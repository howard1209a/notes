<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>树结构总结</title>
    <link href="/notes/2024/03/08/%E7%AE%97%E6%B3%95%E7%AF%87%20%E6%A0%91%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2024/03/08/%E7%AE%97%E6%B3%95%E7%AF%87%20%E6%A0%91%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="树结构总结"><a href="#树结构总结" class="headerlink" title="树结构总结"></a>树结构总结</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul><li>全局定义：每个节点的左子树所有节点均小于当前节点，右子树所有节点均大于当前节点。</li><li>递归定义：根节点的左子树所有节点均小于根节点，根节点的右子树所有节点均大于根节点，且根节点的左右子树均为二叉搜索树。</li></ul><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul><li>全局定义：每个节点的左子树和右子树的深度之差的绝对值不大于 1。</li><li>递归定义：根节点的左子树和右子树的深度之差的绝对值不大于 1，且左右子树均为平衡二叉树。</li></ul><h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><p>AVL 树本质是平衡二叉搜索树，其插入、删除、查找的时间复杂度均为$log(n)$。由于 AVL 树对平衡性的要求比较严格（任意节点左右子树高度之差小于等于 1），因此插入、删除速度相比红黑树更慢（需要做较多的调整），查找速度相比红黑树更快。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种自平衡的二叉搜索树，其插入、删除、查找的时间复杂度均为$log(n)$。但由于红黑树的平衡条件相较于 AVL 更为宽松，因此插入、删除速度相比于 AVL 树更快（需要做的调整较少），查找速度相比于 AVL 树更慢。</p><ul><li>红黑树是二叉搜索树，这也意味着它满足二叉搜索树的定义</li><li>红黑树的平衡条件包括以下四点<ol><li>所有 null 节点都是黑色，这里 null 节点指的是叶节点的左右节点。</li><li>红色节点之间不能相邻</li><li>红黑树中的节点到其任意叶子节点路径上的黑节点个数相同。</li><li>新插入的节点都是红色，在平衡过程中可能变色。</li></ol></li></ul><p>对于一个节点来说，既然左右子树路径上的黑色节点个数相同，因此决定左右子树高度差的因素就是红节点的个数，最极端的情况就是一条子树没有任何红节点，另一条子树尽可能多的有红节点，即红黑节点交替出现（因为红节点之间不能相邻）。因此左右子树高度差不会超过一倍。这保证了红黑树插入、删除、查找的时间复杂度均为$log(n)$。</p><p>红黑树做查找操作时，直接当成普通的二叉搜索树来查找即可。</p><p>红黑树做插入、删除操作时，先只关注红黑树的二叉搜索树性质，相当于对二叉搜索树做插入、删除操作。然后再进行颜色调整和节点调整以满足四点平衡条件，如果仅仅调整颜色就满足四点平衡条件，那么就已经变成了红黑树。如果还需要调整节点，则需要注意调整过程中不要破坏二叉搜索树性质。整个过程分类讨论情况较多。</p><p>具体分类讨论可参考链接资料</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://gufeijun.com/post/map/2/">https://gufeijun.com/post/map/2/</a></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>B 树和 B-树是一个概念。</p><p>B 树和平衡二叉搜索树的不同之处是：B 树属于多叉树又名<strong>平衡多路查找树</strong>，数据库索引技术里大量使用着 B 树和 B+树的数据结构。其中<strong>多路</strong>指的是 B 树是 k 叉树而不是二叉树，<strong>查找树</strong>指的是 B 树仍然具有搜索树的切分性质，<strong>平衡</strong>指的是 B 树的结构就是平衡的，这点从 B 树自身形态以及插入删除的操作对自身形态的维护可以大致看出来。</p><h3 id="B-树构建规则"><a href="#B-树构建规则" class="headerlink" title="B 树构建规则"></a>B 树构建规则</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308190735.png"></p><p>构建 B 树需要满足以下几点</p><ol><li>排序方式：所有节点关键字是按递增次序排列。</li><li>子节点数：非叶节点的子节点数 &gt;1、且子节点数量&lt;&#x3D;M，其中 M 是树的阶数。</li><li>关键字数：枝节点的关键字数量大于等于 M&#x2F;2 个且小于等于 M-1 个。</li><li>所有叶子节点均在同一层。</li></ol><p>观察上图可以看出，首先是 M 把区间切成两半，然后左区间被 D 和 G 切了两刀，右区间被 Q 和 T 切了两刀，然后 D 左边的区间又被 A 和 C 切…</p><h3 id="B-树查询"><a href="#B-树查询" class="headerlink" title="B 树查询"></a>B 树查询</h3><p>比如说查 E，每一层都用二分来查，首先小于 M 往左走，然后大于等于 D 且小于 G，判断不等于 D，往对应子节点走，大于等于 E 且小于 F，判断等于 E，因此查到。</p><h3 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B 树插入"></a>B 树插入</h3><p>定义一个 5 阶树（平衡 5 路查找树），现在我们要把 3、8、31、11、23、29、50、28、53 这些数字依次插入到五阶树中，注意关键字数最多为 4。</p><p>首先插入 3、8、31、11<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308192708.png"></p><p>然后插入 23、29，插入 23 的时候就要拆分了，11 被提起来，发现没有父节点，就新创建一个父节点然后把 11 放进去<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308192952.png"></p><p>最后插入 50、28、53，其中插入 28 的时候再次进行拆分，29 被提到已经存在的父节点<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308193216.png"></p><h3 id="B-树删除"><a href="#B-树删除" class="headerlink" title="B 树删除"></a>B 树删除</h3><p>B 树的删除过程涉及复杂的调整</p><h3 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B 树特点"></a>B 树特点</h3><p>B 树的特点是每个节点都既包含索引数据又包含记录数据。</p><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树在 B 树的基础上进行了改进，首先非叶子结点只存储索引数据不再存储记录数据，所有的记录数据都存储在叶子结点。其次所有叶子结点之间通过指针形成了双向链表。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308195837.png"></p><h3 id="B-树查询-1"><a href="#B-树查询-1" class="headerlink" title="B+树查询"></a>B+树查询</h3><p>比如要查 E 节点，判断 E 属于小于 G 的区间还是大于等于 G 的区间，向子节点走，然后判断 E 属于小于 c、大于等于 c 且小于 E、大于等于 E，向子节点走，最后判断 E 属于小于 E、大于等于 E 且小于 F 还是大于等于 F，结果是 E 大于等于 E 且小于 F，再判断 E 是否等于 E，查到结束。</p><h3 id="B-树插入-1"><a href="#B-树插入-1" class="headerlink" title="B+树插入"></a>B+树插入</h3><p>假设现在构建一棵四阶 B+树，首先插入 A，直接作为根节点。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308200846.png"></p><p>然后插入 B、C、D，插入 D 时超过了节点容量，需要拆分</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308200908.png"></p><p>把 C 提出来，放入父节点，父节点不存在就创建一个，然后分成 AB 和 CD 两个节点，并用指针连接它们</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201050.png"></p><p>下面插入 M，M 大于等于 C，走到右子节点并插入。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201355.png"></p><p>下面插入 L，超过了节点容量，L 被提出来放入父节点，然后拆分</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201532.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201656.png"></p><p>后续非叶节点超过容量时，J 被提起放入父节点，父节点不存在就创建一个</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201935.png"></p><p>剩下的被拆分成了 CH 和 L</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308202122.png"></p><h3 id="innodb-存储引擎索引结构为什么选择-B-树而不是-B-树"><a href="#innodb-存储引擎索引结构为什么选择-B-树而不是-B-树" class="headerlink" title="innodb 存储引擎索引结构为什么选择 B+树而不是 B 树"></a>innodb 存储引擎索引结构为什么选择 B+树而不是 B 树</h3><p>B+树相比于 B 树主要有以下优势</p><ol><li>虽然 B 树不搜索到叶子结点就可以查到记录，但是由于 B 树的非叶子结点存储了记录数据，导致对于固定容量的非叶子结点（非叶子结点的大小有限，需要满足在一定次数的磁盘 IO 后完成对节点的数据读取），B+树相比于 B 树可以存储更多的索引，也就意味着 B+树相比于 B 树更加扁平，一次查询的 IO 次数反而要少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除上的效率相比于 B 树更高，调整的复杂度更低。</li><li>B+ 树叶子节点之间用双向链表连接了起来，有利于范围查询，而 B 树要实现范围查询只能通过树的遍历来完成。</li></ol><h3 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/weixin_52622200/article/details/118530154">https://blog.csdn.net/weixin_52622200/article/details/118530154</a></p><p><a href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在VSCODE中刷力扣</title>
    <link href="/notes/2024/02/26/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E5%A6%82%E4%BD%95%E5%9C%A8VSCODE%E4%B8%AD%E5%88%B7%E5%8A%9B%E6%89%A3/"/>
    <url>/notes/2024/02/26/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E5%A6%82%E4%BD%95%E5%9C%A8VSCODE%E4%B8%AD%E5%88%B7%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="如何在-VSCODE-中刷力扣"><a href="#如何在-VSCODE-中刷力扣" class="headerlink" title="如何在 VSCODE 中刷力扣"></a>如何在 VSCODE 中刷力扣</h1><ol><li>安装 vscode 的力扣扩展</li><li>关闭代理软件</li><li>网页力扣退出登录</li><li>选择中国区<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240226232350.png"></li><li>邮箱登陆即可<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240226232503.png"></li><li>重新登陆力扣网页，选择中等｜已解答或中等｜未解答，然后就可以随机不断地随机一题了<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240226232751.png"><br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240226232919.png"></li><li>复制题号可以在 vscode 上找到对应的题</li></ol><h2 id="如何刷题"><a href="#如何刷题" class="headerlink" title="如何刷题"></a>如何刷题</h2><h3 id="刷新题"><a href="#刷新题" class="headerlink" title="刷新题"></a>刷新题</h3><p>中等+正确率 65%以下+评论数 100 以上，才需要刷</p><h3 id="刷旧题"><a href="#刷旧题" class="headerlink" title="刷旧题"></a>刷旧题</h3><p>做过的题如果再次做，没有思路或者写起来不顺畅，可以添加到错题本中</p><h3 id="刷错题本"><a href="#刷错题本" class="headerlink" title="刷错题本"></a>刷错题本</h3><p>需要定期不断地刷，才能记牢，建议一周复习一次</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EGateway网关代理服务器</title>
    <link href="/notes/2024/02/22/%E9%A1%B9%E7%9B%AE%E7%AF%87%20EGateway%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%20/"/>
    <url>/notes/2024/02/22/%E9%A1%B9%E7%9B%AE%E7%AF%87%20EGateway%E7%BD%91%E5%85%B3%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%20/</url>
    
    <content type="html"><![CDATA[<h1 id="EGateway-网关代理服务器"><a href="#EGateway-网关代理服务器" class="headerlink" title="EGateway 网关代理服务器"></a>EGateway 网关代理服务器</h1><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>难点：</p><ul><li>多线程安全问题，全都是并发场景</li><li>异步编程方式</li><li>大量使用范型和设计模式</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EBed图床网站</title>
    <link href="/notes/2024/02/22/%E9%A1%B9%E7%9B%AE%E7%AF%87%20EBed%E5%9B%BE%E5%BA%8A%E7%BD%91%E7%AB%99%20/"/>
    <url>/notes/2024/02/22/%E9%A1%B9%E7%9B%AE%E7%AF%87%20EBed%E5%9B%BE%E5%BA%8A%E7%BD%91%E7%AB%99%20/</url>
    
    <content type="html"><![CDATA[<h1 id="EBed-图床网站"><a href="#EBed-图床网站" class="headerlink" title="EBed 图床网站"></a>EBed 图床网站</h1><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>项目难点：</p><ul><li>双库同步问题（分布式锁保证双库一致性、rabbitmq 做业务解耦）</li><li>二级缓存开发（解决了缓存击穿、定时失效兜底一致性、rabbitmq 解决 redis 写失败）</li><li>获取经验模块，redis 保存用户状态</li><li>图片批量上传，redis 保存上一次上传的信息</li><li>滚动浏览去重</li><li>全站搜索模块的开发</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二级缓存总结</title>
    <link href="/notes/2024/02/13/%E5%85%AB%E8%82%A1%E7%AF%87%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2024/02/13/%E5%85%AB%E8%82%A1%E7%AF%87%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="二级缓存总结"><a href="#二级缓存总结" class="headerlink" title="二级缓存总结"></a>二级缓存总结</h1><h2 id="正确的二级缓存方式"><a href="#正确的二级缓存方式" class="headerlink" title="正确的二级缓存方式"></a>正确的二级缓存方式</h2><p>首先需要说明的是，二级缓存的增删改查如果上互斥锁的话，将完全保证数据一致性，但是会极大影响效率，所以我们一般不会上锁，而是采用以下的方式</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>在数据库中增加相应条目，此前数据库中一定是没有这些条目的，否则会报异常</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>先删除数据库中相应条目，再删除缓存中相应条目，此前数据库中可能有这些条目，也可能没有这些条目，并不影响</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>先修改数据库中相应条目，再删除缓存中相应条目，此前数据库中可能有这些条目，也可能没有这些条目，并不影响</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>先查缓存，如果有数据就直接返回，如果没有数据就查数据库，如果没有数据就返回空，有数据的话存入缓存后返回，此前数据库中可能有这些条目，也可能没有这些条目，并不影响</p><h2 id="并发数据一致性分析"><a href="#并发数据一致性分析" class="headerlink" title="并发数据一致性分析"></a>并发数据一致性分析</h2><p>那么为什么上述的增删改查方式几乎不会出现数据一致性问题呢？首先需要明确几点</p><ol><li>数据库保证了关于相同条目操作的原子性</li><li>缓存保证了关于相同条目操作的原子性</li><li>前后两个操作之间存在顺序性，比如改操作，先改数据库再删缓存</li><li>数据库的读写时间远远长于缓存的读写时间</li></ol><p>下面是四种操作的时序图，其中查询只考虑了缓存没查到的情况，因为缓存查到了就会直接返回，并不会带来数据一致性问题<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214143806.png"></p><p>首先明确如下两种情况是结果等价的，比如我们把改和查 2 放在一起，其中改操作的第一步修改数据库操作完成后，根据顺序性，当前线程下一步的删除缓存开始执行，根据原子性，另一个线程的查询数据库开始执行。由于数据库的读写时间远远长于缓存的读写时间，所以可以等价于先执行删除缓存，再执行查询数据库，这在结果上是一样的。即结果等价于改和查 2 是串行执行的。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214144903.png"></p><p>接下来考虑增、删、改、查 1、查 2 这几种操作的任意并发情况，其实从结果上来看等价于所有操作都是串行执行的，因此不会出现数据库和缓存之间的数据一致性问题。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214151609.png"></p><h2 id="一些额外的操作"><a href="#一些额外的操作" class="headerlink" title="一些额外的操作"></a>一些额外的操作</h2><p>上面我们已经证明了正确的增删改查操作不会带来并发数据一致性问题，然而有时我们会有一些额外的操作，这些操作也是不会带来数据一致性问题的。</p><h3 id="手动缓存失效或超时缓存失效"><a href="#手动缓存失效或超时缓存失效" class="headerlink" title="手动缓存失效或超时缓存失效"></a>手动缓存失效或超时缓存失效</h3><p>比如我们设置一个接口，让相应缓存条目失效，或者设置缓存本身的超时失效。</p><h3 id="读缓存"><a href="#读缓存" class="headerlink" title="读缓存"></a>读缓存</h3><p>比如我们设置一个接口，读缓存中的相应条目，或查操作本身第一步就是读缓存。</p><h2 id="为什么先改再删而不是先删再改"><a href="#为什么先改再删而不是先删再改" class="headerlink" title="为什么先改再删而不是先删再改"></a>为什么先改再删而不是先删再改</h2><p>之所以先改再删是为了将耗时长的数据库读写操作放在前面，将耗时短的缓存读写操作放在后面，这样才能保证串行等价性。</p><p>而如果先删再改的话，就有可能出现一方包裹另一方或者交替执行的非串行执行方式，如下图所示<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214154830.png"></p><h3 id="先删再改并发问题实例"><a href="#先删再改并发问题实例" class="headerlink" title="先删再改并发问题实例"></a>先删再改并发问题实例</h3><p>下面这种情况很容易发生<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214155219.png"></p><h3 id="先改再删并发问题实例"><a href="#先改再删并发问题实例" class="headerlink" title="先改再删并发问题实例"></a>先改再删并发问题实例</h3><p>下面这种情况几乎不可能发生<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214155336.png"></p><h2 id="为什么删除缓存而不是更新缓存"><a href="#为什么删除缓存而不是更新缓存" class="headerlink" title="为什么删除缓存而不是更新缓存"></a>为什么删除缓存而不是更新缓存</h2><p>删除一个数据，相比更新一个数据更加轻量级，操作执行的更快，因此出现数据一致性问题的概率更小。从另外一个角度来看，删除缓存也可以及时清理掉不频繁访问的缓存。</p><h2 id="超时缓存失效的兜底方案"><a href="#超时缓存失效的兜底方案" class="headerlink" title="超时缓存失效的兜底方案"></a>超时缓存失效的兜底方案</h2><p>无论任何时候，我们都不保证二级缓存百分百的一致性，先改再删的小概率事件、程序异常等原因都可能造成二级缓存的数据一致性问题，而前面也已经说明了手动或自动的缓存失效并不会对二级缓存带来问题，所以我们可以定期地手动清除缓存，或者设置超时缓存失效来兜底，这样即使出现了数据不一致的情况，也能在一段时间后恢复一致。</p><h2 id="删除缓存失败的解决办法"><a href="#删除缓存失败的解决办法" class="headerlink" title="删除缓存失败的解决办法"></a>删除缓存失败的解决办法</h2><p>比如在数据库和缓存都有值的情况下进行改操作，先改数据库，成功了，然后删除缓存失败了，此时缓存中就一直是旧值了。</p><p>解决方法有两种</p><ul><li>重试机制。</li><li>订阅 MySQL binlog，再操作缓存</li></ul><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>本质是当删除缓存失败的时候，不断地重试，因为删除缓存失败本来就是小概率事件，所以几次重试几乎可以认为一定成功。</p><p>可以利用消息队列完成，之前是修改数据库后直接删除缓存，现在是修改数据库后就生产一条消息到 mq 中，由消费者消费这条消息并删除缓存，如果消费者删除缓存失败，就重新获取消息进行重试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM总结</title>
    <link href="/notes/2024/02/05/%E6%80%BB%E7%BB%93%E7%AF%87%20JVM%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2024/02/05/%E6%80%BB%E7%BB%93%E7%AF%87%20JVM%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-总结"><a href="#JVM-总结" class="headerlink" title="JVM 总结"></a>JVM 总结</h1><h2 id="字节码文件详解"><a href="#字节码文件详解" class="headerlink" title="字节码文件详解"></a>字节码文件详解</h2><h3 id="Java-虚拟机的组成"><a href="#Java-虚拟机的组成" class="headerlink" title="Java 虚拟机的组成"></a>Java 虚拟机的组成</h3><p>JVM 本质上是一个运行在计算机上的进程，它的主要职责是</p><ul><li>解释运行：解释运行字节码中的指令</li><li>内存管理：为对象、方法等分配内存，自动进行垃圾回收</li><li>即时编译：对热点代码进行优化，提升执行效率</li></ul><p>常见的 JVM 有很多实现，他们都遵循 Oracle 制定的 Java 虚拟机规范</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240205193708.png"></p><h3 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h3><h4 id="字节码文件包含哪些信息"><a href="#字节码文件包含哪些信息" class="headerlink" title="字节码文件包含哪些信息"></a>字节码文件包含哪些信息</h4><p>字节码文件中保存了源代码编译之后的内容，以二进制文件的方式存储，可以用 jclasslib 工具解析字节码文件信息。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240205191944.png"></p><h5 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h5><p>magic 魔数用来标识二进制文件的类型。版本号用来标识编译此字节码文件的编译器版本，此版本必须小于等于 JVM 版本。</p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>存放字符串常量</p><p>常量池中的数据都有一个编号，编号从 1 开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>存放每个方法的字节码指令序列，下面是一个示例，两个核心部分分别是操作数栈和局部变量表</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240205193307.png"></p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240205195048.png"></p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>类加载器根据类的全限定名通过读取磁盘上的字节码文件或动态代理生成的方式获取字节码。</p><p>加载完成后，JVM 会在方法区类信息内存中生成一个 C++的 InstanceKlass 对象，在堆区生成一个 class 对象，class 对象中存储了该类的所有静态属性。</p><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>检测 Java 字节码文件是否遵守 Java 虚拟机规范</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为所有静态属性分配内存并设置初始值</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中的符号引用替换为内存直接引用。在类加载之前只看字节码文件的话，比如字节码指令序列中调了<code>#6</code>方法，我们只能在常量池中找到这个方法的类名方法名，而在类加载中替换为内存直接引用后，我们就能在方法区运行时常量池中直接得到此方法的内存地址，因为此时此方法所在类一定已经加载到了方法区类信息中。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>按顺序进行所有静态属性的初始化和静态代码块的运行。本质是执行字节码文件中 clinit 部分的字节码指令。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240205201612.png"></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器(ClassLoader)只负责类加载中的加载阶段。读入字节码数据放入内存转换成 byte[]，接下来调用虚拟机底层 native 方法根据 byte[]在方法区类信息生成 InstanceKlass 对象，在堆区生成 class 对象。</p><h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><p>使用 C++实现的类加载器，加载 Java 中最核心的类，默认加载 Java 安装目录&#x2F;jre&#x2F;lib 下的类文件。</p><h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><p>使用 Java 实现的类加载器，加载 Java 中的扩展类，默认加载 Java 安装目录&#x2F;jre&#x2F;lib&#x2F;ext 下的类文件。</p><h5 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h5><p>使用 Java 实现的类加载器，加载源码类和 jar 包类，默认加载 classpath 下的类文件。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>当我们使用应用程序类加载器或扩展类加载器去加载类的时候（注意我们在 java 代码中拿不到启动类加载器），会从下向上的判断要加载的类是否已经被当前类加载器加载，如果已被加载则直接返回。如果一直到启动类加载器都没有加载过，则从上到下判断哪个加载器可以加载该类，如果找到就加载后返回，如果找不到最后抛出 ClassNotFoundException</p><p>两种方法的区别：</p><ul><li>loadClass 方法：只加载，不会连接和初始化</li><li>forName 方法：加载连接初始化</li></ul><p>双亲委派机制的作用：</p><ul><li>避免重复加载</li><li>保证类加载的安全性，避免恶意代码替换 JDK 中的核心类库</li></ul><h4 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h4><p>自定义类加载器，重写 loadClass 方法，即可打破双亲委派机制。</p><h5 id="为什么要打破双亲委派机制"><a href="#为什么要打破双亲委派机制" class="headerlink" title="为什么要打破双亲委派机制"></a>为什么要打破双亲委派机制</h5><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240206112214.png"></p><p>两个自定义类加载器加载相同限定名的类，不会冲突，因为在同一个 Java 虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类。</p><h5 id="SPI-机制"><a href="#SPI-机制" class="headerlink" title="SPI 机制"></a>SPI 机制</h5><p>JDBC 中使用了 DriverManager 来管理项目中引入的不同数据库的驱动，比如 mysql 驱动、oracle 驱动。实际应用中，只需要引入相关数据库驱动的 jar 包即可自动进行类加载，这个过程依靠 SPI 机制实现。</p><p>SPI 是一个为某个接口自动装配实现实例的机制。有点类似 IOC 的思想，就是将装配的控制权移到程序之外。当服务的提供者，提供了服务接口的一种实现之后，在 jar 包的 META-INF&#x2F;services&#x2F;目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类的类名。而当外部程序装配这个模块的时候，就能通过该 jar 包 META-INF&#x2F;services&#x2F;里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p><h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240206192912.png"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>每个线程会通过程序计数器记录当前要执行的的字节码指令的地址，程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。</p><p>程序计数器不存在内存溢出问题</p><h3 id="方法栈"><a href="#方法栈" class="headerlink" title="方法栈"></a>方法栈</h3><p>Java 虚拟机栈和本地方法栈本质是一个方法栈。方法栈中是一个个栈帧，每个栈帧都存了局部变量表、操作数栈和帧数据。</p><ul><li>局部变量表：存放方法中的 this 对象地址、形参以及局部变量</li><li>操作数栈：虚拟机在执行指令过程中用来存放临时数据的一块区域</li><li>帧数据：当前栈帧结束后的返回地址、异常表等</li></ul><p>栈帧过多（比如无限递归），超过栈内存最大大小就会出现内存溢出 StackOverflowError</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>存放所有对象。堆空间有三个需要关注的值，used total max。used 指的是当前已使用的堆内存，total 是 java 虚拟机已经分配的可用堆内存，max 是 java 虚拟机可以分配的最大堆内存。</p><p>对象过多或对象中数据过大会出现堆内存溢出<code>OutOfMemory</code></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>又称元空间，使用的是直接内存</p><p>存放类信息、运行时常量池、字符串常量池</p><ul><li>类信息：所有已经加载的类的 InstanceKlass 对象</li><li>运行时常量池：存放常量符号到内存地址的直接映射，包括类、接口、属性等等</li><li>字符串常量池：存储在代码中定义的常量字符串内容</li></ul><p>当无限加载类的时候，方法区也是会内存溢出的，报<code>java.lang.OutOfMemoryError: Metaspace</code></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不会被 GC，常应用于 NIO，目的是为了减少内存复制次数。</p><h2 id="自动垃圾回收"><a href="#自动垃圾回收" class="headerlink" title="自动垃圾回收"></a>自动垃圾回收</h2><p>Java 中为了简化对象内存的释放，引入了自动的垃圾回收(Garbage Collection 简称 GC)机制。</p><h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>线程独享的程序计数器和方法栈是不需要垃圾回收的。</p><p>方法区的回收主要就是类的卸载，当满足如下三个条件时，方法区类信息中该类的 InstanceKlass 对象被清除，运行时常量池和字符串常量池中该类相关的数据被清除，堆区中该类的 class 对象被清除。</p><ul><li>此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。</li><li>加载该类的类加载器已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用。</li></ul><p>如果我们不自定义类加载器的话，则所有类都是由启动类加载器或扩展类加载器或应用程序类加载器加载的，则不会出现类的卸载。</p><p>调用 System.gc()方法并不一定会立即回收垃圾，仅仅是向 Java 虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收 Java 虚拟机会自行判断。</p><h3 id="堆区回收"><a href="#堆区回收" class="headerlink" title="堆区回收"></a>堆区回收</h3><h4 id="引用计数法和可达性分析法"><a href="#引用计数法和可达性分析法" class="headerlink" title="引用计数法和可达性分析法"></a>引用计数法和可达性分析法</h4><p>一个 java 对象是否可以被回收取决于这个对象是否仍被引用</p><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>为每个对象维护一个引用计数器，当对象被引用时加 1，取消引用时减 1。</p><h5 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h5><p>JVM 使用的就是这种方法。可达性分析法将对象分为两类:垃圾回收的根对象(GC Root 对象)和普通对象，对象与对象之间存在引用关系。一个对象只要能追溯到某个 GC Root 对象，则它就不能被回收。</p><p>GC Root 对象有四类：</p><ul><li>线程 Thread 对象，关联该线程方法栈中所有 this 对象、形参、局部变量</li><li>class 对象，关联该类的所有静态属性</li><li>synchronized 关键字持有的对象</li><li>本地方法调用时使用的全局对象（不需要关注）</li></ul><p>下图是一个示例：<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207145226.png"></p><h4 id="五种对象引用"><a href="#五种对象引用" class="headerlink" title="五种对象引用"></a>五种对象引用</h4><ul><li>强引用：可达性算法描述的引用</li><li>软引用：如果一个对象只有软引用关联到它，当堆内存不足时，就会将该对象回收，JDK 提供 SoftReference 类来实现软引用。软引用适用于缓存场景。</li><li>弱引用：弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。</li><li>虚引用</li><li>终结器引用</li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207172743.png"></p><h5 id="GC-算法的评价标准"><a href="#GC-算法的评价标准" class="headerlink" title="GC 算法的评价标准"></a>GC 算法的评价标准</h5><ul><li>吞吐量：执行用户代码时间 &#x2F; (执行用户代码时间 + GC 时间)</li><li>最大暂停时间：所有垃圾回收过程中的 STW 时间最大值</li><li>堆使用效率：百分之多少的堆内存能够用于实际存放对象</li></ul><h5 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h5><p>利用可达性分析算法，从 GC Root 开始通过引用链遍历并标记所有存活对象，然后清除所有未标记对象</p><h5 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h5><p>利用可达性分析算法，从 GC Root 开始通过引用链遍历并标记所有存活对象，将所有存活对象移动到堆的一端</p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>将堆内存分割成两块相等的 from 空间 to 空间，在 from 空间存放对象，GC 时将 From 中存活对象复制到 To 空间，将两块空间的 From 和 To 名字互换</p><h5 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h5><p>分代算法将堆内存划分为年轻代和老年代，其中年轻代又分为伊甸园区和幸存者区，幸存者区分为 from 空间和 to 空间。新创建的对象会被放入伊甸园区，伊甸园区满会触发 Minor GC，将伊甸园区和 From 空间中需要回收的对象回收，把没有回收的对象放入 To 区，然后交换 from 和 to 名字。每次 Minor GC 都会让对象年龄加一。如果 Minor GC 后对象的年龄达到阈值，该对象就会被转移到老年代。当老年代空间不足时会触发 Full GC，Full GC 会对年轻代、老年代和元空间（方法区）进行回收。如果 Full GC 后老年代空间仍然不足，则会抛出 Out Of Memory 异常。</p><p>为什么分代算法要分年轻代和老年代，原因是防止长期存活对象在 from 空间和 to 空间之间被不断复制。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207181056.png"></p><h4 id="几种垃圾回收器"><a href="#几种垃圾回收器" class="headerlink" title="几种垃圾回收器"></a>几种垃圾回收器</h4><p>需要掌握下图三条实线连接的垃圾回收器和 G1 垃圾回收器，实际具体选择哪种垃圾回收器，和业务类型相关。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207183700.png"></p><h5 id="Serial-SerialOld"><a href="#Serial-SerialOld" class="headerlink" title="Serial-SerialOld"></a>Serial-SerialOld</h5><p>Serial 和 SerialOld 都是单线程串行垃圾回收器</p><p>Serial-SerialOld 适用于单核 cpu</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207184741.png"></p><h5 id="ParNew-CMS"><a href="#ParNew-CMS" class="headerlink" title="ParNew-CMS"></a>ParNew-CMS</h5><p>ParNew 是多线程串行垃圾回收器<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207190638.png"></p><p>CMS 的过程比较复杂，涉及到串行&#x2F;并行，单线程&#x2F;多线程<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207190753.png"></p><p>ParNew-CMS 适用于大型的互联网系统中用户请求数据量大、频率高的场景。比如订单接口、商品接口等</p><h5 id="PS-PO"><a href="#PS-PO" class="headerlink" title="PS-PO"></a>PS-PO</h5><p>JDK8 默认的垃圾回收器，Parallel Scavenge 和 Parallel Old 都是多线程串行垃圾回收器，可以自动调整堆内存大小</p><p>PS-PO 相比于 STW 更关注吞吐量大小，因此适用于不需要与用户交互的后台任务处理。比如:大数据的处理，大文件导出</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240207191944.png"></p><h5 id="G1-垃圾回收器"><a href="#G1-垃圾回收器" class="headerlink" title="G1 垃圾回收器"></a>G1 垃圾回收器</h5><p>JDK9 及之后的默认垃圾回收器。性能要高于其他垃圾回收器。</p><h2 id="实际业务调优"><a href="#实际业务调优" class="headerlink" title="实际业务调优"></a>实际业务调优</h2><h3 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h3><p>观察程序的堆内存曲线，如果正常就不需要进行内存调优，如果异常比如发现了存在大量不可回收对象或存在内存泄露或出现内存突然飙高乃至溢出的现象，这时就需要进行内存调优，找到大量不可回收对象是什么、哪里出现的内存泄露、内存溢出是什么原因（是持续性的内存泄露导致的，还是内存峰值过高导致的，如果是内存峰值过高导致的，要么分配更多的堆内存、要么修改代码降低内存峰值）</p><p>堆内存泄漏：某个对象不再使用却仍然引用它，该对象依然在 GC ROOT 的引用链上</p><h4 id="一些可能引起内存溢出的原因"><a href="#一些可能引起内存溢出的原因" class="headerlink" title="一些可能引起内存溢出的原因"></a>一些可能引起内存溢出的原因</h4><ul><li>持续的内存泄露<ul><li>往 ThreadLocal 里面放对象后不去清除，这时只要这个线程没有结束，ThreadLocal 里面的对象就会一直在。这种情况常发生于线程池。</li><li>大量的数据在静态属性中被引用，但是不再使用，成为了内存泄漏。</li></ul></li><li>并发请求问题：某些接口由于用户的并发请求量有可能很大，同时处理数据的时间很长，导致大量的数据存在于内存中，最终超过了内存的上限，导致内存溢出。</li></ul><h4 id="发现内存问题"><a href="#发现内存问题" class="headerlink" title="发现内存问题"></a>发现内存问题</h4><ul><li>top 命令：实时地查看系统的资源</li><li>VisualVM：监控一个 Java 进程的堆内存曲线，微服务比较多的时候不太方便用</li><li>Arthas：功能很强大的线上监控诊断产品</li><li>Prometheus + Grafana：企业中运维常用的监控方案，其中 Prometheus 用来采集系统或者应用的相关数据，同时具备告警功能。Grafana 可以将 Prometheus 采集到的数据以可视化的方式进行展示。</li></ul><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240208160227.png"></p><h4 id="定位问题代码"><a href="#定位问题代码" class="headerlink" title="定位问题代码"></a>定位问题代码</h4><p>我们可以通过<code>-XX:+HeapDumpOnOutOfMemoryError</code>虚拟参数，设置堆内存溢出时自动生成内存快照（hprof 文件），将整个堆内存保存下来。</p><p><code>-XX:+HeapDumpBeforeFullGC</code>虚拟机参数可以在 FullGC 之前生成内存快照。</p><p>如果要导出运行中系统的内存快照</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240208164715.png"></p><h5 id="MAT-软件分析内存快照文件"><a href="#MAT-软件分析内存快照文件" class="headerlink" title="MAT 软件分析内存快照文件"></a>MAT 软件分析内存快照文件</h5><p>MAT 会首先生成一个支配树，在对象引用<br>图中，所有指向对象 B 的路径都经过对象 A，则认为对象 A 支配对象 B。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240208162855.png"></p><p>对于支配树中的某个节点对象，对象本身占用的空间称为浅堆，对象子树的所有空间称为深堆，深堆的大小表示该对象如果可以被回收，能释放多大的内存空间。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240208163333.png"></p><p>MAT 就是遍历支配树，如果发现某节点深堆的大小超过整个堆内存的一定比例阈值，就会将其标记成内存泄漏的”嫌疑对象”</p><h4 id="排查内存问题的方式"><a href="#排查内存问题的方式" class="headerlink" title="排查内存问题的方式"></a>排查内存问题的方式</h4><ol><li>服务出现 OOM 内存溢出时，生成内存快照</li><li>使用 MAT 分析内存快照，找到内存溢出的对象</li><li>尝试在开发环境中重现问题，分析代码中问题产生的原因</li><li>修改代码</li><li>测试并验证结果</li></ol><h4 id="一些设计上引起的内存溢出"><a href="#一些设计上引起的内存溢出" class="headerlink" title="一些设计上引起的内存溢出"></a>一些设计上引起的内存溢出</h4><ul><li>某分页查询接口 OOM，问题根源是高并发、单次查询数据量大<ol><li>限制单次查询数据量</li><li>高峰期直接限流保护</li></ol></li><li>某并发处理大量数据的程序 OOM，问题根源是线程每次读入内存的数据量过大，导致内存峰值过大<ol><li>减少单批读入内存的数据量大小</li></ol></li></ul><h3 id="GC-调优"><a href="#GC-调优" class="headerlink" title="GC 调优"></a>GC 调优</h3><p>观察程序的 GC 吞吐量和 GC STW 值，如果 GC 吞吐量较高、STW 很低，那么就不需要进行 GC 调优，如果出现了 GC 吞吐量低、STW 较高的情况，那么就需要进行 GC 调优，首先如果出现了频繁 FULLGC，那么是由于内存过高导致的，这时又回到了内存调优，如果不存在频繁 FULLGC 现象，我们可以选择合适的垃圾回收器、设置合适的 JVM 参数来提高 GC 效率。</p><h4 id="发现-GC-问题"><a href="#发现-GC-问题" class="headerlink" title="发现 GC 问题"></a>发现 GC 问题</h4><p>通过 GC 日志，可以得到每次 GC 的详细信息，比如本次 GC 使用什么垃圾回收器、是 MinorGC 还是 FullGC、回收了多少内存、耗时多久等等。</p><ul><li>使用方法(JDK 8 及以下):<code>-XX:+PrintGCDetails -Xloggc:文件名</code></li><li>使用方法(JDK 9+):<code>-Xlog:gc\*:file=文件名</code></li></ul><p>我们可以用 GCeasy 来分析 GC 日志，网址是<code>https://gceasy.io/</code></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210154617.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210154734.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210154816.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210160447.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210160625.png"></p><h4 id="解决-GC-问题的手段"><a href="#解决-GC-问题的手段" class="headerlink" title="解决 GC 问题的手段"></a>解决 GC 问题的手段</h4><h5 id="优化基础-JVM-参数"><a href="#优化基础-JVM-参数" class="headerlink" title="优化基础 JVM 参数"></a>优化基础 JVM 参数</h5><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210161146.png"></p><p>-Xmx 和 –Xms 一般设置成相等的值</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210161529.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210161607.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210163225.png"></p><p>其余 JVM 参数如年轻代大小、伊甸园区和幸存者区内存比例等不建议自己设置</p><h5 id="更换垃圾回收器"><a href="#更换垃圾回收器" class="headerlink" title="更换垃圾回收器"></a>更换垃圾回收器</h5><p>根据业务类型和垃圾回收器特性设置即可</p><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>性能调优适用于，在不需要进行内存调优和 GC 调优时，发现程序导致 cpu 飙高或某个接口响应时间过长或出现死锁，这时可以进行性能调优。</p><h4 id="cpu-飙高问题"><a href="#cpu-飙高问题" class="headerlink" title="cpu 飙高问题"></a>cpu 飙高问题</h4><p>利用<code>top</code>命令定位哪个进程的哪个线程存在很高的 cpu 占用率，使用<code>jstack 进程ID &gt; 文件名</code>命令进行 Thread Dump 线程转储（打一份线程当前状态的快照）。然后查看下 cpu 飙高线程当前的方法栈。</p><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>通过<code>jstack -l 进程ID &gt; 文件名</code>命令进行线程 dump，然后在文件中搜索 deadlock 即可找到死锁位置。</p><h4 id="接口响应时间很长问题"><a href="#接口响应时间很长问题" class="headerlink" title="接口响应时间很长问题"></a>接口响应时间很长问题</h4><p>我们需要定位接口中的哪一部分代码导致的性能问题，可以借助 Arthas 的 trace 命令。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240210184244.png"></p><h4 id="如何测试一个方法的耗时"><a href="#如何测试一个方法的耗时" class="headerlink" title="如何测试一个方法的耗时"></a>如何测试一个方法的耗时</h4><p>由于存在懒加载对象，所以第一次方法调用的时间有可能很长，由于多次执行方法 JIT 会进行优化，因此经过充分预热后的测试才是准确的。因此我们一般使用 JMH 框架进行预热后的测试。</p><h2 id="JVM-扩展知识"><a href="#JVM-扩展知识" class="headerlink" title="JVM 扩展知识"></a>JVM 扩展知识</h2><h3 id="GraalVM"><a href="#GraalVM" class="headerlink" title="GraalVM"></a>GraalVM</h3><p>GraalVM 是 Oracle 官方推出的一款高性能 JDK，核心优势是可以编译成可执行文件（失去跨平台特性），具有更快的启动速度、更低的内存和 cpu 使用率。</p><h3 id="新一代的-GC"><a href="#新一代的-GC" class="headerlink" title="新一代的 GC"></a>新一代的 GC</h3><h4 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h4><p>Shenandoah 是由 Red Hat 开发的一款低延迟的垃圾回收器，无论堆大小如何，Shenandoah 都能通过多次回收的方式将 STW 尽量控制在 10ms 以下。</p><p>Shenandoah 不是 oraclejdk 的可选垃圾回收器，它只存在于 openjdk 中。</p><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>ZGC 是 oracle 开发的低延迟垃圾回收器，将 STW 尽量控制在了 1ms 以下，ZGC 吞吐量不佳，且垃圾回收会占用大量额外堆内存，OracleJDK 和 OpenJDK 中都支持 ZGC。</p><h3 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h3><p>Java Agent 技术是 JDK 提供的用来编写 Java 工具的技术，使用这种技术生成一种特殊的 jar 包，这种 jar 包可以让一个 Java 进程静态或动态地运行其中的代码。</p><h4 id="静态加载模式"><a href="#静态加载模式" class="headerlink" title="静态加载模式"></a>静态加载模式</h4><p><code>java</code>命令运行时就指定好 Java Agent 的 jar 包，主线程会在执行 main 方法前先执行 premain 方法</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240211181717.png"></p><h4 id="动态加载模式"><a href="#动态加载模式" class="headerlink" title="动态加载模式"></a>动态加载模式</h4><p>首先开启被加载的 java 进程，然后打开另一个 java 进程，给这个 java 进程输入被加载的 java 进程的进程号和 Java Agent 的 jar 包路径，这样这两个 java 进程可以通信，被加载的 java 进程也就能拿到 jar 包中的字节码，它会开一个新的线程来运行这段字节码。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240211182146.png"></p><h4 id="字节码增强技术"><a href="#字节码增强技术" class="headerlink" title="字节码增强技术"></a>字节码增强技术</h4><p>静态加载模式是在主线程 main 方法之前执行一段代码，动态加载模式是随时单开一个线程执行一段代码。</p><p>借助 ASM 或 Byte Buddy 这两个字节码增强技术框架，我们可以修改加载到 JVM 内存中的字节码，比如在字节码指令序列的开头统计当前时间，在字节码指令序列的结尾统计当前时间然后相减得到该方法的执行时间。ASM 框架比较底层不太容易用，Byte Buddy 框架基于 ASM 框架开发，要简单一些。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240211185740.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240211185805.png"></p><h2 id="JVM-底层原理"><a href="#JVM-底层原理" class="headerlink" title="JVM 底层原理"></a>JVM 底层原理</h2><h3 id="栈上的数据存储"><a href="#栈上的数据存储" class="headerlink" title="栈上的数据存储"></a>栈上的数据存储</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212104643.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212113147.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212113301.png"></p><p>无论是 32 位还是 64 位虚拟机，对于任意数值类型来说，栈内存字节数一定大于等于堆内存字节数。比如在 32 位虚拟机中 double 堆内存 8 字节、栈内存 8 字节，在 64 位虚拟机中 double 堆内存 8 字节、栈内存 16 字节。</p><p>栈内存比堆内存大是存在空间浪费的，这是一种空间换时间的方案，在栈中不区分数值类型直接按槽 slot 进行计算，省去了根据不同数值类型进行不同计算方式的过程。</p><p>堆中数据保存到栈上，无符号高位补 0 有符号高位补 0 或 1，栈中数据保存到堆上，超出部分舍弃即可。</p><h3 id="对象在堆上是如何存储的"><a href="#对象在堆上是如何存储的" class="headerlink" title="对象在堆上是如何存储的"></a>对象在堆上是如何存储的</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212122153.png"></p><p>其中 Klass Word(Klass pointer)指向方法区栈信息中 InstanceKlass 对象的地址，32 位虚拟机中 Mark Word 和 Klass Word 都占 4 字节，64 位虚拟机中 Mark Word 和 Klass Word 都占 8 字节</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212115608.png"></p><h4 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212115816.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212120119.png"></p><p>指针压缩虽然可以降低对象占用内存，但也有两个问题，第一是要求所有对象占用堆内存的大小是 8 字节的倍数（内存对齐），第二是寻址范围变小，不用压缩指针，应该是 2 的 64 次方 &#x3D; 16EB，用了压缩指针就变成了 8(字节) &#x3D; 2 的 3 次方 * 2 的 32 次方 &#x3D; 2 的 35 次方</p><h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p>内存对齐主要目的是为了解决并发情况下 CPU 缓存失效的问题，一个 cpu 缓存内存块大小是 8 字节，要求所有对象占用堆内存的大小是 8 字节倍数的情况下，使得每个对象完整的占满整数个 cpu 缓存内存块，这样某个对象 cpu 缓存失效并不会导致其他对象 cpu 缓存失效。</p><h5 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h5><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212121819.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212121843.png"></p><h3 id="方法调用的原理"><a href="#方法调用的原理" class="headerlink" title="方法调用的原理"></a>方法调用的原理</h3><p>方法调用的本质是在栈上创建栈帧，然后程序计数器指向方法中的第一行字节码指令。以 invoke 开头的字节码指令的作用是执行方法的调用。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212123003.png"></p><h4 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212122542.png"></p><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212122827.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212122845.png"></p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212122902.png"></p><h3 id="异常捕获的原理"><a href="#异常捕获的原理" class="headerlink" title="异常捕获的原理"></a>异常捕获的原理</h3><h4 id="try-catch-实现"><a href="#try-catch-实现" class="headerlink" title="try-catch 实现"></a>try-catch 实现</h4><p>编译时字节码中生成的异常表在类加载后会存储到方法区的类信息中，在执行该方法时，异常表会被加载到栈帧的帧数据中，异常表中包含了该方法异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212125203.png"></p><p>程序运行中触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。</p><ol><li>如果匹配，跳转到“跳转 PC”对应的字节码位置。</li><li>如果遍历完都不能匹配，说明异常无法在当前方法执行时被捕获，此方法栈帧直接弹出，在上一层的栈帧中进行异常捕获的查询。</li></ol><h4 id="finally-实现"><a href="#finally-实现" class="headerlink" title="finally 实现"></a>finally 实现</h4><p>finally 中的字节码指令会插入到 try 和 catch 代码块中，保证在 try 和 catch 执行之后一定会执行 finally 中的代码。如下图所示，其中<code>iconst_3 istore1</code>这两条指令在三个位置出现了，这样就保证了没有抛异常、抛异常但捕获、抛异常但未捕获三种情况都会执行 finally 中的代码。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212131857.png"></p><h3 id="JIT-即时编译器"><a href="#JIT-即时编译器" class="headerlink" title="JIT 即时编译器"></a>JIT 即时编译器</h3><p>执行一条字节码指令的时候，首先解释器会进行语法分析，然后根据结果进行对应的操作，这个逻辑是在 C++层面实现的，但是 JVM 本质是一个可执行文件，因此运行的还是机器码。JIT 会对一些热点方法的字节码进行优化，直接将其编译成机器码同时进行一些效率优化，之后执行这段字节码时就不再解释执行而是直接执行机器码，相比于解释执行更快的原因在于：</p><ol><li>这段机器码不是 C++逻辑编译生成的，而是字节码直接编译生成的</li><li>进行了一些优化</li><li>省去了语法解析的过程</li></ol><h4 id="JIT-即时编译器种类"><a href="#JIT-即时编译器种类" class="headerlink" title="JIT 即时编译器种类"></a>JIT 即时编译器种类</h4><p>在 HotSpot 中，有三款即时编译器，C1、C2 和 Graal，其中 Graal 在 GraalVM 章节中已经介绍过。 C1 编译效率比 C2 快，但是优化效果不如 C2。</p><p>C1 即时编译器和 C2 即时编译器都有独立的线程去进行处理，内部会保存一个队列，队列中存放需要编译的任务。一般即时编译器是针对方法级别来进行优化的，当然也有对循环进行优化的设计。</p><h4 id="常见的-JIT-即时编译器优化手段"><a href="#常见的-JIT-即时编译器优化手段" class="headerlink" title="常见的 JIT 即时编译器优化手段"></a>常见的 JIT 即时编译器优化手段</h4><h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><p>方法体中的字节码指令直接复制到调用方的字节码指令中，节省了创建栈帧的开销。</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>如果方法中的一个对象不会逃逸，只会被当前局部变量引用（不会调别的方法把这个对象传进去，也不会将这个对象 return 出去），那么该对象可以直接在栈上分配内存，不用分配堆内存。下面是一个例子</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240212134513.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法知识点检查总结</title>
    <link href="/notes/2024/01/28/%E6%80%BB%E7%BB%93%E7%AF%87%20%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A3%80%E6%9F%A5%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2024/01/28/%E6%80%BB%E7%BB%93%E7%AF%87%20%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A3%80%E6%9F%A5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="算法知识点检查总结"><a href="#算法知识点检查总结" class="headerlink" title="算法知识点检查总结"></a>算法知识点检查总结</h1><ul><li>单调栈<ul><li>单调栈的结构和作用</li><li>单调栈的执行过程是怎么样的</li><li>八种需求和四种单调栈的对应关系</li></ul></li><li>单调队列 (见”滑动窗口最大值”)<ul><li>单调队列的结构和作用</li><li>单调队列的执行过程是怎么样的</li></ul></li><li>优先队列<ul><li>优先队列的结构和作用</li><li>优先队列的执行过程是怎么样的</li></ul></li><li>大根堆小根堆<ul><li>堆的递归定义和全局定义</li><li>堆的向上向下两种调整方式</li><li>建堆过程</li></ul></li><li>背包<ul><li>01 背包的标准模型，二维 dp 和滚动数组写法</li><li>完全背包标准模型，二维 dp 和滚动数组写法</li></ul></li><li>动态规划<ul><li>动态规划的五个步骤</li></ul></li><li>二叉树<ul><li>二叉树的前中后序遍历，递归和迭代方式</li><li>二叉树的广度优先遍历，队列方式</li></ul></li><li>回溯<ul><li>组合、情况相乘、子集、可多取的子集、去重子集、全排列、去重全排列分别都怎么写</li></ul></li><li>图论 DFS 和 BFS<ul><li>无向图<ul><li>DFS 搜每一个点、DFS 搜所有路径</li><li>BFS 搜每一个点</li></ul></li><li>有向图<ul><li>DFS 搜每一个可到达点</li><li>DFS 搜所有路径</li></ul></li></ul></li><li>二分法（递增、非严格递增、递减、非严格递减）<ul><li>找等于 target 的数</li><li>递增&#x2F;非严格递增的情况下，找小于&#x2F;小于等于 target 的最右边的数，或找大于&#x2F;大于等于 target 的最左边的数（见 LC34. 在排序数组中查找元素的第一个和最后一个位置）</li></ul></li><li>排序</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC总结</title>
    <link href="/notes/2024/01/08/%E6%80%BB%E7%BB%93%E7%AF%87%20JUC%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2024/01/08/%E6%80%BB%E7%BB%93%E7%AF%87%20JUC%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC-总结"><a href="#JUC-总结" class="headerlink" title="JUC 总结"></a>JUC 总结</h1><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><p>详细了解 Java 线程底层</p><p><a href="https://zhuanlan.zhihu.com/p/363839223">https://zhuanlan.zhihu.com/p/363839223</a></p><h3 id="多线程什么时候效率高"><a href="#多线程什么时候效率高" class="headerlink" title="多线程什么时候效率高"></a>多线程什么时候效率高</h3><p>单核 cpu 下，多线程不能实际提高 cpu 密集型程序的运行效率（线程切换还会带来额外的资源损耗），但可以在不同的任务之间切换从而实现并发效果。多核 cpu 同时跑多个线程才能真正提高程序运行效率。</p><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;Integer&gt; task3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> task3.get();<br>log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, result);<br></code></pre></td></tr></table></figure><h3 id="查看进程线程"><a href="#查看进程线程" class="headerlink" title="查看进程线程"></a>查看进程线程</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p><code>ps -ef</code> 查看当前时刻所有进程</p><p><code>top</code> 动态监视所有进程状态，包括 cpu 利用率、内存占用率等等。</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><code>jps</code> 命令查看所有 Java 进程</p><p><code>jstack PID</code> 查看某个 Java 进程(PID)的所有线程状态</p><h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><p>每个线程启动后，JVM 都会为其分配一块方法栈内存。一个线程的方法栈由多个栈帧组成，对应着方法的递归调用，栈顶的栈帧是当前的活动栈帧，对应着正在执行的方法。每个栈帧中都要保存局部变量表、操作数栈、帧信息。</p><h3 id="API-细节"><a href="#API-细节" class="headerlink" title="API 细节"></a>API 细节</h3><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>start()</td><td></td><td>native 方法，在 JVM 层面创建一个线程，初始化线程方法栈等资源，线程状态从 NEW 切换到 RUNNABLE，映射操作系统内核原生线程，切换到就绪态</td></tr><tr><td>join()</td><td></td><td>阻塞当前线程直到 thread 对象对应的线程结束，阻塞状态是 WAITING，底层依靠 synchronized 的 wait 实现</td></tr><tr><td>setPriority()</td><td></td><td>设置线程优先级，较大的优先级 能提高该线程被 CPU 调度的机率</td></tr><tr><td>isInterrupted()</td><td></td><td>判断是否被打断，不会清除打断标记</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是否被打断，会清除打断标记</td></tr><tr><td>interrupt()</td><td></td><td>打断线程，如果被打断线程正在 sleep（TIMED_WAITING），wait（WAITING），join（本质是 wait，WAITING） 会导致被打断的线程抛出 InterruptedException，并清除打断标记。如果打断的正在运行的线程，则会设置打断标记。park 的线程被打断，也会设置打断标记，如果打断标记已经是 true, 则 park 会失效。</td></tr><tr><td>sleep()</td><td>static</td><td>native 方法，当前线程转到阻塞态（TIMED_WAITING），一定时间后恢复到 RANNABLE</td></tr><tr><td>yield()</td><td>static</td><td>native 方法，提示 JVM 层面的线程调度器让出当前线程对 CPU 的使用，循环调 yield()方法也相当于让当前线程几乎不运行</td></tr></tbody></table><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p>垃圾回收器线程就是一种守护线程</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><h4 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112171408.png"></p><ul><li>初始状态：仅是在语言层面创建了线程对象，操作系统还未实际创建线程</li><li>就绪状态：指该线程已经被创建(分配了资源)，可以由 CPU 调度运行</li><li>运行状态：获取了 CPU 时间片正在运行，当 CPU 时间片用完，会从运行状态转换至就绪状态，会导致线程的上下文切换</li><li>阻塞状态：不再接受 CPU 的调度，设置了相应的唤醒条件，在一定条件下会被软中断触发唤醒，转换到就绪状态</li><li>终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h4 id="JVM-层面"><a href="#JVM-层面" class="headerlink" title="JVM 层面"></a>JVM 层面</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112172052.png"></p><ul><li>NEW：只是 new 了 Thread 对象，还没有调用 start() 方法，线程没有注册到 JVM</li><li>RUNNABLE：调用了 start() 方法之后，在 JVM 层面创建一个线程，初始化方法栈等资源，线程状态从 NEW 切换到 RUNNABLE，映射操作系统内核原生线程，切换到就绪态。注意 JVM 层面的 RUNNABLE 状态涵盖了操作系统层面的就绪状态和运行状态。</li><li>BLOCKED：synchronized 没有抢到锁时线程会进入的阻塞态</li><li>WAITING：wait()、join()、await()、LockSupport.park()调用时会进入的阻塞态，其中 await()、LockSupport.park()底层走的都是 UNSAFE.park()，join()底层是 wait()</li><li>TIMED_WAITING：Threap.sleep()和 wait(n)调用时会进入的阻塞态</li></ul><h2 id="Monitor-管程"><a href="#Monitor-管程" class="headerlink" title="Monitor 管程"></a>Monitor 管程</h2><h3 id="Java-中变量的自增和自减"><a href="#Java-中变量的自增和自减" class="headerlink" title="Java 中变量的自增和自减"></a>Java 中变量的自增和自减</h3><p>Java 中变量的自增和自减并不是原子操作，因为它们对应多条字节码（JVM 只保证多线程对基本数据类型的读写字节码指令的执行是原子的）。</p><p>对于 i++而言，实际会产生如下的 JVM 字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic i <span class="hljs-comment">// 读静态变量i的值并放入操作数栈</span><br>iconst_1 <span class="hljs-comment">// 常量1放入操作数栈</span><br>iadd <span class="hljs-comment">// 操作数栈弹栈相加，结果放入操作数栈</span><br>putstatic i <span class="hljs-comment">// 操作数栈弹栈并写入静态变量i</span><br></code></pre></td></tr></table></figure><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p>synchronized 方法将锁加在了 this 对象上，synchronized 静态方法将锁加在了类的 class 对象上</p><h3 id="一个变量什么时候线程安全"><a href="#一个变量什么时候线程安全" class="headerlink" title="一个变量什么时候线程安全"></a>一个变量什么时候线程安全</h3><h4 id="属性和静态属性"><a href="#属性和静态属性" class="headerlink" title="属性和静态属性"></a>属性和静态属性</h4><ul><li>没有多线程共享：线程安全</li><li>被多线程共享：<ul><li>本身是不可变类型：线程安全</li><li>可变类型：<ul><li>只存在并发读：线程安全</li><li>存在并发读写：线程不安全</li></ul></li></ul></li></ul><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul><li>数值类型：线程安全</li><li>引用类型：<ul><li>对象没有逃离方法的作用访问：线程安全</li><li>对象逃离方法的作用范围：线程不安全</li></ul></li></ul><h4 id="String-引用辨析"><a href="#String-引用辨析" class="headerlink" title="String 引用辨析"></a>String 引用辨析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建一个String对象，该对象引用方法区字符串常量池中&quot;abc&quot;这个字符串的内存地址，s1引用堆中String对象地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><br><span class="hljs-comment">// s2直接引用方法区字符串常量池中&quot;abc&quot;这个字符串的内存地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br><span class="hljs-comment">// s3直接引用方法区字符串常量池中&quot;abc&quot;这个字符串的内存地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<br><br><span class="hljs-comment">// c直接引用方法区字符串常量池中&quot;c&quot;这个字符串的内存地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;c&quot;</span>;<br><br><span class="hljs-comment">// 在堆中创建一个String对象，该对象引用方法区字符串常量池中&quot;abc&quot;这个字符串的内存地址，s4引用堆中String对象地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> + c;<br></code></pre></td></tr></table></figure><h3 id="Monitor-管程概念"><a href="#Monitor-管程概念" class="headerlink" title="Monitor 管程概念"></a>Monitor 管程概念</h3><h4 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h4><p>以 32 位虚拟机（JVM）为例：<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112213325.png"></p><h4 id="重量级锁（fat-lock）"><a href="#重量级锁（fat-lock）" class="headerlink" title="重量级锁（fat lock）"></a>重量级锁（fat lock）</h4><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁(重量级)之后，该对象头的<br>Mark Word 中就被设置指向 Monitor 对象的指针</p><p>Monitor 结构如下<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112214733.png"></p><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2</li><li>之后如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList，线程状态变为 BLOCKED</li><li>Thread-2 释放锁时，会按照某种算法（非公平）选择 EntryList 中某个线程置为 Owner，然后将这个线程的状态转为 Runnable</li></ul><h4 id="重量级锁的自旋优化"><a href="#重量级锁的自旋优化" class="headerlink" title="重量级锁的自旋优化"></a>重量级锁的自旋优化</h4><p>当多个线程尝试获取同一个重量级锁的时候，没有获取到锁的线程可能不会立刻进入 EntryList 变成 BLOCKED 状态，而是会进行 CPU 自旋空转，多尝试几次获取重量级锁，自旋优化某些时候性能高于直接阻塞，因为防止了线程状态的切换。自旋优化在 Java 中是自适应的。</p><p>下图为自旋重试成功的情况<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112223816.png"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>如果多个线程共享锁，但不存在锁争用，这时采用重量级锁维护 Monitor 是比较浪费的。轻量级锁可以保证多个线程不存在锁争用时的共享锁，并且能够在出现锁争用时升级重量级锁。</p><p>Lock Record 对象，每个线程的每个栈帧都会包含一个锁记录的结构，如下图所示<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112221512.png"></p><p>当某个线程取得轻量级锁时，会交换 Lock Record 中的<code>lock record 地址 00</code>部分和对象头中的<code>Mark Word</code>，然后<code>Object reference</code>部分指向对象头。结果如下图<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112221933.png"></p><p>当某个线程尝试取得轻量级锁时，有可能发现对象头正处于轻量级锁状态并且<code>lock record</code>地址非空，此时如果是其他线程占用，则说明出现了锁争用，锁膨胀成重量级锁，如果是本线程占用，则进行锁重入，再新增一个<code>lock record</code>，结果如下图<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112222536.png"></p><p>下图是 Thread-0 已经加了轻量级锁，之后 Thread-1 加轻量级锁失败，进入锁膨胀流程，创建 Monitor，Owner 置为 Thread-0，EntryList 放入 Thread-1<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112223117.png"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>如果只有单线程使用锁，那么不需要在栈帧中添加<code>lock record</code>，只需要在对象头的<code>Mark Word</code>中记录线程 ID 即可，这种方式相比于轻量级锁减少了很多 CAS 操作。偏向锁保证单个线程占用锁，并且能够在多线程共享锁时升级轻量级锁。</p><p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有线程共享锁，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p><h4 id="偏向锁升级轻量级锁示例"><a href="#偏向锁升级轻量级锁示例" class="headerlink" title="偏向锁升级轻量级锁示例"></a>偏向锁升级轻量级锁示例</h4><p>如图两个代码块是严格顺序执行的，多线程锁共享但不存在锁争用，所以第一次和第二次打印都是偏向锁偏向 t1 线程，第三次打印是锁升级的轻量级锁指向 t2 的<code>lock record</code>，第四次打印是轻量级锁释放后的 Normal 状态（之后不会再使用偏向锁了）。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112234054.png"></p><p>下图是执行结果<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240112234538.png"></p><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>当前有一些偏向锁偏向 A 线程，B 线程尝试获取这些锁导致多线程非争用地共享锁，偏向锁升级成轻量级锁，当升级次数超过一定阈值的时候，JVM 会将剩余的偏向锁批量地重偏向给 B 线程。</p><h4 id="批量撤销偏向"><a href="#批量撤销偏向" class="headerlink" title="批量撤销偏向"></a>批量撤销偏向</h4><p>当升级次数超过更高阈值的时候，JVM 会觉得根本不该偏向，因此会让该类的所有对象都不可偏向，即最低就是轻量级锁。</p><h4 id="重量级锁的六个过程"><a href="#重量级锁的六个过程" class="headerlink" title="重量级锁的六个过程"></a>重量级锁的六个过程</h4><h5 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h5><p>将 Monitor 的 Owner 置为当前线程，继续执行</p><h5 id="上锁但锁已被占用"><a href="#上锁但锁已被占用" class="headerlink" title="上锁但锁已被占用"></a>上锁但锁已被占用</h5><p>发现 Owner 非空，将当前线程加入 EntryList，状态从 RUNNABLE 变为 BLOCKED，阻塞</p><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>将当前线程从 Owner 删掉，按照某种算法从 EntryList 中选出一个线程放入 Owner，状态从 BLOCKED 置为 RUNNABLE，继续执行</p><h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p>将当前线程放入 WaitSet，状态从 RUNNABLE 变成 WAITING，然后执行释放锁流程，都执行完后当前线程阻塞</p><h5 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify&#x2F;notifyAll"></a>notify&#x2F;notifyAll</h5><p>从 WaitSet 拿出一个线程（notify）或拿出全部线程（notifyAll）放入 EntryList，状态从 WAITING 转为 BLOCKED，继续执行</p><h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h5><p>如果一个线程正处于 WAITING 状态，打断它等同于从 WaitSet 拿出它并放入 EntryList，状态从 WAITING 转为 BLOCKED，抢到锁后直接抛出 InterruptedException 异常</p><h4 id="join-原理"><a href="#join-原理" class="headerlink" title="join 原理"></a>join 原理</h4><p>判断目标线程是否 alive，不断地 wait 当前线程</p><h2 id="park-和-unpark-原理"><a href="#park-和-unpark-原理" class="headerlink" title="park 和 unpark 原理"></a>park 和 unpark 原理</h2><p><code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>底层实现依赖 native 的<code>UNSAFE.park</code>和<code>UNSAFE.unpark</code>。</p><p>每个线程都有自己的一个 Parker 对象，由三部分组成 <code>_counter</code>，<code>_cond</code>和<code>_mutex</code>，其中<code>_counter</code>为 0 代表耗尽，1 代表充足。</p><h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><p>如果当前<code>_counter</code>为 0，阻塞当前线程，状态从 RANNBLE 变为 WAITING</p><p>如果当前<code>_counter</code>为 1，将其置为 0，继续运行不会阻塞</p><h3 id="unpark"><a href="#unpark" class="headerlink" title="unpark"></a>unpark</h3><p>如果此时线程被 park 阻塞了，则唤醒线程，状态从 WAITING 变为 RUNNABLE</p><p>如果此时线程正在运行，则将线程的<code>_counter</code>置为 1</p><h3 id="对比-wait-notify"><a href="#对比-wait-notify" class="headerlink" title="对比 wait &amp; notify"></a>对比 wait &amp; notify</h3><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</p><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p><h2 id="死锁、活锁和饥饿"><a href="#死锁、活锁和饥饿" class="headerlink" title="死锁、活锁和饥饿"></a>死锁、活锁和饥饿</h2><p>在设计锁的粒度时，要尽可能地细粒度以提高程序的并发度，但是需要注意死锁等问题。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程因互相等待资源而共同陷入阻塞的情况</p><p>检测死锁可以使用 jconsole 工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>多个线程互相改变对方的结束条件，导致虽然大家都在运行，没有阻塞，但是都不能结束的情况</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>线程因为某种原因一直得不到运行的情况</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于 synchronized ，ReentrantLock 阻塞式获取锁的过程具备如下特点：</p><ul><li>可打断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>synchronized 阻塞式获取锁的过程状态是 BLOCKED，不可打断，不可超时退出，非公平锁，只有一个 WaitSet 因此只支持一个条件变量。</p><p>ReentrantLock 和 synchronized 一样，都是可重入锁</p><p>synchronized 是在 JVM 的 C++层面实现的，ReentrantLock 是借助 unsafe 提供的 CAS 接口和 LockSupport 提供的阻塞接口在 Java 层面实现的。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="最常见使用"><a href="#最常见使用" class="headerlink" title="最常见使用"></a>最常见使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    lock.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非阻塞式获取锁"><a href="#非阻塞式获取锁" class="headerlink" title="非阻塞式获取锁"></a>非阻塞式获取锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>lock.tryLock();<br></code></pre></td></tr></table></figure><h4 id="可打断可超时退出"><a href="#可打断可超时退出" class="headerlink" title="可打断可超时退出"></a>可打断可超时退出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>ReentrantLock 默认是非公平锁，公平锁需要在构造时指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 只支持一个条件变量 WaitSet，ReentrantLock 可以创建多个条件变量，除此之外两者在条件变量方面几乎相同。</p><p>await 的线程可以被唤醒（signal、signalAll）、被打断（interrupt）、超时（如果 await 设置了时间），重新竞争 lock 锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>condition.await();<br>condition.signal();<br>condition.signalAll();<br></code></pre></td></tr></table></figure><h2 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、Cache 缓存和硬件内存。</p><h3 id="一个错误的例子"><a href="#一个错误的例子" class="headerlink" title="一个错误的例子"></a>一个错误的例子</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240113141002.png"></p><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率。1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 可以用来修饰属性或静态属性，当属性或静态属性被多线程共享且存在多线程读写时，需要设置成 volatile 的以保证可见性和有序性，如果只被单线程访问或是只涉及到多线程读的话就不需要设置成 volatile 的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>volatile 修饰的变量在任意线程的读写都将直接针对主存。</p><p>这里其实和 CPU 缓存比较像，CPU 的 L1、L2Cache 中会缓存内存中的内存块，如果一个变量只有单个 CPU 访问，那么写回、写直达等策略就可以保证缓存一致性，但是如果一个变量被多个 CPU 访问，会使用总线嗅探来解决多核间的缓存一致性。但是 Java 内存模型没有总线嗅探功能，只能强制所有线程直接读写主存来保证可见性。</p><p>volatile 本身不能保证原子性，但上述例子中对静态属性 run 的读写本身是原子性的，因为 JVM 保证多线程对基本数据类型读写的字节码指令执行的原子性，如下图所示。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240113143347.png"></p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>指令重排：JVM 会在不影响单线程执行正确性的前提下，调整字节码指令的执行顺序，目的是提高 cpu 流水线技术的工作效率。但是多线程下『指令重排』会影响正确性。</p><h4 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h4><p>happens-before 原则规定了对共享变量的写操作对其它线程的读操作可见，除了 happens-before 原则之外的其他情况，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><h4 id="读写屏障"><a href="#读写屏障" class="headerlink" title="读写屏障"></a>读写屏障</h4><p>volatile 是通过读写屏障机制保证的可见性和有序性，对 volatile 变量的写指令后会加入写屏障，对 volatile 变量的读指令前会加入读屏障。</p><ul><li>写屏障：同步工作内存到主存，并保证不会将写屏障之前的代码排在写屏障之后</li><li>读屏障：清空工作内存，并保证不会将读屏障之后的代码排在读屏障之前</li></ul><h2 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 全称 compareAndSet，compareAndSet 操作的执行过程是先比较，如果相等就 set 返回成功，不相等就返回失败，compareAndSet 操作本身是原子的，并且它的原子性来自于 CPU 指令级别的保证，CAS 的底层是 <code>lock cmpxchg</code> 指令(X86 架构)，在单核时单条机器指令自然是原子的，在多核时，<code>lock cmpxchg</code> 指令会锁住总线保证只有自己在执行。</p><h3 id="CAS-和-synchronized-对比"><a href="#CAS-和-synchronized-对比" class="headerlink" title="CAS 和 synchronized 对比"></a>CAS 和 synchronized 对比</h3><ul><li>CAS：CAS 是乐观锁，体现的是无锁并发、无阻塞并发，线程不会陷入阻塞，这是效率提升的因素之一，但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li><li>synchronized：悲观锁，线程会阻塞，线程上下文切换会带来较大资源开销</li></ul><h3 id="JUC-包提供的-Atomic-实现"><a href="#JUC-包提供的-Atomic-实现" class="headerlink" title="JUC 包提供的 Atomic 实现"></a>JUC 包提供的 Atomic 实现</h3><ul><li>原子数值：提供对数值的 CAS 操作<ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul></li><li>原子引用：提供对引用对象的 CAS 操作，这里的 compare 对比的是两个对象是否&#x3D;&#x3D;<ul><li>AtomicReference</li></ul></li><li>原子数组：提供对数组中的数值或引用的 CAS 操作<ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul></li><li>字段更新器：利用字段更新器，可以针对对象的某个域(Field)进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常。适用场景：有一个类，类里面有一个属性，属性并不是 Atomic 的，现在有一个此类的对象，我希望 CAS 原子地操作这个对象的属性。<ul><li>AtomicReferenceFieldUpdater</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul></li></ul><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>JUC 包提供的 Atomic 实现全部都是依靠 Unsafe 的 native 方法实现的。Unsafe 类是单例的， 它提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。</p><h2 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h2><p>不可变类就是不能够修改内部属性</p><ul><li>将类和类中所有属性都设置为 final 的，那么这个类的对象一定是不可变的</li><li>没有属性的类一定是不可变的</li></ul><h2 id="共享模型之工具"><a href="#共享模型之工具" class="headerlink" title="共享模型之工具"></a>共享模型之工具</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Java 线程池采用了常见的一种接口设计方式<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240113165911.png"></p><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul><li>RUNNING</li><li>SHUTDOWN</li><li>STOP</li><li>TIDYING</li><li>TERMINATED</li></ul><h4 id="线程池工作方式"><a href="#线程池工作方式" class="headerlink" title="线程池工作方式"></a>线程池工作方式</h4><p>线程池由一些运行着的线程和一个阻塞队列组成，阻塞队列支持多线程并发放入任务和取出任务。当向线程池提交任务时，如果当前线程数没有达到核心线程数，那么创建新的线程并执行任务，如果当前线程数达到了核心线程数，那么放入阻塞队列，如果阻塞队列满了，那么尝试创建临时线程，如果临时线程数也满了（临时线程的最大数目等于最大线程数减核心线程数），那么提交失败（这里有多种拒绝策略）。当高峰过去后，临时线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。</p><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><p>线程可以向线程池提交 Runnable 或 Callable 的任务，其中 Callable 会返回 future</p><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><ul><li>shutdown 方法：线程池状态变为 SHUTDOWN，之后不再接收新任务，但已提交任务会执行完</li><li>shutdownNow 方法：线程池状态变为 STOP，之后不再接收新任务，会将队列中的任务返回，并用 interrupt 的方式中断正在执行的任务</li></ul><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>可以使用 ScheduledExecutorService</p><p>具体线程池知识详见并发编程 pdf 的 P146</p><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</p><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p><p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</p><p>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p>特点:</p><ul><li>用 state 属性来表示资源的状态</li><li>提供了一个双向链表用于放置阻塞线程，类似于 Monitor 的 EntryList</li><li>提供了条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>AQS 要实现的功能目标：</p><ul><li>tryAcquire（自己实现）：非阻塞式获取锁</li><li>acquire：阻塞式获取锁</li><li>acquireInterruptibly：阻塞式获取锁，可打断</li><li>tryAcquireNanos：阻塞式获取锁，可打断、可超时</li><li>release：原子释放锁，需要自己实现 tryRelease</li></ul><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240115162236.png"></p><h2 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h2><h3 id="非公平锁-NonfairSync-实现原理"><a href="#非公平锁-NonfairSync-实现原理" class="headerlink" title="非公平锁 NonfairSync 实现原理"></a>非公平锁 NonfairSync 实现原理</h3><p>ReentrantLock 中的 NonfairSync 静态内部类就是 AQS 类的子类，借助 AQS 实现了一个非公平的可重入锁。</p><p>非公平性体现在<code>tryRelease()</code>中直接<code>setState(0)</code>，之后再去<code>unparkSuccessor</code>唤醒双向链表中的第一个线程，在此之间如果有新的线程尝试 CAS 获取锁将会成功。</p><p>可重入性体现在非阻塞式获取锁方法<code>nonfairTryAcquire()</code>中如果发现上锁的是当前线程的话就会加锁重入的计数。原子释放锁方法<code>tryRelease</code>中会减锁重入的计数。</p><h3 id="公平锁-FairSync-实现原理"><a href="#公平锁-FairSync-实现原理" class="headerlink" title="公平锁 FairSync 实现原理"></a>公平锁 FairSync 实现原理</h3><p>是一个公平的可重入锁。与非公平锁实现的区别仅仅在于非阻塞式获取锁方法<code>tryAcquire</code>中不会直接 CAS，而是查看双向链表中没有线程等待的时候才会去 CAS。</p><h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><p>ReentrantReadWriteLock 支持读读并发、读写、写写互斥，适合读多写少的情况。</p><p>ReentrantReadWriteLock 不支持条件变量，支持重入时锁降级，即一个线程在获取到写锁的情况下，可以继续获取到读锁。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Semaphore 中也定义了一个 NonfairSync，借助 AQS 实现了一个限制共享资源访问的信号量机制。</p><p>核心在于<code>tryAcquireShared</code>实现了非阻塞式多线程并发获取共享资源权限。</p><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，<code>await()</code> 用来等待计数归零，<code>countDown()</code> 用来让计数减一</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql总结</title>
    <link href="/notes/2024/01/08/%E6%80%BB%E7%BB%93%E7%AF%87%20Mysql%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2024/01/08/%E6%80%BB%E7%BB%93%E7%AF%87%20Mysql%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-总结"><a href="#Mysql-总结" class="headerlink" title="Mysql 总结"></a>Mysql 总结</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="Mysql-的一条语句是如何执行的"><a href="#Mysql-的一条语句是如何执行的" class="headerlink" title="Mysql 的一条语句是如何执行的"></a>Mysql 的一条语句是如何执行的</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317093516.png"></p><p>Server 层是上层，负责建立连接、分析和执行 SQL。底层存储引擎层负责数据的存储和提取，支持 <strong>InnoDB（默认存储引擎）</strong>、MyISAM、Memory 等多个存储引擎。</p><ol><li>客户端与 server 层建立 tcp 连接并校验用户名密码</li><li>对传过来的 sql 进行解析，词法分析识别关键词，语法分析构建语法树。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317094400.png"></li><li>预处理 sql，检查表和字段是否存在，将 <code>select *</code>中的<code>*</code>扩展为全部字段</li><li>确定 SQL 语句的执行计划，比如当有多个索引的时候，基于查询成本的考虑来决定选择使用哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令来输出本条 sql 的执行计划。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317095333.png"></li><li>执行 sql，下面举几个例子</li></ol><ul><li>主键等值：把条件交给存储引擎，存储引擎直接返回一条</li><li>全表扫描：存储引擎返回第一条记录，执行器判断并返回客户端，存储引擎返回下一条记录</li></ul><h3 id="Mysql-一行记录是如何存储的"><a href="#Mysql-一行记录是如何存储的" class="headerlink" title="Mysql 一行记录是如何存储的"></a>Mysql 一行记录是如何存储的</h3><h4 id="数据存储在哪个文件"><a href="#数据存储在哪个文件" class="headerlink" title="数据存储在哪个文件"></a>数据存储在哪个文件</h4><p>每一个数据库有一个文件夹，当我们给这个数据库创建一个 t_order 表的时候，文件夹中会存在三个文件</p><ul><li>db.opt：用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm：存放表结构</li><li>t_order.ibd：存放表数据</li></ul><h4 id="表空间文件的结构是怎么样的"><a href="#表空间文件的结构是怎么样的" class="headerlink" title="表空间文件的结构是怎么样的"></a>表空间文件的结构是怎么样的</h4><p>InnoDB 存储引擎的逻辑存储结构大致如下图：<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317102558.png"></p><ul><li>页是 InnoDB 存储引擎磁盘管理的最小单元，页的大小固定 16KB。数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</li><li>区可以使得 B+树中每层双向链表相邻的页的物理位置也相邻，这样可以使用顺序 IO 提高速度</li></ul><h4 id="InnoDB-行格式-COMPACT"><a href="#InnoDB-行格式-COMPACT" class="headerlink" title="InnoDB 行格式 COMPACT"></a>InnoDB 行格式 COMPACT</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317103104.png"></p><ul><li>变长字段长度列表：用来存放当前记录所有变长字段的长度</li><li>NULL 值列表：存放所有可以为 NULL 的字段是否为 NULL，每个字段用 1bit 表示</li><li>row_id：隐式主键，如果建表时存在主键或者不存在主键但是存在非空唯一索引，这个字段就没有用了，否则会设置隐式自增主键</li><li>trx_id：事务 id，表明这条记录是由哪个事务生成的</li><li>roll_pointer：指向 undolog 上一个版本的指针</li></ul><h4 id="varchar-n-中-n-最大取值为多少"><a href="#varchar-n-中-n-最大取值为多少" class="headerlink" title="varchar(n) 中 n 最大取值为多少"></a>varchar(n) 中 n 最大取值为多少</h4><p>Mysql 一行记录最大长度为 65535 字节，所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 &lt;&#x3D; 65535。</p><h4 id="行溢出后，MySQL-是怎么处理的"><a href="#行溢出后，MySQL-是怎么处理的" class="headerlink" title="行溢出后，MySQL 是怎么处理的"></a>行溢出后，MySQL 是怎么处理的</h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><h2 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h2><p>索引的定义就是帮助存储引擎快速查找数据的一种数据结构，形象的说就是索引是数据的目录。</p><p>所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><h3 id="从数据页的角度看-B-树"><a href="#从数据页的角度看-B-树" class="headerlink" title="从数据页的角度看 B+ 树"></a>从数据页的角度看 B+ 树</h3><p>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p><h4 id="一个数据页里面是什么样的"><a href="#一个数据页里面是什么样的" class="headerlink" title="一个数据页里面是什么样的"></a>一个数据页里面是什么样的</h4><p>一个数据页里面存放了多条记录，数据页中的记录按照「主键」顺序组成单向链表。当按照主键进行查询的时候，由于是单链表的结构所以只能遍历整个链表。为提高查询效率引入了分组的方式，页目录中的每个槽都索引了分组的最后一条记录，因此每次查询时可以先用二分法查到相应的槽，然后再去槽对应的分组中遍历得到记录。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317142341.png"></p><h4 id="B-树是如何进行查询的"><a href="#B-树是如何进行查询的" class="headerlink" title="B+ 树是如何进行查询的"></a>B+ 树是如何进行查询的</h4><p>InnoDB 里的 B+ 树中的每个节点都是一个数据页，非叶子节点的数据页只存放索引不存放记录数据，叶子节点的数据页存放的是记录数据。</p><p>比如说我们要查找主键为 6 的记录，首先在根叶子节点二分法定位槽，然后遍历链表找到大于等于 1 且小于 7 对应页 30。在页 30 非叶子节点二分法定位槽，然后遍历链表找到大于等于 5 对应页 16。在页 16 叶子节点二分法定位槽，然后遍历链表找到主键为 6 的记录。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317151626.png"></p><h4 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h4><p>索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><h4 id="回表和索引覆盖"><a href="#回表和索引覆盖" class="headerlink" title="回表和索引覆盖"></a>回表和索引覆盖</h4><p>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</p><h3 id="为什么-MySQL-采用-B-树作为索引"><a href="#为什么-MySQL-采用-B-树作为索引" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引"></a>为什么 MySQL 采用 B+ 树作为索引</h3><p>磁盘读写的最小单位是扇区，扇区的大小只有 <code>512B</code> 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I&#x2F;O 操作会直接读写 8 个扇区。</p><p>MySQL 的索引结构应该满足以下两点：</p><ul><li>能在尽可能少的磁盘 I&#x2F;O 次数下查找记录</li><li>既能高效查找某条记录，也能高效查找某个范围内的记录</li></ul><h4 id="可能的索引结构"><a href="#可能的索引结构" class="headerlink" title="可能的索引结构"></a>可能的索引结构</h4><p>首先我们需要明确，数据页在存储上并不是连续存储的。</p><ul><li>二分法：把每个数据页地址组成一个连续存储的数组，并按照主键 id 从小到大排列，然后就可以二分查找了。二分法查找单条记录或者范围记录的时间复杂度都是 O(log(n))，远差于 B+树。</li><li>平衡二叉搜索树（AVL）：把每个数据页地址组成一个 AVL 树，AVL 树的查找、插入、删除时间复杂度都是 O(log(n))，而二分法的插入、删除时间复杂度是 O(n)。但 AVL 树无法高效范围查找。</li><li>B 树：相当于平衡多叉搜索树，相比于 AVL 树查询效率得到提升，IO 次数更少，但仍然无法高效范围查找（只能遍历树）。</li><li>B+树：和 B 树的区别在于，记录只存在叶子结点，并且每层节点之间由双向链表连接。相比于 B 树，因为非叶子节点不存记录数据，所以非叶子节点可以存更多的索引，因此整体结构更加扁平，查询的磁盘 IO 次数更少，且支持高效范围查找。</li></ul><h3 id="MySQL-单表不要超过-2000W-行"><a href="#MySQL-单表不要超过-2000W-行" class="headerlink" title="MySQL 单表不要超过 2000W 行"></a>MySQL 单表不要超过 2000W 行</h3><p>MySQL 单表不要超过多少行这个问题和表结构有哪些字段以及字段类型有关。核心问题是希望聚簇索引的 B+树层数不要超过 3 层，否则太高的磁盘 IO 次数会导致查询效率降低。</p><p>我们假设：</p><ul><li>非叶子节点内指向其他页的数量为 x</li><li>叶子节点内能容纳的数据行数为 y</li><li>B+ 数的层数为 z</li></ul><p>则行数$Total &#x3D;x^{z-1}y$，一个数据页大概能存 1280 个索引，即$x&#x3D;1280$，我们假设一行数据占 1KB 大小，那么一个数据页大概能存 15 行记录。算下来，当 B+树层数为 3 时最多能存约 2450w 行记录。</p><h3 id="索引失效有哪些"><a href="#索引失效有哪些" class="headerlink" title="索引失效有哪些"></a>索引失效有哪些</h3><ul><li>对索引使用左或者左右模糊匹配：也就是 <code>like %xx%</code> 或者 <code>like %xx%</code> 这两种方式</li><li>对索引使用函数或对索引进行表达式计算：如果查询条件中对索引字段使用函数，就会导致索引失效。B+树是按照索引字段原来的值构建的，经过函数映射后当然不再适用。</li><li>对索引隐式类型转换：比如下面的例子，phone 是 varchar 类型，自动转换为数字<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure></li><li>联合索引非最左匹配：单字段索引在排序时直接按单字段排序即可，而联合索引在排序时先按第一个字段排序，第一个字段相同时再按第二个字段排序，以此类推。因此联合索引要能正确使用需要遵循最左匹配原则，以下情况会走联合索引：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span>；<br><span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>；<br><span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span>；<br></code></pre></td></tr></table></figure>以下情况会全表扫描：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span>；<br><span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>；<br><span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>；<br></code></pre></td></tr></table></figure>以下情况会部分走联合索引的<strong>索引下推</strong>：<code>a = 1</code>会走联合索引，在查到一条记录后不会回表查整行记录再判断<code>c=3</code>，而是先判断 c，如果<code>c=3</code>才会回表查整行数据并返回。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>；<br></code></pre></td></tr></table></figure></li><li>WHERE 子句中的 OR：id 字段是主键，age 字段没有索引。那么下面这条 sql 走全表扫描，这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="count-和-count-1-有什么区别"><a href="#count-和-count-1-有什么区别" class="headerlink" title="count(*) 和 count(1) 有什么区别"></a>count(*) 和 count(1) 有什么区别</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317221540.png"></p><p>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</p><ul><li>count(主键字段) ：全扫描聚簇索引或二级索引，判断主键字段是否为 NULL，count 加一</li><li>count(1)：全扫描聚簇索引或二级索引，count 加一</li><li>count(*)：等价于 count(0)</li><li>count(字段)：如果字段是普通字段则全表扫描，如果是索引字段则全扫描索引</li></ul><h4 id="为什么要通过遍历的方式来计数"><a href="#为什么要通过遍历的方式来计数" class="headerlink" title="为什么要通过遍历的方式来计数"></a>为什么要通过遍历的方式来计数</h4><p>一方面在有 where 条件限制的时候，肯定要遍历。另一方面在没有 where 条件限制的时候，因为 innodb 存储引擎有着事务隔离的 MVCC 机制，因此不能用一个量来衡量整个表的行数，也需要遍历。</p><h2 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h2><h3 id="事务的-ACID-特性"><a href="#事务的-ACID-特性" class="headerlink" title="事务的 ACID 特性"></a>事务的 ACID 特性</h3><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><ul><li>原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</li><li>一致性（Consistency）：一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li>隔离性（Isolation）：数据库允许多个并发事务同时读写数据，但每个事务内要满足数据一致性。</li><li>持久性（Durability）：事务结束后对数据的修改就是永久的，即便 mysql 进程崩溃重启或者断电重启也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的</li><li>原子性是通过 undo log（回滚日志） 来保证的</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的</li><li>一致性则是通过持久性+原子性+隔离性来保证</li></ul><h3 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h3><ul><li>脏读：一个事务读到了另外一个未提交事务的数据，未提交事务回滚后已经读到的就变成了脏数据。插入、删除和修改都可以导致脏读。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318201101.png"></li><li>不可重复读：在一个事务内多次读取同一个数据，如果出现同一行记录前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。只有修改可以导致不可重复读，插入和删除不会导致不可重复读。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318202103.png"></li><li>幻读：在一个事务内多次查询符合某个查询条件的所有记录，如果出现前后两次查询的结果条目并不是一一对应的，就意味着发生了「幻读」现象。插入、删除和修改都可以导致幻读，其中修改是修改一些字段使其不满足查询条件。<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318205141.png"></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>读未提交：指一个事务还没提交时，它做的变更就能被其他事务看到。</li><li>读已提交：指一个事务提交之后，它做的变更才能被其他事务看到</li><li>可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别</li><li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行，因为只有事务结束时才会释放所有的读锁&#x2F;写锁</li></ul><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</p><h4 id="四种隔离级别是如何实现的"><a href="#四种隔离级别是如何实现的" class="headerlink" title="四种隔离级别是如何实现的"></a>四种隔离级别是如何实现的</h4><ul><li>「读未提交」：直接读取最新的数据就好了</li><li>「串行化」：每行记录都要加读写锁</li><li>「读提交」和「可重复读」：它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同。「读已提交」是在查询前生成一个 Read View，「可重复读」是在开启事务时生成一个 Read View。</li></ul><h3 id="并发版本控制协议-MVCC"><a href="#并发版本控制协议-MVCC" class="headerlink" title="并发版本控制协议 MVCC"></a>并发版本控制协议 MVCC</h3><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318213242.png"></p><p>Read View 有四个重要的字段：</p><ul><li>creator_trx_id：指的是创建该 Read View 的事务的事务 id</li><li>m_ids：指的是在创建 Read View 时，已开启但还未提交的事务</li><li>min_trx_id：m_ids 的最小值</li><li>max_trx_id ：创建 Read View 时当前数据库中应该给下一个事务的 id 值</li></ul><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318213628.png"></p><p>聚簇索引记录中的两个隐藏列：</p><ul><li>trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里</li><li>roll_pointer：指向当前记录上一个版本的 undo log，每次对聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log 中</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318214006.png"></p><p>一个事务去访问记录的时候，先看最新记录数据，如果最新记录数据对当前事务不可见，则沿着 undo log 链向下追溯，直到找到当前事务可见的版本记录。</p><p>在事务中，自己的更新记录总是可见的，生成 Read View 之前已提交事务的记录数据是可见的，生成 Read View 之前已开启但未提交或未开启的事务的记录数据都是不可见的。</p><ul><li>读已提交是在查询前生成一个 Read View，所以读已提交隔离级别下的事务中，每次都读的是当前时刻已提交的最新记录数据</li><li>可重复读是在开启事务时生成一个 Read View，所以可重复读隔离级别下的事务中，相当于在事务开始时生成了一份数据快照，并且只有当前事务可以对它进行修改</li></ul><h3 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>借助于 MVCC、Read View、undo log 这一套机制，快照读大部分情况下可以避免幻读，但也有一些特殊情况。</p><h5 id="第一个发生幻读现象的场景"><a href="#第一个发生幻读现象的场景" class="headerlink" title="第一个发生幻读现象的场景"></a>第一个发生幻读现象的场景</h5><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240318223432.png"></p><h5 id="第二个发生幻读现象的场景"><a href="#第二个发生幻读现象的场景" class="headerlink" title="第二个发生幻读现象的场景"></a>第二个发生幻读现象的场景</h5><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id&#x3D; 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>当前读读的是所有记录已提交的最新数据。Innodb 引擎借助于间隙锁、记录锁和 next key 锁保证了当前读不会出现幻读问题。</p><h2 id="锁篇"><a href="#锁篇" class="headerlink" title="锁篇"></a>锁篇</h2><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁会锁住整个数据库变成只读状态，任何对数据的增删改和对表结构的修改都会阻塞，用全局锁备份数据库会导致业务停滞。</p><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><h4 id="MVCC-可重复读"><a href="#MVCC-可重复读" class="headerlink" title="MVCC 可重复读"></a>MVCC 可重复读</h4><p>在可重复读隔离级别下，先开启一个事务，再去 select 查询并备份，这样也能保证数据一致性，并且业务可以正常增删改查。</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br></code></pre></td></tr></table></figure><p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 MDL 读锁</li><li>对一张表做结构变更操作的时候，加的是 MDL 写锁</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li></ul><p>意向共享锁、意向独占锁、共享表锁、独占表锁之间构成读写锁关系（意向锁之间不会发生冲突），这样就能保证比如行级别的独占记录锁和独占表锁之间会互斥。而如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p>记录锁针对于一个行记录，有 S 锁和 X 锁之分，S 锁是共享锁， X 锁是独占锁。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240319095821.png"></p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>只存在于可重复读隔离级别。X 型间隙锁和 S 型间隙锁没有区别，且间隙锁与间隙锁之间是兼容的，在间隙锁区间内的插入意向锁要等待间隙锁释放。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240319095839.png"></p><h4 id="Next-Key-锁"><a href="#Next-Key-锁" class="headerlink" title="Next-Key 锁"></a>Next-Key 锁</h4><p>Next-Key 锁称为临键锁，是间隙锁和记录锁的组合</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240319095914.png"></p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁，如果有的话会生成一个插入意向锁，并设置状态为等待，直到事务结束间隙锁释放。</p><h4 id="各种加锁情况（在事务中）"><a href="#各种加锁情况（在事务中）" class="headerlink" title="各种加锁情况（在事务中）"></a>各种加锁情况（在事务中）</h4><p>下面这条语句会在 id &#x3D; 1 上加一个插入意向锁。具体过程如下：首先走聚簇索引查看是否主键冲突，然后加一个插入意向锁并根据间隙锁情况判断该插入意向锁是否应该等待，插入新的行数据到聚簇索引的 B+树相应的数据页中，并设置行记录的事务 id 为当前事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">values</span>(x1,x2) <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>下面这两条语句会在 id &#x3D; 1 上加一个 X 型记录锁。更新操作的具体过程如下：首先走聚簇索引查看是否有这条记录，然后加一个 X 型记录锁并判断该记录锁是否应该等待（该行记录是否已经存在 X 型或 S 型记录锁），将更新的数据放入 undo log 链的首部，并设置行记录的事务 id 为当前事务。直到事务结束时释放 X 型记录锁。</p><p>需要注意的是，<code>update</code>和<code>delete</code>相当于当前读，具体 sql 会上哪些锁直接参考<strong>当前读的各种情况</strong>即可，比如下面两条其实对应的就是唯一索引等值查询且记录存在的情况，加的是 X 型记录锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">table</span> .... <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>下面这条语句是快照读，快照读是无锁的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ...<br></code></pre></td></tr></table></figure><h5 id="当前读的各种情况"><a href="#当前读的各种情况" class="headerlink" title="当前读的各种情况"></a>当前读的各种情况</h5><p>当前读会加哪些锁取决于加哪些锁就可以避免幻读</p><h6 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h6><p>当查询记录存在时，加的是 X 型记录锁，这样直到当前事务结束，其他事务都不可以 update 和 delete 这条记录，因为 update 和 delete 都会上 X 型记录锁。</p><p>当查询记录不存在时，会在比查询记录更大的下一条记录上加间隙锁（在某条记录上加间隙锁，间隙锁的作用范围就是这条记录到上一条记录），这样直到当前事务结束，其他事务都不可以 insert 查询记录，因为 insert 会产生插入意向锁。</p><h6 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h6><p>参见小林 coding</p><h6 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h6><p>参见小林 coding</p><h6 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h6><p>参见小林 coding</p><h6 id="全表扫描查询"><a href="#全表扫描查询" class="headerlink" title="全表扫描查询"></a>全表扫描查询</h6><p>如果当前读、update 或 delete，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><p>因此，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。</p><h3 id="Mysql-中的死锁"><a href="#Mysql-中的死锁" class="headerlink" title="Mysql 中的死锁"></a>Mysql 中的死锁</h3><p>下面是一个死锁的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_order` (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `order_no` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `create_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `index_order` (`order_no`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB ;<br></code></pre></td></tr></table></figure><p>其中 id 是主键，order_no 是非唯一索引</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240320094603.png"></p><p>我们要插入订单，为了保证消息幂等性，需要先开启事务然后再做一个当前读，如果没有这条订单，那么就插入然后结束事务，如果已有这条订单，那么就直接结束事务。</p><ul><li>为什么不选择不开启事务时读呢？因为不开启事务时读是读的最新数据，因为没有锁，所以并不满足幂等性。</li><li>为什么不选择开启事务后的快照读呢？一方面快照读无锁且读的不是最新数据，所以不满足幂等性。</li></ul><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240320095533.png"></p><p>上面这种方式可能会出现死锁，事务 A 先当前读没读到并加一个$(1006,+\infty)$的间隙锁，然后事务 B 再当前读没读到并加一个$(1006,+\infty)$的间隙锁，然后事务 A insert 主键 id 为 1007 的记录，事务 A 的插入意向锁和事务 B 的间隙锁冲突，事务 A 阻塞并等待事务 B 的间隙锁释放，然后事务 B insert 主键 id 为 1007 的记录，事务 B 的插入意向锁和事务 A 的间隙锁冲突，事务 B 阻塞并等待事务 A 的间隙锁释放……</p><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><p>打破循环等待条件的角度</p><ul><li>设置事务等待锁的超时时间：当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。</li><li>开启主动死锁检测：主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。</li></ul><p>业务的角度<br>设置 order_no 字段为唯一索引，每次直接 insert 就好，但要记得捕获异常。</p><h2 id="日志篇"><a href="#日志篇" class="headerlink" title="日志篇"></a>日志篇</h2><ul><li>undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC</li><li>redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复</li><li>binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制</li></ul><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>我们在执行一条增删改语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会隐式开启事务来执行增删改语句，执行完就自动提交事务，这样就保证了执行完增删改语句后，我们可以及时在数据库表看到增删改的结果了。</p><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；</li><li>在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；</li><li>在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。</li></ul><p>undo log 版本链如下图：<br><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240320103527.png"></p><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>Buffer Pool 是 Innodb 存储引擎设计的一个缓冲池，用于提高数据页读写效率</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul><p>Buffer Pool 是一块连续的内存，存放着一个个大小为 16KB 的缓存页，其中我们主要关注数据页和 undo 页</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240320105629.png"></p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。</p><p>redo log 用于解决断电导致 Buffer Pool 中还未落盘的脏页数据丢失问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新才算完成。如果断电重启发生在更新完成之前，那么客户端收到更新失败的结果， Buffer Pool 数据丢失，数据是一致的。如果断电重启发生在更新完成之后，那么客户端收到更新成功的结果，Buffer Pool 数据丢失，但是可以利用 redo log 恢复脏数据，数据是一致的。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240320110858.png"></p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了 AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务保证事务的原子性，事务未提交 Buffer Pool 脏数据直接丢失即可，事务提交之后发生了崩溃，重启后会通过 redo log 恢复 Buffer Pool 中的脏数据。</p><p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，即保证了事务四大特性中的持久性。</p><h4 id="redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><a href="#redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？" class="headerlink" title="redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？"></a>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</h4><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。磁盘的「顺序写 」比「随机写」 高效的多。</p><h4 id="redo-log-刷盘"><a href="#redo-log-刷盘" class="headerlink" title="redo log 刷盘"></a>redo log 刷盘</h4><p>redo log 在刚产生时会存放于 redo log buffer 内存缓存中，一般会在每隔一秒以及事务提交时刷入磁盘。</p><h4 id="redo-log-文件写满了怎么办"><a href="#redo-log-文件写满了怎么办" class="headerlink" title="redo log 文件写满了怎么办"></a>redo log 文件写满了怎么办</h4><p>一共有两个 redo log 文件，它们构成一个环形以循环写的方式工作，write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，如果 buffer pool 中的脏页已经刷新到了磁盘，那么脏页对应的 redo log 就可以擦除。</p><p>如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，此时 Mysql 会阻塞并将 buffer pool 中的脏页不断刷新到磁盘，然后擦除相应的 redo log。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240321091950.png"></p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL 在完成一条增删改操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写入 binlog 文件。binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作。</p><h4 id="binlog-的-3-种格式类型"><a href="#binlog-的-3-种格式类型" class="headerlink" title="binlog 的 3 种格式类型"></a>binlog 的 3 种格式类型</h4><ul><li>STATEMENT：每一条增删改的 SQL 都会被记录到 binlog 中，相当于记录了所有的逻辑操作，主从复制中 slave 端再根据 SQL 语句重现。但如果用了 uuid 或者 now 这些函数，则主库从库执行的结果不一致。</li><li>ROW：记录每行数据的变化结果，不会出现 STATEMENT 下动态函数的问题，缺点是文件比较大。</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式。</li></ul><h4 id="binlog-和-redo-log-的不同点"><a href="#binlog-和-redo-log-的不同点" class="headerlink" title="binlog 和 redo log 的不同点"></a>binlog 和 redo log 的不同点</h4><p>binlog 在 server 层实现，redo log 在 innodb 存储引擎实现。binlog 用来做备份和主从复制，redo log 用来做 buffer pool 脏数据页恢复。binlog 是追加写，写满一个文件就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。<br>redo log 是循环写，日志空间大小是固定。</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制过程如下图，可以看到无论是主库的 binlog 日志发送还是从库的中继日志回放都是异步过程。</p><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240321095420.png"></p><p>有了主从复制机制，主库从库之间就存在了延迟数据同步。客户端可以在写数据时只写主库，在读数据时只读从库，这样每台数据库的压力会变小，并且即使写请求会锁表或者锁记录，也不会影响读请求的执行。但缺点是延迟问题和单点问题（一旦主库宕机就会出现数据丢失）。</p><h5 id="主从复制的其他模型"><a href="#主从复制的其他模型" class="headerlink" title="主从复制的其他模型"></a>主从复制的其他模型</h5><ul><li>同步复制：性能很低、可用性很差</li><li>异步复制：单点问题</li><li>半同步复制：只要一部分从库返回复制成功的响应，就成功提交事务，保证即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</li></ul><h4 id="binlog-刷盘"><a href="#binlog-刷盘" class="headerlink" title="binlog 刷盘"></a>binlog 刷盘</h4><p>事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件。</p><h3 id="一条-update-语句的执行过程"><a href="#一条-update-语句的执行过程" class="headerlink" title="一条 update 语句的执行过程"></a>一条 update 语句的执行过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> t_user <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xiaolin&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>优化器分析出成本最小的执行计划。</li><li>通过聚簇索引搜索 id &#x3D; 1 这一行记录，如果 id&#x3D;1 这一行所在的数据页不在 buffer pool 中，就将数据页从磁盘读入到 buffer pool。</li><li>唯一索引等值查询且数据存在，上 X 型记录锁。</li><li>开启事务，生成一条存放该行旧值的 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面并将该页面标记为脏数据，生成一条用于恢复脏 undo 页的 redo log。</li><li>更新 buffer pool 中对应数据页并标记为脏页，生成一条用于恢复脏数据页的 redo log。脏页会通过 WAL 技术由后台线程选择一个合适的时机写入到磁盘。</li><li>记录该语句对应的 binlog，并保存到 binlog cache。</li><li>提交事务，释放锁，两阶段提交（binlog 刷入磁盘、redo log 刷入磁盘）。</li></ol><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><h4 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h4><p>事务提交后，redo log 和 binlog 都要写入磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><ul><li>如果 redo log 写入磁盘后断电重启，binlog 没来得及写入：主库是新值，从库是旧值。</li><li>如果 binlog 写入磁盘后断电重启，redo log 没来得及写入：从库是新值，主库是旧值。</li></ul><h4 id="两阶段提交过程"><a href="#两阶段提交过程" class="headerlink" title="两阶段提交过程"></a>两阶段提交过程</h4><p><img src="https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240321104933.png"></p><p>从图中可看出，事务的提交分为 prepare 和 commit 两个阶段：</p><ul><li>prepare 阶段：设置 redo log 的 XID，设置 redo log 的事务状态为 prepare，将 redo log 写入磁盘。</li><li>commit 阶段：设置 binlog 的 XID，将 binlog 写入磁盘，最后调用引擎的提交事务接口，将磁盘中 redo log 状态设置为 commit。</li></ul><p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，此时的 redo log 都处于 prepare 状态。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li>如果 binlog 中没有此 XID，说明 redo log 完成刷盘，但是 binlog 还没有刷盘，则回滚事务。</li><li>如果 binlog 中有此 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级分布式系统</title>
    <link href="/notes/2023/12/14/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%20/"/>
    <url>/notes/2023/12/14/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E9%AB%98%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%20/</url>
    
    <content type="html"><![CDATA[<h1 id="高级分布式系统"><a href="#高级分布式系统" class="headerlink" title="高级分布式系统"></a>高级分布式系统</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ul><li>什么是分布式系统</li><li>分布式系统的优势</li><li>分布式系统的特征</li><li>分布式系统扩展方式</li><li>衡量性能的常用指标</li><li>分布式系统中的典型问题</li><li>分布式系统模型</li><li>网络分区与脑裂</li><li>事务</li><li>ACID&#x2F;CAP&#x2F;BASE</li><li>分布式计算</li></ul><h2 id="第二章-进程线程及客户服务器"><a href="#第二章-进程线程及客户服务器" class="headerlink" title="第二章 进程线程及客户服务器"></a>第二章 进程线程及客户服务器</h2><ul><li>进程</li><li>线程</li><li>IO 模型<ul><li>阻塞式 IO 模型</li><li>非阻塞式 IO 模型</li><li>信号驱动式 IO 模型</li><li>复用式 IO 模型</li><li>异步式 IO 模型</li></ul></li><li>服务器<ul><li>并发服务器&#x2F;迭代服务器</li><li>客户和服务器的联系</li><li>服务器状态问题</li></ul></li><li>服务器集群<ul><li>无状态服务的节点集群</li><li>有状态服务的节点集群<ul><li>单一服务节点集群</li><li>信息共享的节点集群</li><li>信息一致的节点集群</li></ul></li><li>负载均衡</li><li>正向&#x2F;反向&#x2F;透明代理</li></ul></li></ul><h2 id="第三章-通信"><a href="#第三章-通信" class="headerlink" title="第三章 通信"></a>第三章 通信</h2><ul><li>分层通信协议<ul><li>OSI 模型</li><li>中间件协议<ul><li>持久通信&#x2F;瞬时通信</li><li>同步通信&#x2F;异步通信</li></ul></li></ul></li><li>套接字</li><li>HTTP 协议</li><li>远程过程调用 RPC</li><li>REST 风格</li><li>面向消息通信<ul><li>面向消息的瞬时通信：MPI</li><li>面向消息的持久通信：Kafka</li></ul></li><li>面向流的通信</li><li>多播通信</li></ul><h2 id="第四章-体系结构"><a href="#第四章-体系结构" class="headerlink" title="第四章 体系结构"></a>第四章 体系结构</h2><ul><li>软件体系结构</li><li>体系结构样式<ul><li>分层体系结构</li><li>基于对象的体系结构</li><li>以资源为中心的体系结构</li><li>基于事件的体系结构</li></ul></li><li>系统体系结构<ul><li>集中式体系结构</li><li>P2P 体系结构</li><li>混合型体系结构</li></ul></li><li>体系结构与中间件</li><li>分布式系统服务架构演进<ul><li>原始分布式时代</li><li>基于对象的体系结构</li><li>基于构件的体系结构<ul><li>ORM</li><li>重量级框架 EJB</li><li>轻量级框架 Spring，控制反转，依赖注入</li></ul></li><li>面向服务的体系结构 SOA</li><li>REST 风格的体系结构</li><li>微服务体系结构<ul><li>Dubbo</li><li>Spring Cloud</li></ul></li><li>Serverless 体系结构</li></ul></li></ul><h2 id="第五章-命名"><a href="#第五章-命名" class="headerlink" title="第五章 命名"></a>第五章 命名</h2><ul><li>实体</li><li>实体命名方法</li><li>命名系统</li><li>无结构命名&#x2F;结构化命名</li><li>DNS 域名解析<ul><li>迭代式域名解析</li><li>递归式域名解析</li></ul></li></ul><h2 id="第六章-容错"><a href="#第六章-容错" class="headerlink" title="第六章 容错"></a>第六章 容错</h2><ul><li>分布式容错模型<ul><li>可靠&#x2F;可信系统</li><li>失效&#x2F;差错&#x2F;故障</li><li>进程失效分类</li><li>进程崩溃的发现</li><li>基于冗余的失效屏蔽</li></ul></li><li>RPC 失效的五种情况</li><li>进程恢复<ul><li>进程复制</li><li>协定与共识<ul><li>拜占庭失效</li><li>拜占庭容错</li></ul></li><li>失效检测</li></ul></li><li>可靠分组通信<ul><li>可靠多播</li><li>原子多播</li></ul></li><li>恢复处理<ul><li>向前&#x2F;向后恢复</li><li>检查点</li><li>消息日志</li></ul></li></ul><h2 id="第八章-事务与并发控制"><a href="#第八章-事务与并发控制" class="headerlink" title="第八章 事务与并发控制"></a>第八章 事务与并发控制</h2><ul><li>事务基本概念<ul><li>ACID</li><li>事务隔离级别<ul><li>脏读&#x2F;不可重复读&#x2F;幻读</li><li>读未提交&#x2F;读已提交&#x2F;可重复读&#x2F;可串行化</li></ul></li><li>事务饥饿</li><li>分布式事务</li></ul></li><li>分布式事务提交<ul><li>单阶段协议</li><li>两阶段提交协议</li><li>三阶段提交协议</li></ul></li><li>事务并发控制<ul><li>什么是冲突操作</li><li>串行等价性</li><li>并发控制协议<ul><li>两阶段锁协议<ul><li>死锁解决方案</li><li>分布式死锁解决方案</li></ul></li><li>乐观并发控制协议</li><li>时间戳排序协议</li><li>三种协议比较</li></ul></li></ul></li></ul><h2 id="第九章-复制与一致性"><a href="#第九章-复制与一致性" class="headerlink" title="第九章 复制与一致性"></a>第九章 复制与一致性</h2><ul><li>复制管理</li><li>一致性模型<ul><li>以数据为中心的一致性模型<ul><li>顺序一致性</li><li>线性一致性</li><li>因果一致性</li><li>最终一致性</li></ul></li><li>以客户为中心的一致性模型</li></ul></li><li>一致性协议<ul><li>基于主备的协议<ul><li>同步复制&#x2F;异步复制</li><li>节点失效</li></ul></li><li>复制写协议<ul><li>主动复制</li><li>基于多数表决的协议</li></ul></li></ul></li></ul><h2 id="第十章-协调与协定"><a href="#第十章-协调与协定" class="headerlink" title="第十章 协调与协定"></a>第十章 协调与协定</h2><ul><li>Lamport 逻辑时钟</li><li>分布式互斥<ul><li>中央服务器算法</li><li>基于环的算法</li></ul></li><li>选举<ul><li>基于环的选举算法</li><li>霸道 Bully 算法</li></ul></li><li>共识<ul><li>非拜占庭容错类算法</li><li>拜占庭容错类算法</li><li>Paxos 算法</li><li>PBFT 算法</li><li>Pow 算法</li></ul></li><li>Zookeeper<ul><li>Zookeeper 的应用<ul><li>基于数据发布订阅的配置管理</li><li>Master 选举</li><li>Kafka</li></ul></li><li>Zookeeper 原理<ul><li>Zookeeper 的基本需求</li><li>Zookeeper 集群中的角色</li><li>Zookeeper 集群中服务器的状态</li></ul></li><li>Zab 协议</li></ul></li></ul><h2 id="第十一章-分布式文件系统"><a href="#第十一章-分布式文件系统" class="headerlink" title="第十一章 分布式文件系统"></a>第十一章 分布式文件系统</h2><ul><li>基本概念</li><li>体系结构<ul><li>CS 体系结构</li><li>基于集群的体系结构</li><li>对称式体系结构</li></ul></li><li>GoogleFS</li></ul><h2 id="第十二章-分布式数据管理系统"><a href="#第十二章-分布式数据管理系统" class="headerlink" title="第十二章 分布式数据管理系统"></a>第十二章 分布式数据管理系统</h2><ul><li>关系型数据库</li><li>NoSQL 数据库</li><li>NewSQL 数据库</li><li>Redis<ul><li>Redis 事务</li><li>Redis 持久化<ul><li>基于全量模式的持久化</li><li>基于增量模式的持久化</li></ul></li><li>复制副本</li><li>Redis 集群功能实现</li></ul></li><li>Google Spanner</li></ul><h2 id="第十三章-分布式数据处理技术"><a href="#第十三章-分布式数据处理技术" class="headerlink" title="第十三章 分布式数据处理技术"></a>第十三章 分布式数据处理技术</h2><ul><li>静态数据&#x2F;流数据</li><li>批量计算&#x2F;实时计算</li><li>MapReduce</li><li>Spark</li><li>Storm</li></ul><h2 id="第十五章-云计算"><a href="#第十五章-云计算" class="headerlink" title="第十五章 云计算"></a>第十五章 云计算</h2><ul><li>云计算基本概念</li><li>云计算的三种服务模式<ul><li>SaaS</li><li>PaaS</li><li>IaaS</li></ul></li><li>虚拟化技术<ul><li>虚拟机技术</li><li>容器技术</li></ul></li><li>Kubernetes</li><li>云原生</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>顺序一致性：<a href="https://lotabout.me/2019/QQA-What-is-Sequential-Consistency/">https://lotabout.me/2019/QQA-What-is-Sequential-Consistency/</a></p><p>Zookeeper：</p><p><a href="https://www.douban.com/note/208430424/?_i=2804776XBx1W5J">https://www.douban.com/note/208430424/?_i=2804776XBx1W5J</a></p><p><a href="https://blog.csdn.net/cnh294141800/article/details/53768464">https://blog.csdn.net/cnh294141800/article/details/53768464</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java自限定泛型详解</title>
    <link href="/notes/2023/12/11/%E5%85%AB%E8%82%A1%E7%AF%87%20Java%E8%87%AA%E9%99%90%E5%AE%9A%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/notes/2023/12/11/%E5%85%AB%E8%82%A1%E7%AF%87%20Java%E8%87%AA%E9%99%90%E5%AE%9A%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-自限定泛型详解"><a href="#Java-自限定泛型详解" class="headerlink" title="Java 自限定泛型详解"></a>Java 自限定泛型详解</h1><h2 id="先介绍下最基本的泛型"><a href="#先介绍下最基本的泛型" class="headerlink" title="先介绍下最基本的泛型"></a>先介绍下最基本的泛型</h2><p>类泛型的应用范围是属性、方法中的形参、方法中的返回类型、方法中的局部变量。非应用范围是静态属性、静态方法中的形参、静态方法中的返回类型、静态方法中的局部变量。原因在于泛型只和对象有关，而静态属性和静态方法只和类有关，和对象无关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// T可以是任意类型，因此对于T类型的对象，我们只能调Object类的属性和方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T&gt; &#123;&#125;<br><br><span class="hljs-comment">// T只能是B类型及其子类型，因此对于T类型的对象，我们可以调B类访问修饰符范围内的所有成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; &#123;&#125;<br><br><span class="hljs-comment">// T只能是B类型及其父类型，因此对于T类型的对象，我们只能调Object类的属性和方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T <span class="hljs-built_in">super</span> B&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="普通泛型类定义一个自限定子类"><a href="#普通泛型类定义一个自限定子类" class="headerlink" title="普通泛型类定义一个自限定子类"></a>普通泛型类定义一个自限定子类</h2><p>在下面这段代码中，BasicHolder 只是一个普通的泛型类，里面定义了关于泛型 T 的一些操作，接下来定义了一个 A 类，我们发现 A 类继承 BasicHolder 父类的时候给的泛型就是 A 类自身，这也意味着 A 类继承了其父类关于 A 类的所有操作。这种子类称之为自限定子类，自限定子类的意义在于限定了父类关于泛型的操作必须是针对子类同类的，简单来说就是自限定子类只能和自己同类型对象交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicHolder</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t=t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        System.out.println(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicHolder</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>        a.get();<br>        a.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="当我们把自限定子类用作泛型定义"><a href="#当我们把自限定子类用作泛型定义" class="headerlink" title="当我们把自限定子类用作泛型定义"></a>当我们把自限定子类用作泛型定义</h2><p>在下面的代码中，我们定义 SelfBounded 类的泛型是<code>&lt;T extends SelfBounded&lt;T&gt;&gt;</code>，<code>&lt;T extends SelfBounded&lt;T&gt;&gt;</code>的意思是 SelfBounded 类的子类且子类在继承 SelfBounded 父类时指定的父类泛型只能是子类自己，简单来说就是<code>&lt;T extends SelfBounded&lt;T&gt;&gt;</code>要求 SelfBounded 类的泛型只能是 SelfBounded 类的自限定子类。那么当我们初始化 SelfBounded 类的对象的时候，需要给的泛型是<code>SelfBounded 类的自限定子类</code>，对应<code>new SelfBounded&lt;A&gt;();</code>。当我们定义子类继承 SelfBounded 父类的时候，需要给的泛型是<code>SelfBounded 类的自限定子类</code>，这里又分为两种情况，第一种情况子类本身就是 SelfBounded 类的自限定子类，对应<code>class A extends SelfBounded&lt;A&gt; &#123;&#125;</code>，第二种情况是子类本身不是 SelfBounded 类的自限定子类，对应<code>class B extends SelfBounded&lt;A&gt; &#123;&#125;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfBounded</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;T&gt;&gt; &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfBounded</span>&lt;A&gt;();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;A&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="自限定也可用于泛型方法"><a href="#自限定也可用于泛型方法" class="headerlink" title="自限定也可用于泛型方法"></a>自限定也可用于泛型方法</h2><p>在下面的代码中，test1 静态方法的方法泛型要求是 SelfBounded 类的自限定子类，test2 静态方法的方法泛型要求是 NoBounded 类的自限定子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfBounded</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;T&gt;&gt; &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoBounded</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SelfBounded</span>&lt;U&gt;&gt; U <span class="hljs-title function_">test1</span><span class="hljs-params">(U u)</span> &#123;<br>        <span class="hljs-keyword">return</span> u;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NoBounded</span>&lt;V&gt;&gt; V <span class="hljs-title function_">test2</span><span class="hljs-params">(V v)</span> &#123;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="除了自限定子类还有自限定接口"><a href="#除了自限定子类还有自限定接口" class="headerlink" title="除了自限定子类还有自限定接口"></a>除了自限定子类还有自限定接口</h2><p>自限定接口和自限定子类的作用基本一致，像这里 Integer 类实现了 Integer 自身泛型的 Comparable 接口，相当于 Integer 要实现 Comparable 接口中关于操作 Integer 自身的方法，也即之前讲到的限定只能和自己同类型对象交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Integer&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="JDK-源码里自限定的应用-Enum"><a href="#JDK-源码里自限定的应用-Enum" class="headerlink" title="JDK 源码里自限定的应用 Enum"></a>JDK 源码里自限定的应用 Enum</h2><p>java 中使用 enum 关键字来创建枚举类，实际创建出来的枚举类都继承了 java.lang.Enum。也正因为这样，所以 enum 不能再继承别的类了。其实 enum 就是 java 的一个语法糖，编译器在背后帮我们继承了 java.lang.Enum。</p><p>以下是 jdk 中 Enum 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Enum</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;E&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;, Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><p>比如我们定义了一个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeekDay</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>其反编译回来是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeekDay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;WeekDay&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>可以看到确实所有枚举类都是 Enum 类的自限定子类，这么做有什么好处呢？好处是限定只有相同枚举类的对象才可以交互，也就是 WeekDay 的实例就只能和 WeekDay 的实例交互。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/anlian523/article/details/102511783">https://blog.csdn.net/anlian523/article/details/102511783</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 hyper-v 虚拟机服务器</title>
    <link href="/notes/2023/12/08/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E9%85%8D%E7%BD%AE%20hyper-v%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/notes/2023/12/08/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E9%85%8D%E7%BD%AE%20hyper-v%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="配置-hyper-v-虚拟机服务器"><a href="#配置-hyper-v-虚拟机服务器" class="headerlink" title="配置 hyper-v 虚拟机服务器"></a>配置 hyper-v 虚拟机服务器</h1><p>主机重启后所有虚拟机都会重启，在 NAT 网络模式下虚拟机服务器的 ip 重启后会变化。</p><h2 id="如何在-win-主机与-linux-虚拟机之间传输文件"><a href="#如何在-win-主机与-linux-虚拟机之间传输文件" class="headerlink" title="如何在 win 主机与 linux 虚拟机之间传输文件"></a>如何在 win 主机与 linux 虚拟机之间传输文件</h2><p><a href="https://blog.csdn.net/qq_32824605/article/details/127759846">https://blog.csdn.net/qq_32824605/article/details/127759846</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty总结</title>
    <link href="/notes/2023/12/05/%E6%80%BB%E7%BB%93%E7%AF%87%20Netty%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/12/05/%E6%80%BB%E7%BB%93%E7%AF%87%20Netty%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-总结"><a href="#Netty-总结" class="headerlink" title="Netty 总结"></a>Netty 总结</h1><h2 id="多路复用-IO-底层实现"><a href="#多路复用-IO-底层实现" class="headerlink" title="多路复用 IO 底层实现"></a>多路复用 IO 底层实现</h2><p>多路复用 IO 特指对于多个网络 IO 的单线程阻塞式事件获取，java 中可以通过<code>selector.select()</code>完成，但是 selector 只是一个多路复用 IO 接口，不同操作系统底层有着不同的底层实现，其中最主要的实现方式是 select、poll 和 epoll 这三种系统调用。内核只实现了网络 IO 的多路复用，普通文件 IO 没有多路复用机制。</p><p>大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（page cache）。也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓存区拷贝到应用程序的地址空间中。这种做法的缺点就是，需要在应用程序地址空间和内核进行多次拷贝，这些拷贝动作所带来的 CPU 以及内存开销是非常大的。</p><p>至于为什么不能直接让磁盘控制器把数据送到应用程序的地址空间中呢？最简单的一个原因就是应用程序不能直接操作底层硬件。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>在 linux 中，任何 IO 都被抽象为一个文件，有对应的文件描述符 fd。</p><p>select 系统调用时会首先将需要监控的所有 fd 从用户内存拷贝到内核内存，然后内核遍历自己监控的所有 fd，通过 poll 逻辑检查 socket 是否有读写事件，遍历完后如果有事件则返回遍历到的事件集合，如果没有事件则睡眠当前内核进程并设置唤醒条件为 fd 产生事件或 timeout 超时，内核进程唤醒后会再次遍历所有 fd（如果是 timeout 唤醒则不知道有没有事件，如果是事件唤醒则不知道哪些 IO 产生了哪些事件，所以都要整体遍历一遍），重复过程…</p><p>上述过程中的内核进程唤醒是通过软中断完成的，即 timeout 超时或某个 fd 产生事件的时候会触发一个软中断，操作系统探查时检测到中断会执行操作系统中断处理程序，唤醒相应的内核进程。</p><p>select 存在三个问题：</p><ul><li>每次调用 select，都需要把被监控的 fd 集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。</li><li>能监听端口的数量有限，单个进程所能打开的最大连接数受限于 FD_SETSIZE 宏定义。</li><li>每次都要遍历所有 fd，调用 socket 的 poll 函数查看事件</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同。针对 select 遗留的三个问题中的 fd 个数限制问题，poll 只是使用 pollfd 结构而不是 select 的 fd_set 结构，这使得不再存在 fd 个数限制，但是另外两个问题仍然存在。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>相比于 select，epoll 最大的好处在于它不使用轮询机制，所以不会随着监听 fd 数目的增长而降低效率。</p><p>epoll 系统调用函数内部有三个数据结构：</p><ul><li>wq：等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。</li><li>rbr：红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用的就是红黑树。通过红黑树来管理用户主进程 accept 添加进来的所有 socket 连接。</li><li>rdllist：就绪的描述符链表。当有连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。<strong>这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历红黑树的所有节点了。</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>select，poll 实现需要自己不断轮询所有 fd 集合，直到产生 IO 事件，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需要调用 epoll_wait 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是 IO 产生 IO 事件时，主动调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait 中睡眠的进程。虽然都要睡眠和交替，但是 select 和 poll 在“醒着”的时候要遍历整个 fd 集合，而 epoll 在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。这就是回调机制带来的性能提升。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/367591714">https://zhuanlan.zhihu.com/p/367591714</a></p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 是一个 java 中的多路复用 IO 接口，我们可以为 Selector 注册 channel，并绑定这个 channel 上的一些事件，绑定的事件类型可以有：</p><ul><li>connect：客户端连接成功时触发</li><li>accept：服务器端内核 tcp 就绪队列中有数据时触发</li><li>read：内核 tcp 接收缓冲区中有数据时触发</li><li>write：内核 tcp 发送缓冲区中有空闲位置时触发</li></ul><h3 id="三种监听事件方式"><a href="#三种监听事件方式" class="headerlink" title="三种监听事件方式"></a>三种监听事件方式</h3><ul><li>阻塞直到绑定事件发生<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure></li><li>阻塞直到绑定事件发生，或是超时<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select(<span class="hljs-type">long</span> timeout);<br></code></pre></td></tr></table></figure></li><li>不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.selectNow();<br></code></pre></td></tr></table></figure></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="基础-CS-架构"><a href="#基础-CS-架构" class="headerlink" title="基础 CS 架构"></a>基础 CS 架构</h4><p>注意示例代码中<code>iter.remove()</code>是必要的，因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己删除，如果不删除之后的每次<code>selector.selectedKeys()</code>调用都会携带这个 key。</p><p>另一个点就是如果<code>sc.read(buffer)</code>读取过后，tcp 接收缓冲区中还有没被读出来的数据（buffer 较小），那么读事件不会消失，下次的<code>selector.select()</code>会直接触发。</p><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>            channel.configureBlocking(<span class="hljs-literal">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br><span class="hljs-comment">//                int count = selector.selectNow();</span><br>                log.debug(<span class="hljs-string">&quot;select count: &#123;&#125;&quot;</span>, count);<br><span class="hljs-comment">//                if(count &lt;= 0) &#123;</span><br><span class="hljs-comment">//                    continue;</span><br><span class="hljs-comment">//                &#125;</span><br><br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br><br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                        sc.register(selector, SelectionKey.OP_READ);<br>                        log.debug(<span class="hljs-string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                        <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                            key.cancel();<br>                            sc.close();<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            buffer.flip();<br>                            debugAll(buffer);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)) &#123;<br>            System.out.println(socket);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;world&quot;</span>.getBytes());<br>            System.in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分隔符解决黏包半包"><a href="#分隔符解决黏包半包" class="headerlink" title="分隔符解决黏包半包"></a>分隔符解决黏包半包</h4><p>buffer 被 attach 到 key 事件中，读事件触发后，可以从读事件 key 中取出这个 socket 的 buffer，如果 buffer 不够长还会动态扩容。这种方式每次都要检测分隔符，因此效率比较低。</p><h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(ByteBuffer source)</span> &#123;<br>    source.flip();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; source.limit(); i++) &#123;<br>        <span class="hljs-comment">// 找到一条完整消息</span><br>        <span class="hljs-keyword">if</span> (source.get(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> - source.position();<br>            <span class="hljs-comment">// 把这条完整消息存入新的 ByteBuffer</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(length);<br>            <span class="hljs-comment">// 从 source 读，向 target 写</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                target.put(source.get());<br>            &#125;<br>            debugAll(target);<br>        &#125;<br>    &#125;<br>    source.compact(); <span class="hljs-comment">// 0123456789abcdef  position 16 limit 16</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. 创建 selector, 管理多个 channel</span><br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 2. 建立 selector 和 channel 的联系（注册）</span><br>    <span class="hljs-comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sscKey</span> <span class="hljs-operator">=</span> ssc.register(selector, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// key 只关注 accept 事件</span><br>    sscKey.interestOps(SelectionKey.OP_ACCEPT);<br>    log.debug(<span class="hljs-string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);<br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span><br>        <span class="hljs-comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span><br>        selector.select();<br>        <span class="hljs-comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span><br>        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="hljs-comment">// accept, read</span><br>        <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>            <span class="hljs-comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span><br>            iter.remove();<br>            log.debug(<span class="hljs-string">&quot;key: &#123;&#125;&quot;</span>, key);<br>            <span class="hljs-comment">// 5. 区分事件类型</span><br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">// 如果是 accept</span><br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> channel.accept();<br>                sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>); <span class="hljs-comment">// attachment</span><br>                <span class="hljs-comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">scKey</span> <span class="hljs-operator">=</span> sc.register(selector, <span class="hljs-number">0</span>, buffer);<br>                scKey.interestOps(SelectionKey.OP_READ);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sc);<br>                log.debug(<span class="hljs-string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123; <span class="hljs-comment">// 如果是 read</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel(); <span class="hljs-comment">// 拿到触发事件的channel</span><br>                    <span class="hljs-comment">// 获取 selectionKey 上关联的附件</span><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer); <span class="hljs-comment">// 如果是正常断开，read 的方法的返回值是 -1</span><br>                    <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>) &#123;<br>                        key.cancel();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        split(buffer);<br>                        <span class="hljs-comment">// 需要扩容</span><br>                        <span class="hljs-keyword">if</span> (buffer.position() == buffer.limit()) &#123;<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">newBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="hljs-number">2</span>);<br>                            buffer.flip();<br>                            newBuffer.put(buffer); <span class="hljs-comment">// 0123456789abcdef3333\n</span><br>                            key.attach(newBuffer);<br>                        &#125;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                    key.cancel();  <span class="hljs-comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6984</span>)) &#123;<br>            System.out.println(socket);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;hello\n&quot;</span>.getBytes());<br>            Thread.sleep(<span class="hljs-number">1500</span>);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;hellogqesabqeadrbdbr\n***&quot;</span>.getBytes());<br>            Thread.sleep(<span class="hljs-number">1500</span>);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;helloedqabaaaaaaehberqedbhrhbarbrwbrdw\n&quot;</span>.getBytes());<br>            System.in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="写事件解决数据太长一次无法写完"><a href="#写事件解决数据太长一次无法写完" class="headerlink" title="写事件解决数据太长一次无法写完"></a>写事件解决数据太长一次无法写完</h4><p>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）。</p><p>注意只有一次没写完才注册写事件，数据都写完之后要及时取消写事件注册，否则之后只要 tcp 发送缓冲区有空闲空间就还会触发。</p><h5 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br><br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sckey</span> <span class="hljs-operator">=</span> sc.register(selector, SelectionKey.OP_READ);<br>                    <span class="hljs-comment">// 1. 向客户端发送内容</span><br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000000</span>; i++) &#123;<br>                        sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buffer);<br>                    <span class="hljs-comment">// 3. write 表示实际写了多少字节</span><br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-comment">// 4. 如果有剩余未读字节，才需要关注写事件</span><br>                    <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                        <span class="hljs-comment">// read 1  write 4</span><br>                        <span class="hljs-comment">// 在原有关注事件的基础上，多关注 写事件</span><br>                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);<br>                        <span class="hljs-comment">// 把 buffer 作为附件加入 sckey</span><br>                        sckey.attach(buffer);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="hljs-comment">// 写完了</span><br>                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);<br>                        key.attach(<span class="hljs-literal">null</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);<br>        sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>                    System.out.println(sc.finishConnect());<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>                    count += sc.read(buffer);<br>                    buffer.clear();<br>                    System.out.println(count);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="多线程优化-每个线程可以处理事件和执行异步任务"><a href="#多线程优化-每个线程可以处理事件和执行异步任务" class="headerlink" title="多线程优化-每个线程可以处理事件和执行异步任务"></a>多线程优化-每个线程可以处理事件和执行异步任务</h4><ul><li>主线程：做一些准备就结束</li><li>accept 线程：针对每个新连接都轮询地提交异步任务</li><li>多个 eventloop 线程：处理事件和执行异步任务</li></ul><h5 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossEventLoop</span>().register();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> Selector boss;<br>        <span class="hljs-keyword">private</span> WorkerEventLoop[] workers;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>                ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>                boss = Selector.open();<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">ssckey</span> <span class="hljs-operator">=</span> ssc.register(boss, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>                ssckey.interestOps(SelectionKey.OP_ACCEPT);<br>                workers = initEventLoops();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;boss&quot;</span>).start();<br>                log.debug(<span class="hljs-string">&quot;boss start...&quot;</span>);<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;<br><span class="hljs-comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span><br>            WorkerEventLoop[] workerEventLoops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerEventLoops.length; i++) &#123;<br>                workerEventLoops[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> workerEventLoops;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    boss.select();<br>                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                            log.debug(<span class="hljs-string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());<br>                            workers[index.getAndIncrement() % workers.length].register(sc);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> Selector worker;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkerEventLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>            <span class="hljs-built_in">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(SocketChannel sc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                worker = Selector.open();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;worker-&quot;</span> + index).start();<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            tasks.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sckey</span> <span class="hljs-operator">=</span> sc.register(worker, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>                    sckey.interestOps(SelectionKey.OP_READ);<br>                    worker.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            worker.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    worker.select();<br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> tasks.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                                    key.cancel();<br>                                    sc.close();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    buffer.flip();<br>                                    log.debug(<span class="hljs-string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());<br>                                    debugAll(buffer);<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                                key.cancel();<br>                                sc.close();<br>                            &#125;<br>                        &#125;<br>                        iter.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>因为 UDP 是无连接的，不是面向字节流而是面向数据报的，UDP 客户端在传输层发送一个 UDP 数据报，会在网络层拆成多个 IP 数据报，在服务端的网络层中如果所有 IP 数据报都到齐了，则会组装成 UDP 数据报给到传输层。</p><p>这样带来的结果是，无论服务端是否绑定端口，客户端都可以直接发送 UDP 数据报，如果 UDP 数据报已经到达服务端的时候，服务端仍未绑定端口并等待接收，那么 UDP 数据报不会被缓存而是被直接丢弃。</p><h5 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            channel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">32</span>);<br>            channel.receive(buffer);<br>            buffer.flip();<br>            debug(buffer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> DatagramChannel.open()) &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>);<br>            channel.send(buffer, address);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h2><h3 id="java-中-stream-api-和-channel-api-的区别"><a href="#java-中-stream-api-和-channel-api-的区别" class="headerlink" title="java 中 stream api 和 channel api 的区别"></a>java 中 stream api 和 channel api 的区别</h3><ul><li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li></ul><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="传统-IO"><a href="#传统-IO" class="headerlink" title="传统 IO"></a>传统 IO</h4><p>传统 IO 将磁盘文件写入网卡的构成存在两次系统调用和四次数据拷贝，分别是磁盘数据通过 DMA 读到内核内存，内核内存复制数据到用户内存，用户内存复制数据到 socket 缓冲区，socket 缓冲区数据通过 DMA 发到网卡（注：DMA 用于解放 cpu 完成文件 IO）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br>file.read(buf);<br><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><h4 id="三种零拷贝优化"><a href="#三种零拷贝优化" class="headerlink" title="三种零拷贝优化"></a>三种零拷贝优化</h4><p>所谓零拷贝指的是尽可能减少数据复制的次数以及用户态内核态切换的次数。</p><ul><li>第一种：内核内存不再复制数据到用户内存，我们可以使用 DirectByteBuf 将堆外内存（内核内存）映射到 jvm 内存中来直接访问使用，需要注意 DirectByteBuf 不会被 java gc，需要手动释放。这种情况涉及两次系统调用和三次数据拷贝。</li><li>第二种：依赖 linux 2.1 后提供的 sendFile 方法。java 调用 transferTo 方法后，在内核态依次执行磁盘数据读入内核缓冲区，内核缓冲区数据复制到 socket 缓冲区，socket 缓冲区数据写入网卡三个操作。这种情况涉及一次系统调用和三次数据拷贝。</li><li>第三种：linux 2.4 的进一步优化。在第二种的基础上将内核缓冲区的数据直接写入网卡。这种情况涉及一次系统调用和两次数据拷贝。</li></ul><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO 指的是异步 IO，之前无论是阻塞 read 还是非阻塞 read 都是同步的，也就是说它们从网卡 IO 读数据到内核内存，再从内核内存复制数据到用户内存的过程都是当前线程来完成的。AIO 把这个过程交给了一个异步线程来完成，并通过注册回调的方式通知当前线程数据结果。异步 read 函数的执行是最快的，因为它甚至不需要陷入内核态。</p><p>而在异步线程中执行的 read 任务，其方式是阻塞&#x2F;非阻塞&#x2F;多路复用其实都是可以的。</p><h4 id="文件-AIO"><a href="#文件-AIO" class="headerlink" title="文件 AIO"></a>文件 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">AsynchronousFileChannel</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span><br>                AsynchronousFileChannel.open(<br>                Paths.get(<span class="hljs-string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            s.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read completed...&#123;&#125;&quot;</span>, result);<br>                    buffer.flip();<br>                    debug(buffer);<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;read failed...&quot;</span>);<br>                &#125;<br>            &#125;);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;do other things...&quot;</span>);<br>        System.in.read();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><p>下面的整个过程都是异步完成的，包括<code>AsynchronousServerSocketChannel</code>和<code>AsynchronousSocketChannel</code>，代码首先提交了 accept 任务并在 accept 任务的 Completion 处理中提交一个 read 任务、一个 write 任务和一个 accept 任务，在 read 任务的 Completion 处理中，会打印 buffer 数据并再次提交 read 任务，在 write 任务的 Completion 处理中会查看当前待发送 buffer 中是否还有剩余数据，如果还有剩余数据，则再次提交 write 任务。所有任务都是在一个异步线程池中执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open();<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceptHandler</span>(ssc));<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeChannel</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.printf(<span class="hljs-string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            sc.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReadHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (result == -<span class="hljs-number">1</span>) &#123;<br>                    closeChannel(sc);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>                attachment.flip();<br>                System.out.println(Charset.defaultCharset().decode(attachment));<br>                attachment.clear();<br>                <span class="hljs-comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span><br>                sc.read(attachment, attachment, <span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            closeChannel(sc);<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel sc;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">WriteHandler</span><span class="hljs-params">(AsynchronousSocketChannel sc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sc = sc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>            <span class="hljs-comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span><br>            <span class="hljs-keyword">if</span> (attachment.hasRemaining()) &#123;<br>                sc.write(attachment);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>            exc.printStackTrace();<br>            closeChannel(sc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel ssc;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AcceptHandler</span><span class="hljs-params">(AsynchronousServerSocketChannel ssc)</span> &#123;<br>            <span class="hljs-built_in">this</span>.ssc = ssc;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 读事件由 ReadHandler 处理</span><br>            sc.read(buffer, buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadHandler</span>(sc));<br>            <span class="hljs-comment">// 写事件由 WriteHandler 处理</span><br>            sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="hljs-number">16</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteHandler</span>(sc));<br>            <span class="hljs-comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span><br>            ssc.accept(<span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> &#123;<br>            exc.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>在异步编程中，Future 可以看作是一个多线程结果容器</p><h3 id="pipeline-过程"><a href="#pipeline-过程" class="headerlink" title="pipeline 过程"></a>pipeline 过程</h3><p>一个 channel 有一个 pipeline，pipeline 是一个 <code>AbstractChannelHandlerContext</code>类型 的双向链表，<code>AbstractChannelHandlerContext</code> 是一个抽象父类，有三种实现分别是<code>HeadContext</code>、<code>TailContext</code>和<code>DefaultChannelHandlerContext</code>。pipeline 的头节点是 <code>HeadContext</code> 对象，尾节点是 <code>TailContext</code> 对象，中间都是我们自行添加的 <code>DefaultChannelHandlerContext</code> 对象。</p><h4 id="链式调用例子"><a href="#链式调用例子" class="headerlink" title="链式调用例子"></a>链式调用例子</h4><p>下面是服务端代码的一个典型模板，首先初始化了一个服务器的 <code>Bootstrap</code> 对象，然后设置 <code>NioEventLoopGroup</code>，设置 channel 类型，添加一个对 <code>NioSocketChannel</code> 做初始化操作的回调，在回调中按顺序添加了一些<code>ChannelHandler</code>，每一个 <code>ChannelHandler</code> 都关联 pipeline 中的一个 <code>DefaultChannelHandlerContext</code>。</p><p><code>ChannelHandler</code> 有两个子接口，分别是 <code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code>，对应有 <code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 实现。<code>ChannelInboundHandlerAdapter</code> 是入站处理器，用于处理收到的消息，里面定义了一些方法比如<code>channelRegistered</code>、<code>channelActive</code>、<code>channelRead</code>等等。<code>ChannelOutboundHandlerAdapter</code> 是出站处理器，用于处理发出的消息，里面定义了一些方法比如<code>write</code>等等。我们在<code>ch.pipeline().addLast()</code>中添加的 <code>ChannelHandler</code>，可以是入站处理器、出站处理器或者出入站处理器。</p><p>下面这段代码中，ctx 对象的编译类型是 <code>ChannelHandlerContext</code>，而实际运行类型则是当前 <code>ChannelHandler</code> 对应的 <code>DefaultChannelHandlerContext</code> 对象。其中，<code>ctx.fireChannelRead(msg)</code>用于继续执行下一个 <code>InboundHandler</code> 的 <code>channelRead</code> 方法，<code>ctx.channel().write(msg)</code>是先获取当前 <code>DefaultChannelHandlerContext</code> 对象所在 pipeline 对应的 channel，然后由 channel 对象调 write 方法，channel 对象调 write 方法会返回一个 future，说明 write 方法的调用栈存在异步任务提交操作。channel 对象调 write 方法的具体过程是先执行 pipeline 最后一个 <code>OutboundHandler</code>（也就是 <code>TailContext</code>）的 write 方法，然后再依次向前执行每个 <code>OutboundHandler</code> 的 write 方法，直到最后执行了 <code>HeadContext</code> 的 write 方法，在 <code>HeadContext</code> 的 write 方法中会提交一个真正将 bytebuf 写入到 tcp 发送缓冲区的异步任务，这也就是返回 future 的原因，可以看到这其实是一个链式方法栈的调用过程。<code>ctx.write(msg, promise)</code>是 <code>ChannelHandlerContext</code> 对象调 write 方法，这回不会找 pipeline 中最后一个 <code>OutboundHandler</code>，而是找当前位置的前一个 <code>OutboundHandler</code>。</p><p>如果 eventloop 底层的 selector 触发了 IO 的可读事件，则底层会首先拿到一个原始的 bytebuf（里面放了本次从 tcp 接收缓冲区中读出的数据），然后将 bytebuf 传给第一个<code>InboundHandler</code>（也就是 <code>HeadContext</code>）的 channelRead 方法，然后再依次向后链式调用，需要注意的是这个链式调用依靠 <code>fireChannelRead</code>，也就是说如果某个 <code>channelRead</code> 方法没有调 <code>ctx.fireChannelRead</code>，那么链式调用到这里就截止了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>    .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>    .channel(NioServerSocketChannel.class)<br>    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                    ctx.fireChannelRead(msg); <span class="hljs-comment">// 1</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                    System.out.println(<span class="hljs-number">2</span>);<br>                    ctx.fireChannelRead(msg); <span class="hljs-comment">// 2</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                    System.out.println(<span class="hljs-number">3</span>);<br>                    ctx.channel().write(msg); <span class="hljs-comment">// 3</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg,</span><br><span class="hljs-params">                                  ChannelPromise promise)</span> &#123;<br>                    System.out.println(<span class="hljs-number">4</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 4</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg,</span><br><span class="hljs-params">                                  ChannelPromise promise)</span> &#123;<br>                    System.out.println(<span class="hljs-number">5</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 5</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg,</span><br><span class="hljs-params">                                  ChannelPromise promise)</span> &#123;<br>                    System.out.println(<span class="hljs-number">6</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 6</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .bind(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>上面这段代码的执行结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="固定长度接收分组例子"><a href="#固定长度接收分组例子" class="headerlink" title="固定长度接收分组例子"></a>固定长度接收分组例子</h4><h5 id="LoggingHandler"><a href="#LoggingHandler" class="headerlink" title="LoggingHandler"></a>LoggingHandler</h5><p>下面这段代码在 pipeline 的最开始加了一个 <code>LoggingHandler</code> 对象，<code>LoggingHandler</code> 同时实现了 <code>ChannelInboundHandler</code> 接口和 <code>ChannelOutboundHandler</code> 接口，是一个出入站处理器，<code>LoggingHandler</code> 对出入站的所有方法都在链式的基础上做了打印日志的增强。针对正向的读过程，它将会打印原始 bytebuf，针对反向的写过程，它将会打印给到 <code>HeadContext</code> 的 write 方法之前的最终 bytebuf。</p><h5 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h5><p>在<code>SocketChannel</code>完全准备好之后，会从前向后链式调用 pipeline 中 每个 <code>InboundHandler</code> 的 <code>channelActive</code> 方法，首先走 <code>HeadContext</code>的 <code>channelActive</code> 方法（执行一些默认操作），然后走 <code>LoggingHandler</code> 的 <code>channelActive</code> 方法（执行一些日志操作），然后走自己写的 <code>channelActive</code> 方法，生成一个 bytebuf，然后调 <code>ctx.writeAndFlush(buffer)</code>，然后走当前位置的前一个 <code>ChannelOutboundHandler</code>（也就是 <code>LoggingHandler</code>）的 write 方法（执行一些日志操作），然后走 <code>HeadContext</code> 的 write 方法，提交一个将 bytebuf 写入 tcp 发送缓冲区的异步任务，最后方法栈递归返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap.channel(NioSocketChannel.class);<br>        bootstrap.group(worker);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                        <span class="hljs-comment">// 发送内容随机的数据包</span><br>                        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>                        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; r.nextInt(<span class="hljs-number">8</span>); j++) &#123;<br>                                bytes[j] = (<span class="hljs-type">byte</span>) c;<br>                            &#125;<br>                            c++;<br>                            buffer.writeBytes(bytes);<br>                        &#125;<br>                        ctx.writeAndFlush(buffer);<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9090</span>).sync();<br>        channelFuture.channel().closeFuture().sync();<br><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        worker.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h5><p><code>FixedLengthFrameDecoder</code> 可以按照固定长度接收分组，它是一个入站处理器，实现了 <code>ChannelInboundHandler</code> 接口。对于原始的 bytebuf，按照固定长度进行切分，对于每个切分都要链式调一遍 pipeline 上接下来的 <code>ChannelInboundHandler</code>。如果不够切分长度了则会保存下来拼接到下一次的 bytebuf 继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>            .channel(NioServerSocketChannel.class)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLengthFrameDecoder</span>(<span class="hljs-number">8</span>));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                &#125;<br>            &#125;)<br>            .bind(<span class="hljs-number">9090</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些其他的-ChannelHandler"><a href="#一些其他的-ChannelHandler" class="headerlink" title="一些其他的 ChannelHandler"></a>一些其他的 ChannelHandler</h3><p>固定分隔符，默认以 \n 或 \r\n 作为分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LineBasedFrameDecoder</span>(<span class="hljs-number">1024</span>));<br></code></pre></td></tr></table></figure><p>预设长度，在发送消息前，先约定用定长字节表示接下来数据的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthFieldBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>http 协议解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br></code></pre></td></tr></table></figure><h3 id="Bind-过程"><a href="#Bind-过程" class="headerlink" title="Bind 过程"></a>Bind 过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br><span class="hljs-comment">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br><span class="hljs-type">NioServerSocketChannel</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioServerSocketChannel</span>();<br><br><span class="hljs-comment">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">//4 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">//7 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p>上面过程是 java 原生 nio 代码，在 netty 中，这些逻辑都被放在了 <code>bind</code> 方法中。<code>bind</code> 是一个异步方法，会返回一个 future，<code>bind</code> 方法主要提交了先后两个异步任务，在第一个异步任务中会初始化 <code>ServerSocketChannel</code> 对象并将其绑定给某个 eventloop，在这个异步任务中会执行 <code>channelRegistered</code> 的链式调用。在第二个异步任务中会真正为 <code>ServerSocketChannel</code> 绑定某个 tcp 端口，然后将 <code>ServerSocketChannel</code> 绑定给 eventloop 对应的 <code>selector</code>，最后绑定 OP_ACCEPT 事件。</p><h3 id="Eventloop-过程"><a href="#Eventloop-过程" class="headerlink" title="Eventloop 过程"></a>Eventloop 过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        eventExecutors.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们可以从以上这段代码开始调试（核心在 NioEventLoop 的 run 方法），分析可以得出如下要点：</p><ul><li>eventloop 会在第一次有异步任务提交的时候开启线程。</li><li>eventloop 采用队列来存储提交的异步任务（自己的或其他线程的）。</li><li>eventloop 支持处理多路 IO 事件、执行普通任务和执行定时任务。</li><li>在 run 方法的循环中，如果任务队列有任务，则会调<code>this.selector.selectNow()</code>来非阻塞式的获取所有事件，然后调<code>this.processSelectedKeys()</code>处理所有的事件，再调<code>this.runAllTasks(ioTime * (long)(100 - ioRatio) / (long)ioRatio)</code>按照时间比例限制去执行队列中的一些任务，ioRatio 是处理事件时间占总时间（处理事件时间+执行任务时间）的占比。比如本次循环处理事件用了 8s，而 ioRatio 被设成 80%，那么本次循环留给任务执行的时间只有 2s，<code>runAllTasks</code> 方法的内部会不断地从队头 poll 任务来执行，当发现没有时间的时候就不会再继续执行剩下的任务。ioRatio 默认是 50%，也就是事件处理和任务执行占用大概相同的时间。</li><li>如果在 run 方法的循环中一开始没有任务，则会进入 select 循环，执行 <code>selector.select(timeoutMillis)</code>阻塞式的获取多路 IO 事件，其中超时时间 <code>timeoutMillis</code> 默认是 1s。如果一直阻塞到超时，那么会判断一些条件（当前是否被唤醒、是否有任务等）以决定是否跳出 select 循环向下执行，否则继续执行<code>selector.select(timeoutMillis)</code>。如果在阻塞过程中触发了 IO 事件或者 selector 被唤醒，则 <code>selector.select(timeoutMillis)</code>会返回然后直接跳出 select 循环向下执行<code>this.processSelectedKeys()</code>和<code>this.runAllTasks(ioTime * (long)(100 - ioRatio) / (long)ioRatio)</code>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网关</title>
    <link href="/notes/2023/12/05/Project%20%E7%BD%91%E5%85%B3/"/>
    <url>/notes/2023/12/05/Project%20%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>实现基于配置的请求路由</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网盘</title>
    <link href="/notes/2023/11/26/Project%20%E7%BD%91%E7%9B%98%20/"/>
    <url>/notes/2023/11/26/Project%20%E7%BD%91%E7%9B%98%20/</url>
    
    <content type="html"><![CDATA[<h1 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h1><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h3><ul><li><p>✅ 搭好项目架子</p></li><li><p>✅ 用户注册登陆</p></li><li><p>✅ 上传图片，图片列表</p></li><li><p>✅ 个人相册浏览，图像详细资料展示卡片</p></li><li><p>✅ 图片分组保管</p></li><li><p>✅ 图片链接</p></li><li><p>用户主页个人介绍</p></li><li><p>头像</p></li><li><p>动态</p></li><li><p>个人关注&#x2F;粉丝</p></li><li><p>关注的人专栏</p></li><li><p>等级</p><ul><li>登录 exp 加 5（每日一次）</li><li>浏览一篇博客加 5（每日一次）</li><li>点赞一条评论加 3（每日上限 30）</li><li>你的评论被他人点赞加 1（无上限）</li><li>你的博客被他人收藏加 1（无上限）</li><li>发布一篇博客加 10（每日两次）</li></ul></li><li><p>个人仪表盘监控</p></li><li><p>个人历史记录</p></li><li><p>个人回收站</p></li><li><p>个人收藏夹</p></li><li><p>图库浏览</p></li><li><p>图库浏览衍生功能</p><ul><li>点赞</li><li>评论</li><li>分享</li><li>收藏</li></ul></li><li><p>图片复杂检索（个人&#x2F;全站）</p></li><li><p>积分</p></li><li><p>下单（下单超时未支付）</p></li><li><p>审核中台</p></li><li><p>后台管理</p></li><li><p>稿件管理</p></li><li><p>个人喜好频道</p></li><li><p>✅ 对博客进行点赞、收藏</p></li><li><p>相似图片的博客推送（推荐算法）</p></li><li><p>图片压缩</p></li><li><p>✅ 全局搜索</p><ul><li>博客搜索<ul><li>作者名&#x2F;标题&#x2F;内容分词匹配</li><li>标签限定</li><li>排序<ul><li>点赞排序</li><li>评论数排序</li><li>新发布</li></ul></li></ul></li><li>用户搜索</li></ul></li></ul><h3 id="微服务划分"><a href="#微服务划分" class="headerlink" title="微服务划分"></a>微服务划分</h3><ul><li>user-service*1</li></ul><h3 id="Mysql-表设计"><a href="#Mysql-表设计" class="headerlink" title="Mysql 表设计"></a>Mysql 表设计</h3><ul><li>用户表<ul><li>用户 ID</li><li>用户名</li><li>密码</li><li>邮箱</li><li>创建时间</li><li>修改时间</li></ul></li><li>图片表<ul><li>图片 ID</li><li>所属用户 ID</li><li>图片名称</li><li>所属分组 ID</li><li>描述</li><li>上传时间</li></ul></li><li>分组表<ul><li>分组 ID</li><li>所属用户 ID</li><li>分组名称</li></ul></li><li>标签表<ul><li>标签 ID</li><li>标签名称</li></ul></li><li>博客表<ul><li>博客 ID</li><li>所属用户 ID</li><li>标题</li><li>图片 ID</li><li>内容（普通文本）</li><li>创建时间</li><li>评论数</li><li>收藏数</li></ul></li><li>博客&amp;标签关系表<ul><li>博客 ID</li><li>标签 ID</li></ul></li><li>博客评论表<ul><li>评论 ID</li><li>所属用户 ID</li><li>所属博客 ID</li><li>文本内容</li><li>父评论 ID</li><li>点赞数</li><li>评论发布时间</li><li>楼层数（按时间顺序）</li></ul></li><li>用户&amp;评论的点赞关系表<ul><li>用户 ID</li><li>评论 ID</li></ul></li><li>用户&amp;博客收藏关系表<ul><li>用户 ID</li><li>博客 ID</li></ul></li><li>用户关注用户关系表（复合索引）<ul><li>关注者 ID</li><li>被关注者 ID</li></ul></li></ul><h2 id="用到的技术"><a href="#用到的技术" class="headerlink" title="用到的技术"></a>用到的技术</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><a href="http://10.129.0.31:15672/">http://10.129.0.31:15672/</a></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="http://10.129.0.31:6379/">http://10.129.0.31:6379/</a></p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p><a href="http://10.129.0.31:8848/">http://10.129.0.31:8848/</a></p><p>管理页面：<a href="http://10.129.0.31:8848/nacos">http://10.129.0.31:8848/nacos</a></p><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><h4 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h4><p><a href="http://10.129.0.31:5601/">http://10.129.0.31:5601/</a></p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><a href="http://10.129.0.31:3306/">http://10.129.0.31:3306/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>银行专场就业分享</title>
    <link href="/notes/2023/11/24/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E9%93%B6%E8%A1%8C%E4%B8%93%E5%9C%BA%E5%B0%B1%E4%B8%9A%E5%88%86%E4%BA%AB/"/>
    <url>/notes/2023/11/24/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E9%93%B6%E8%A1%8C%E4%B8%93%E5%9C%BA%E5%B0%B1%E4%B8%9A%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="银行专场"><a href="#银行专场" class="headerlink" title="银行专场"></a>银行专场</h1><h2 id="1-快手大模型算法"><a href="#1-快手大模型算法" class="headerlink" title="1 快手大模型算法"></a>1 快手大模型算法</h2><p>40%沟通+60%技术<br>校招需要注意：团队氛围+老大风格+工作内容很重要。尽量去熟悉的地方</p><p>提前批能参加就参加，机会比较多</p><p>快手错一道算法下一面就寄</p><p>知识要多总结</p><p>简历+ppt，ppt 详述简历的每一个点</p><p>不要光看组的 title，需要详细和内推人了解组内详细情况</p><p>argue 薪资很重要，非常有用</p><p>同事之间和平相处，上下级沟通非常重要（嫡系文化）</p><h2 id="2-农行-中国银行-中银理财"><a href="#2-农行-中国银行-中银理财" class="headerlink" title="2 农行 中国银行 中银理财"></a>2 农行 中国银行 中银理财</h2><p>暑假直接农行实习</p><p>国企不看重实习，面试也不怎么问</p><p>运营商&#x2F;银行&#x2F;研究所</p><p>国企也要海投</p><p>春招很多好 offer（别人鸽的），秋招不要毁约</p><p>亮点非常重要：互联网和国企都是，因为面试官看多了千篇一律的</p><p>国企隔一个月才会到二次面试</p><p>国企进 hr 面&#x2F;领导面&#x3D;拿 offer</p><p>8:30-7：00 周末双休</p><p>无 35 岁危机</p><p>校招银行不需要考证</p><p>国企秋招挂不影响春招</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>8:30-7：00 周末双休</p><p>三段实习？看来没有实习就寄。</p><p>稳定一些不太被裁&#x3D;银行</p><p>银行薪资和互联网差 10w-20w</p><p>科研根本不会问</p><p>行测和申论到时候刷就行</p><p>面银行如果有一定的金融素养、银行业务相关了解的话会很加分</p><p>java 比较好学，学的人也比较多，一定要有独特亮点才可以。</p><p>互联网中业务好的组一般技术也比较好，总之还是要去核心组</p><p>银行投递会有几个志愿</p><p>省行（甲方）或者软件中心（乙方，累一些）</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>国考？？？<br>北邮本硕是总行守门员</p><p>行测一定要提前准备，基本占 50%</p>]]></content>
    
    
    
    <tags>
      
      <tag>就业分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器跨域问题</title>
    <link href="/notes/2023/11/24/%E5%85%AB%E8%82%A1%E7%AF%87%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%20/"/>
    <url>/notes/2023/11/24/%E5%85%AB%E8%82%A1%E7%AF%87%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%20/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>只要满足如下一条不同就存在跨域：</p><ul><li>协议不同</li><li>域名不同</li><li>端口不同</li></ul><p>浏览器限制当前页面不可以跨域获取浏览器缓存 cookie，不可以跨域发送 ajax 请求。跨域限制主要是为了用户的信息安全。</p><h2 id="浏览器如何判断跨域"><a href="#浏览器如何判断跨域" class="headerlink" title="浏览器如何判断跨域"></a>浏览器如何判断跨域</h2><p>跨域 ajax 请求的判断流程为：</p><ul><li>如果该请求为简单请求，浏览器会直接发送实际请求到服务端，浏览器会根据服务端的响应，判断该请求是否可以跨域。如果不能跨域，浏览器会报错，阻止 JS 代码进一步执行。如果能够跨域，则 JS 能正常处理响应，进行后续业务流程。</li><li>如果该请求为非简单请求，浏览器会先发送一个预检请求(preflight)，方法为 OPTIONS，然后针对服务器的响应，做上述跟简单请求一样相同的判断：如果不能跨域，则实际请求不会发送。如果能够跨域，则实际请求会进行发送，进行后续业务处理。</li></ul><p>值得说明的是，浏览器在跨域的情况下，请求都会发送出去，但是对于响应会判断是否满足跨域条件，如果不满足，则报错，阻止 JS 后续的执行流程，例如读取响应数据等。也就是说，跨域机制主要是阻止数据的跨域获取，不是阻止请求的发送。</p><p>服务端 http 响应分组中的 Access-Control-Allow-Origin 决定了此跨域请求是否被服务端允许，字段值可以填 _（通配符）或者单域名。_代表服务端允许任意跨域请求，单域名代表服务端允许来自此域名的跨域请求。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/159060398">https://zhuanlan.zhihu.com/p/159060398</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud总结</title>
    <link href="/notes/2023/11/23/%E6%80%BB%E7%BB%93%E7%AF%87%20SpringCloud%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/23/%E6%80%BB%E7%BB%93%E7%AF%87%20SpringCloud%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud-总结"><a href="#SpringCloud-总结" class="headerlink" title="SpringCloud 总结"></a>SpringCloud 总结</h1><p>分布式架构相比于单体架构具有低耦合、业务拆分的特点，但也引入了一些问题比如数据一致性问题、复杂调用关系等等。微服务是一种分布式架构标准，微服务强调拆分粒度小、每个微服务独立程度高、每个微服务向外提供标准接口。</p><p>微服务拆分原则需要遵守：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li></ul><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配。SpringCloud 和 SpringBoot 之间存在版本兼容关系。</p><p>SpringCloud 中的各种微服务之间采用 http 协议进行接口调用。RestTemplate 接口提供了 http 借口调用的实现。</p><h2 id="微服务注册中心"><a href="#微服务注册中心" class="headerlink" title="微服务注册中心"></a>微服务注册中心</h2><p>微服务注册中心支持服务提供者注册信息，支持服务消费者获取服务提供者的注册信息。相比于服务提供者的接口地址写死在服务消费者代码中的方式，微服务注册中心一方面支持随时的服务提供者变动，另一方面也支持微服务调用的负载均衡。</p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka 支持服务提供者注册服务信息，支持服务消费者定时拉取服务信息。服务提供者通过心跳的方式（默认 30s）告知 Eureka 自己的健康状态。</p><p>我们可以直接在 SpringBoot 中启动一个 Eureka 微服务（通过引入相关依赖、配置 yml 文件、配置注解），然后将其他微服务作为服务提供者注册到 Eureka（通过引入相关依赖、配置 yml 文件），最后作为服务消费者的任何微服务都可以拉取 Eureka 中的服务注册信息进行相应的微服务接口调用（通过引入相关依赖、配置 yml 文件、配置注解）。</p><p>微服务接口调用的负载均衡是通过 Ribbon 实现的，Ribbon 默认是采用懒加载。负载均衡接口 IRule 有一些默认的接口实现比如轮询（RoundRobin）、权重、区域优先等等。</p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos 是阿里的产品，相比 Eureka 功能更丰富。Nacos 直接提供了操作系统可以直接运行的 bin 文件（依赖 jre）。</p><h4 id="服务注册与拉取"><a href="#服务注册与拉取" class="headerlink" title="服务注册与拉取"></a>服务注册与拉取</h4><p>Nacos 将一个服务分为了多个集群（通常一个集群指的是某区域的一个机房），每个集群又分为了多个实例。微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。</p><p>我们同样可以通过引入相关依赖、配置 yml 文件、操作 Nacos 的 web 控制台的方式，完成服务提供者的集群注册、负载权重配置、服务消费者拉取信息等操作。</p><p>Nacos 注册中心对于服务提供者除了心跳检测还会主动询问，除了服务消费者会定时拉取 Nacos 注册中心信息外，Nacos 还会向服务消费者主动推送变更消息。</p><h4 id="配置管理与热更新"><a href="#配置管理与热更新" class="headerlink" title="配置管理与热更新"></a>配置管理与热更新</h4><p>我们可以在 Nacos 的 web 控制台上创建 yaml 配置，并将需要热更新的配置放在其中，这样微服务的配置信息就由 bootstrap.yaml、Nacos 在线 yaml 和 application.yml 共同组成，我们通过@Value 注解或@ConfigurationProperties 注解就可以读取热更新配置。当然上述过程还是需要通过引入相关依赖、配置 yml 文件、配置注解来完成。</p><p>Nacos 在线 yaml 配置有两种：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p><code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><h2 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h2><p>单体应用只需要提供接口给用户即可，但微服务由于其高内聚低耦合的特点，一方面微服务接口的实现需要依赖其他微服务接口，另一方面微服务接口也需同时提供给用户和其他微服务。</p><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>Feign 是一种接口声明式的 http 微服务调用请求，我们可以对每个微服务声明一个接口，在里面为微服务的每个服务接口声明一个方法，可以指定微服务名称（用来从注册中心拉取信息）、请求方式（Get）、资源路径、pojo 返回类型。Feign 的微服务调用和 RPC 有点像。</p><p>Feign 底层依赖的 http 请求框架有多种，如果选择支持 http 连接池的框架则可能会带来性能优化。</p><h2 id="微服务网关"><a href="#微服务网关" class="headerlink" title="微服务网关"></a>微服务网关</h2><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Gateway 基于响应式编程，提供了权限控制、请求路由和服务限流等核心功能。</p><ul><li>权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</li><li>路由和负载均衡：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</li><li>限流：当请求流量过高时，在网关中按照对应微服务能够接受的速度来放行请求，避免服务压力过大。</li></ul><p>引入相关依赖、配置 yml 文件即可启动 Gateway 网关微服务。</p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器可以对路由的请求或响应做加工处理，比如添加请求头等。Gateway 提供了多种类型的过滤器实现，我们可以在 yml 文件中配置路由过滤器和默认过滤器（只可以使用 Gateway 提供的过滤器），我们也可以实现自己的全局过滤器，通过编写自定义逻辑实现登陆状态判断、权限校验、请求限流等功能。</p><p>多个过滤器执行的先后顺序取决于 order 值。</p><h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>application.yml 中可以进行配置。</p><h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><p>大型项目微服务很多，多个微服务之间可能存在依赖冲突，但每个微服务都单独部署在一个服务器不太实际，Docker 可以解决微服务间的依赖兼容性问题。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="Docker-实现机制"><a href="#Docker-实现机制" class="headerlink" title="Docker 实现机制"></a>Docker 实现机制</h4><p>docker 容器的运行由 docker 引擎管理（docker 引擎由一系列负责各个功能的进程组成），根据 docker 官方推荐，大多数情况下我们只会在一个 docker 容器中运行一个进程，这个进程本质就是外部宿主机上 linux 内核的一个进程，可以直接在宿主机上查到。</p><p>docker 的关键是 linux 内核提供的隔离技术，多个 Docker 容器间通过 Namespace 技术进行进程隔离，通过 Cgroups 技术进行进程资源限制。这也是我们进入 Docker 容器内部感觉像是一个完整操作系统的原因。</p><p>docker 镜像打包的其实是文件系统中的文件、要运行的程序等等。</p><p>docker 镜像是分层的，这使得多个 Docker 镜像间可以共享相同层。</p><h4 id="Docker-与虚拟化技术对比"><a href="#Docker-与虚拟化技术对比" class="headerlink" title="Docker 与虚拟化技术对比"></a>Docker 与虚拟化技术对比</h4><p>docker 的实现与虚拟化没有关系，本质就是进程隔离，因此硬盘占用低、启动速度快。</p><p>Vmware 这种虚拟化技术，是在宿主操作系统的基础上，用软件虚拟出一套计算机硬件（这个中间层称为 Hypervisor），再基于虚拟出来的这套硬件安装任何想要的操作系统。因此应用运行在虚拟机上时，想要操作底层真实硬件需要依次通过虚拟机操作系统、Hypervisor、宿主机操作系统、底层真实硬件。因此硬盘占用大、启动慢、性能差。</p><h4 id="Docker-关键点"><a href="#Docker-关键点" class="headerlink" title="Docker 关键点"></a>Docker 关键点</h4><ul><li>文件挂载：支持目录挂载、文件挂载。一方面方便修改配置文件，一方面容器删除后数据保留（如 mysql）。</li><li>构建镜像：<ul><li>把当前容器构建为镜像</li><li>Dockerfile 构建镜像</li></ul></li><li>DockerCompose：DockerCompose 脚本可以自动化构建镜像、运行容器。DockerCompose 可以实现微服务的自动部署。</li><li>网络通信：<ul><li>Docker 容器和外部网络通信需要在运行 Docker 容器的时候映射端口</li><li>Docker 容器与 Docker 容器之间的网络通信时，IP 写 Docker 容器名字即可，Docker 底层做好了实现。</li></ul></li><li>镜像仓库：可以搭建公司私有仓库。</li></ul><h2 id="消息队列-MQ"><a href="#消息队列-MQ" class="headerlink" title="消息队列 MQ"></a>消息队列 MQ</h2><p>业务异步级联可以提高吞吐量、降低业务耦合、流量削峰填谷。缺点是架构变复杂了，需要引入 MQ 消息队列。</p><p>常见的 MQ 技术包含：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="五种消息模型"><a href="#五种消息模型" class="headerlink" title="五种消息模型"></a>五种消息模型</h4><ul><li>只有队列<ul><li>基本消息队列：RabbitMQ 中只有一个队列，生产者往队列中直接放消息，消费者从队列中不断地取消息（直到达到设置的预取上限或者队列为空），消费者在异步线程中消费消息。RabbitMQ 保证了同一个队列放操作和取操作的原子性。</li><li>工作消息队列：和基本消息队列的区别就是消费者变成了两个，整个过程基本不变。当我们把预取设为 1 的时候（也就是取一条消息，消费一条消息），那么两个消费者取消息的速率和它们消费消息的速率成正比。预取上限需要在 yml 中配置 prefetch。</li></ul></li><li>交换机+队列<br>交换机的作用是当有多个队列时，对于每个消息，决定将消息放到哪些队列中。从每个队列自己的角度出发，仍然只存在生产者放消息和消费者取消息的过程，和之前一样。<ul><li>广播交换机（Fanout）：消息放入绑定的所有队列</li><li>直连交换机（Direct）：根据绑定的 key 决定放入哪些队列</li><li>主题交换机（Topic）：根据主题匹配决定放入哪些队列</li></ul></li></ul><h4 id="五大操作"><a href="#五大操作" class="headerlink" title="五大操作"></a>五大操作</h4><p>主要有五大操作：创建交换机、创建队列、绑定交换机和队列、生产消息、消费消息</p><p>实现主要包括官方 maven 依赖原生实现、SpringAMQP 封装实现。AMQP 协议是一种基于 tcp 的专门用于应用程序间传递业务消息的标准（跨语言）。SpringAMQP 是 AMQP 协议在 Spring 框架中的实现，提供了 SpringBoot 自动装配。</p><p>最后需要注意 AMQP 传输的是数据字节，如果要发送 java 对象的话则需要序列化。SpringAMQP 的默认序列化方式是 jdk 序列化，jdk 序列化效率比较低，可以换成 Json 序列化，Json 序列化先将 java 对象转换为字符串，然后把字符串编码发送，接受后先解码成字符串再反序列化成对象即可。</p><h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>消息本身和队列都可以设置过期时间，达到两者的最小值时消息就会过期。</p><p>可以为队列设置死信交换机，这样队列中出现的所有死信不会被丢弃而是转到死信交换机进行重新路由，消息变成死信有三种情况：</p><ul><li>消息过期</li><li>队列达到最大长度，队头消息会变成死信</li><li>开启了手动确认，但消费者拒绝消息或收到消息后不确认，此消息就会变成死信</li></ul><p>我们可以创建一个交换机，绑定一个队列，再为这个队列设置一个死信交换机，再为死信交换机绑定一个死信队列。</p><h4 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h4><p>如果需要消息在延迟定长时间后被消费，可以通过死信队列来实现，设置队列的消息过期时间，然后再转到死信交换机，路由到死信队列，然后消费者消费死信队列即可。</p><h4 id="Confirm-模式和-Return-模式"><a href="#Confirm-模式和-Return-模式" class="headerlink" title="Confirm 模式和 Return 模式"></a>Confirm 模式和 Return 模式</h4><p>生产者和消费者的消息确认功能，用来保证可靠性，保证消息不丢失（AMQP 基于 tcp，所以感觉确认功能没什么用）。</p><h4 id="备用交换机"><a href="#备用交换机" class="headerlink" title="备用交换机"></a>备用交换机</h4><p>当消息经过交换器准备路由给队列的时候，发现没有对应的队列可以投递信息，在 rabbitmq 中会默认丢弃消息，如果我们想要监测一个交换机有哪些消息没有对应的队列，可以为这个交换机绑定一个备用交换机，然后设置消费者接收备用交换机的消息，记录到日志或发送报警信息。</p><h4 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h4><p>消息幂等性是指对同一条消息的多次执行操作的结果与一次执行的结果相同。在分布式系统中，由于网络的不确定性，可能会导致消息被重复发送或者消息的顺序发生变化。为了确保系统的一致性，消息的处理需要具备幂等性。</p><p>保证消息幂等性也就是保证消息不被重复消费，可以通过为每个消息设置全局唯一 ID 结合 redis 实现。</p><h2 id="索引库-Elasticsearch"><a href="#索引库-Elasticsearch" class="headerlink" title="索引库 Elasticsearch"></a>索引库 Elasticsearch</h2><p>Elasticsearch 索引库和 mysql 等关系型数据库的存储模式类似，都是存储数据条目，也存在表、字段、增删改查等概念，但是在底层存储方式上有很大区别。相比而言，mysql 的优势在于擅长事务类型操作，可以确保数据的安全和一致性，而 Elasticsearch 的优势在于擅长海量数据的高效搜索。</p><p>Elasticsearch 底层是基于 lucene 来实现的。Lucene 是 Apache 公司开发的一个 Java 语言的搜索引擎类库</p><p>浏览器搜索、电商搜索、网站内部搜索等都是由 Elasticsearch 完成的。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引的概念是基于 MySQL 这样的正向索引而言的。在 mysql 数据库中，如果表中某个字段没有建立索引，那么按照字段值查找条目的操作需要扫描整张表，如果字段建立了索引，那么按照字段值查找条目的操作就非常快，但是如果是按照字段值模糊匹配来查找条目的话，仍然是需要全表扫描的。</p><p>倒排索引可以解决这个问题。创建倒排索引的过程是对每一个条目的数据利用算法进行分词，然后建立分词到条目的映射。倒排索引建立完成后，每个分词都映射了所有包含这个分词的条目，当查询某句话时，首先对这句话进行分词，然后取所有分词对应条目集合的并集。因此我们可以以 O(1)的时间复杂度直接获取到所有和这句话有关的条目。</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li>无法根据字段做排序</li></ul></li></ul><h3 id="Elasticsearch-和-Mysql"><a href="#Elasticsearch-和-Mysql" class="headerlink" title="Elasticsearch 和 Mysql"></a>Elasticsearch 和 Mysql</h3><p>Elasticsearch 中的条目是以 Json 格式存储的。</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是 JSON 格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是 JSON 文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL 是 elasticsearch 提供的 JSON 风格的请求语句，用来操作 elasticsearch，实现 CRUD</td></tr></tbody></table><p>在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用 mysql 实现</li><li>对查询性能要求较高的搜索需求，使用 elasticsearch 实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h3 id="安装-Elasticsearch、kibana-和-ik-分词器"><a href="#安装-Elasticsearch、kibana-和-ik-分词器" class="headerlink" title="安装 Elasticsearch、kibana 和 ik 分词器"></a>安装 Elasticsearch、kibana 和 ik 分词器</h3><p>Elasticsearch、kibana 用 docker 部署即可，ik 分词器良好支持中文，有两种模式：</p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><p>ik 分词器支持拓展词条和停用词条，分词器分词是依照字典来完成的，那么一些字典中没有的词语（比如最新的网络用语），就需要拓展词条，一些敏感词语则需要停用词条。</p><h3 id="Elasticsearch-常见操作"><a href="#Elasticsearch-常见操作" class="headerlink" title="Elasticsearch 常见操作"></a>Elasticsearch 常见操作</h3><p>mapping 是对索引库中文档的约束，常见的 mapping 属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip 地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为 true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h4 id="索引库-CRUD"><a href="#索引库-CRUD" class="headerlink" title="索引库 CRUD"></a>索引库 CRUD</h4><ul><li>创建索引库：创建时需要想好以下几点<ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索（或者说是否创建这个字段的倒排索引），需要根据业务来判断</li><li>是否需要分词，内容如果是一个整体就无需分词，反之则要分词</li><li>如果分词，分词器是什么？可以统一使用 ik_max_word</li></ul></li><li>查询索引库</li><li>修改索引库：修改索引库只允许新增字段到 mapping 中，不允许修改原有字段（因为会对已经建立好的倒排索引产生影响）</li><li>删除索引库</li></ul><h4 id="文档-CRUD"><a href="#文档-CRUD" class="headerlink" title="文档 CRUD"></a>文档 CRUD</h4><ul><li>新增文档</li><li><strong>查询文档</strong>：后面详述</li><li>删除文档</li><li>修改文档：全量修改&#x2F;增量修改</li></ul><h4 id="ES-客户端"><a href="#ES-客户端" class="headerlink" title="ES 客户端"></a>ES 客户端</h4><p>ES 官方提供了各种不同语言的客户端，用来操作 ES。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ES。</p><p>我们可以用 Java HighLevel Rest Client 客户端 API 来操作 ES，导入相关 maven 依赖后即可使用。RestClient 进行索引库 CRUD 和文档 CRUD 的具体方式可以查询笔记。</p><h3 id="Elasticsearch-查询文档"><a href="#Elasticsearch-查询文档" class="headerlink" title="Elasticsearch 查询文档"></a>Elasticsearch 查询文档</h3><p>查询文档的 DSL 是一个大的 JSON 对象，包含下列属性：</p><ul><li>query：查询条件</li><li>sort：排序条件</li><li>from 和 size：分页条件</li><li>highlight：高亮条件</li></ul><p>RestClient 查询文档的 api 接口类似于查询文档的 DSL，具体可查笔记。</p><h4 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h4><ul><li><p><strong>查询所有</strong>：查询出所有数据，match_all</p></li><li><p><strong>全文检索查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。</p><ul><li>match_query：单字段</li><li>multi_match_query：多字段</li></ul></li><li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。</p><ul><li>range：查找数值或日期的范围</li><li>term：精准匹配 keyword、数值、日期和 boolean</li></ul></li><li><p><strong>地理（geo）查询</strong>：根据经纬度查询。</p><ul><li>geo_distance：查半径范围内</li><li>geo_bounding_box：查矩形范围内</li></ul></li><li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。</p><ul><li>bool：条件复合</li><li>function_score：如果我们没有制定排序顺序的话，ES 会对满足条件的所有文档按照相关度函数进行算分，打分高的文档排在前面。function_score 可以调整一些特定文档的算分，比如提高广告文档的排名。</li></ul></li></ul><h4 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h4><p>elasticsearch 默认是根据相关度算分排序，但也可以自己指定排序。</p><h4 id="结果分页"><a href="#结果分页" class="headerlink" title="结果分页"></a>结果分页</h4><p>elasticsearch 默认情况下只返回 top10 的数据，修改 from、size 参数可以控制要返回的分页，类似于 mysql 中的 limit。</p><h4 id="关键字高亮"><a href="#关键字高亮" class="headerlink" title="关键字高亮"></a>关键字高亮</h4><p>对于查询结果中所有匹配的关键字进行高亮显示，实现方式是给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签。前端可以给<code>&lt;em&gt;</code>标签编写 CSS 样式来高亮。</p><h3 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h3><p>elasticsearch 的数据聚合和 mysql 的数据聚合功能类似，但是速度更快。</p><p>聚合常见的有三类：</p><ul><li><p><strong>桶（Bucket）</strong>聚合：用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p><strong>度量（Metric）</strong>聚合：用以计算一些值</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求 max、min、avg、sum 等</li></ul></li></ul><p>默认情况下，Bucket 聚合是对索引库的所有文档做聚合，但真实情况下往往是对搜索结果进行聚合。</p><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>当我们在搜索框中输入一些文字时，会显示一些自动补全文字。</p><p>elasticsearch 提供了 Completion Suggester 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li>参与补全查询的字段必须是 completion 类型。</li><li>字段的内容一般是用来补全的多个词条形成的数组。</li></ul><p>如果希望能根据字母提示中文汉字的话，需要安装拼音分词器，然后自定义分词器，先用 ik 分词器进行分词，对于每个分出来的词语，在用拼音分词器进行分词。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>当 mysql 数据库发生增删改时，elasticsearch 也必须跟着进行增删改。</p><p>常见的数据同步方案有三种：</p><ul><li>同步调用：微服务 A 增删改 mysql 之后，马上调用微服务 B 的接口对 elasticsearch 进行相应的增删改。</li><li>异步通知：微服务 A 增删改 mysql 之后，发送一个 MQ 消息，微服务 B 持续消费消息对 elasticsearch 进行相应的增删改。</li><li>监听 binlog：mysql 开启 binlog 功能，canal 监听 binlog 变化，实时更新 elasticsearch 中的内容。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 wsl 配置为局域网服务器</title>
    <link href="/notes/2023/11/21/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E5%B0%86%20wsl%20%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/notes/2023/11/21/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E5%B0%86%20wsl%20%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="将-wsl-配置为局域网服务器"><a href="#将-wsl-配置为局域网服务器" class="headerlink" title="将 wsl 配置为局域网服务器"></a>将 wsl 配置为局域网服务器</h1><h2 id="校园网内的另一台设备访问-wsl"><a href="#校园网内的另一台设备访问-wsl" class="headerlink" title="校园网内的另一台设备访问 wsl"></a>校园网内的另一台设备访问 wsl</h2><p>wsl 和 win 同为运行在 hyper-v 上的虚拟机，win 直接连接实际网卡，连接学校校园网。</p><p>wsl 默认采用 NAT 模式，这意味着 wsl 和 win 上都有一块虚拟网卡，配合虚拟的路由器和交换机，再次组成一个内网。由于 win 和 wsl 都有着虚拟网卡，因此他们都有着相应的内网 ip，同时虚拟的路由器（网关）也有着一个网关 ip（路由器内网端口的内网 ip），虚拟路由器的外网端口连接着实际网卡，其 ip 等于 win 的校园网 ip。</p><p>wsl 和 win 是可以相互 ping 通的（因为在同一个局域网内），但是校园网内的另一台设备（比如 mac），由于 NAT 的限制是无法主动访问 wsl 的，但是 wsl 可以主动访问 mac。</p><p>有两种方法可以解决这个问题，第一种方法是更改 wsl 为桥接模式，桥接模式可以使得 wsl 直接连接物理网卡并拥有校园网内网 ip，另一种方法是设置 win 的端口转发，将 wsl 的一些需要用到的端口暴露出来。</p><p>什么是端口转发呢？我们知道在 NAT 中，内网某台机器的 TCP 报文段到达 NAT 网关（路由器）之后，其目标 IP 和目标端口不变，源 IP 换成路由器外网端口的 IP，源端口换成 NAT 分配的一个随机端口，同时 NAT 会记录这个更换的映射。在 NAT 网关收到返回的 TCP 报文段时，会根据之前的映射关系，将目标 IP 换成内网相应机器的内网 IP，端口换成记录的内网机器相应端口，然后通过局域网转发给内网机器。这也就是为什么内网机器可以主动访问外网机器，而外网机器不能主动访问内网机器（因为到达 NAT 后没有相应的 NAT 映射记录）。而端口转发就是自己创建一条 NAT 映射记录，核心在于 NAT 网关某个端口映射内网的某个 IP 和端口。</p><p>win 中 NAT 映射（端口转发）可以通过以下命令完成：</p><ul><li><p>增加转发规则，以 80 端口为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface portproxy add v4tov4 listenport=80 listenaddress=0.0.0.0 connectport=80 connectaddress=wsl虚拟网卡ip<br></code></pre></td></tr></table></figure></li><li><p>查看所有已转发的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface portproxy show all<br></code></pre></td></tr></table></figure></li><li><p>重置转发规则（删除所有规则）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface portproxy reset<br></code></pre></td></tr></table></figure></li></ul><p>我们可以通过上述命令开放一些端口（比如 ssh 的 22，mysql 的 3306，redis 的 6379）</p><p>下面是常用服务的端口开放：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ssh</span><br>netsh interface portproxy add v4tov4 listenport=22 listenaddress=0.0.0.0 connectport=22 connectaddress=172.20.5.187<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mysql</span><br>netsh interface portproxy add v4tov4 listenport=3306 listenaddress=0.0.0.0 connectport=3306 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">redis</span><br>netsh interface portproxy add v4tov4 listenport=6379 listenaddress=0.0.0.0 connectport=6379 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nacos</span><br>netsh interface portproxy add v4tov4 listenport=8848 listenaddress=0.0.0.0 connectport=8848 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rabbitmq web管理</span><br>netsh interface portproxy add v4tov4 listenport=15672 listenaddress=0.0.0.0 connectport=15672 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rabbitmq 消息通信</span><br>netsh interface portproxy add v4tov4 listenport=5672 listenaddress=0.0.0.0 connectport=5672 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">es外部通信</span><br>netsh interface portproxy add v4tov4 listenport=9200 listenaddress=0.0.0.0 connectport=9200 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">es集群通信</span><br>netsh interface portproxy add v4tov4 listenport=9300 listenaddress=0.0.0.0 connectport=9300 connectaddress=172.26.17.30<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Kibana-es可视化工具</span><br>netsh interface portproxy add v4tov4 listenport=5601 listenaddress=0.0.0.0 connectport=5601 connectaddress=172.26.17.30<br></code></pre></td></tr></table></figure><h2 id="配置-ssh"><a href="#配置-ssh" class="headerlink" title="配置 ssh"></a>配置 ssh</h2><p>查看服务器是否安装了 ssh-server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef|grep sshd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">root      2859     1  020:29 ?        00:00:00 /usr/sbin/sshd -D</span><br></code></pre></td></tr></table></figure><p>如果没有，安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install openssh-server<br></code></pre></td></tr></table></figure><p>允许密码登录，允许 root 登录，重启 ssh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim /etc/ssh/sshd_config</span><br><br>PasswordAuthentication yes<br>PermitRootLogin yes<br>service sshd restart<br></code></pre></td></tr></table></figure><p>为服务器 root 用户设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo passwd root<br></code></pre></td></tr></table></figure><p>win 配置端口转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface portproxy add v4tov4 listenport=22 listenaddress=0.0.0.0 connectport=22 connectaddress=wsl虚拟网卡ip<br></code></pre></td></tr></table></figure><p>接下来就可以直接用密码登录服务器 root 用户了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">win</span><br>ssh root@wsl内网ip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">mac</span><br>ssh root@win校园网ip<br></code></pre></td></tr></table></figure><h2 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h2><p>安装 mysql 有两种方式，一种是通过 apt 软件管理器，另一种是手动，我们通过 apt 安装 mysql 8.0</p><p>首先需要更换 apt 镜像源，默认镜像源是国外的很慢，当然也可以设置 apt 代理解决。</p><p>使用阿里云镜像源：<a href="https://developer.aliyun.com/mirror/ubuntu">https://developer.aliyun.com/mirror/ubuntu</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/apt/sources.list # 删掉所有内容，然后粘贴镜像源<br>apt update # 更新一下<br></code></pre></td></tr></table></figure><p>安装 mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install mysql-server<br></code></pre></td></tr></table></figure><p>查看 mysql 状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql status<br></code></pre></td></tr></table></figure><p>启动 mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start<br></code></pre></td></tr></table></figure><p>此时 wsl 已经可以连接 mysql 了，但是 win 还无法连接</p><p>修改账号权限为%</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">use mysql;<br>select host, user, authentication_string, plugin from user;<br>update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;<br>GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>修改 mysql 配置文件 my.cnf 允许外部 ip 访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/mysql/my.cnf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加如下</span><br>[mysqld]<br>bind-address = 服务器本地ip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启mysql服务</span><br>service mysql restart<br></code></pre></td></tr></table></figure><p>为 root 用户设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新一下</span><br>flush privileges;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置密码</span><br>ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure><p>SHA2 认证改为密码认证（mysql 8.0 默认 SHA2 认证 5.7 默认密码认证）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">update user set plugin=&#x27;mysql_native_password&#x27; where user=&#x27;root&#x27;;<br></code></pre></td></tr></table></figure><p>修改操作系统防火墙和云服务器安全组，放行 3306 端口</p><p>现在 win 可以连接 mysql 了，但是校园网内其他机器还不可以</p><p>win 配置端口转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface portproxy add v4tov4 listenport=3306 listenaddress=0.0.0.0 connectport=3306 connectaddress=wsl虚拟网卡ip<br></code></pre></td></tr></table></figure><p>现在校园网内其他机器也可以连接了</p><h2 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h2><p>apt 安装 redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install redis-server<br></code></pre></td></tr></table></figure><p>修改 redis 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/redis/redis.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注释掉下面这一行，开放远程访问</span><br>bind 127.0.0.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解开下面一行注释，设置redis密码</span><br>requirepass yourpassword<br></code></pre></td></tr></table></figure><p>重启 redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/init.d/redis-server restart<br></code></pre></td></tr></table></figure><p>win 配置端口转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface portproxy add v4tov4 listenport=6379 listenaddress=0.0.0.0 connectport=6379 connectaddress=wsl虚拟网卡ip<br></code></pre></td></tr></table></figure><p>share (file:&#x2F;&#x2F;DESKTOP-QVOGF9U&#x2F;share)</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理</title>
    <link href="/notes/2023/11/20/%E5%85%AB%E8%82%A1%E7%AF%87%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/notes/2023/11/20/%E5%85%AB%E8%82%A1%E7%AF%87%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>Apple 类实现了 Fruit 接口，我们对 Apple 类进行代理。无论是静态代理还是动态代理，代理的本质都是我们不需要修改被代理类源码、不需要重新编译被代理类，而只需要修改代理类源码即可完成被代理类功能的修改与增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat apple&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理需要自己编写代理类代码，经过编译生成代理类字节码。缺点是每当我们想要去代理某个类的时候都要手动创建一个代理类，还有就是当被代理的接口和类修改的时候，代理类的代码也需要手动修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br>        fruit.eat();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">private</span> Apple apple;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(Apple apple)</span> &#123;<br>        <span class="hljs-built_in">this</span>.apple = apple;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        before();<br>        apple.eat();<br>        after();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat before&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat after&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jdk-动态代理"><a href="#jdk-动态代理" class="headerlink" title="jdk 动态代理"></a>jdk 动态代理</h2><p>只能代理实现了某个接口的类，是在内存中动态生成字节码并进行类加载的，涉及反射调用因此生成类较快、方法调用较慢。</p><p>原理是底层会定义一个类，也实现这个接口，类中静态属性包含这个接口所有的 method 对象，每个实现方法都回调 InvocationHandler 的 invoke 方法，方法中有被代理对象、method 对象、args 参数的情况下进行反射调用并自由地进行方法增强。</p><p>Proxy.newProxyInstance 的前两个参数指定了生成哪个接口的代理类，第三个参数决定了是对哪个接口对象进行代理以及每个接口方法分别进行怎样的增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FruitHandler</span> <span class="hljs-variable">fruitHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FruitHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> (Fruit) Proxy.newProxyInstance(Fruit.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Fruit.class&#125;, fruitHandler);<br>        fruit.eat();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FruitHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        before();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(<span class="hljs-built_in">this</span>.target, args);<br>        after();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat before&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat after&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在虚拟机参数中加入<code>-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true</code>，可以保存生成的代理类字节码文件，反编译可以看到如下结果。从中可以清晰的看到利用反射实现代理的过程，也可以看出是每一个接口对应生成一个代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="hljs-comment">// (powered by FernFlower decompiler)</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">import</span> java.lang.invoke.MethodHandles;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m0;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Method m3;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) &#123;<br>        <span class="hljs-built_in">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m0, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object var1)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m2, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, (Object[])<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>            m3 = Class.forName(<span class="hljs-string">&quot;Fruit&quot;</span>).getMethod(<span class="hljs-string">&quot;eat&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodError</span>(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoClassDefFoundError</span>(var3.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodHandles.Lookup <span class="hljs-title function_">proxyClassLookup</span><span class="hljs-params">(MethodHandles.Lookup var0)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        <span class="hljs-keyword">if</span> (var0.lookupClass() == Proxy.class &amp;&amp; var0.hasFullPrivilegeAccess()) &#123;<br>            <span class="hljs-keyword">return</span> MethodHandles.lookup();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalAccessException</span>(var0.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h2><p>CGLib 基于 ASM 框架提供的字节码增强技术，可以直接实现类的增强，也是在内存中动态生成字节码并进行类加载的，不经过反射因此类生成慢但方法调用快。</p><p>原理是底层会定义一个被代理类的子类，然后按照 MethodInterceptor 中 intercept 方法中写的方式对每个方法进行直接的字节码增强。</p><p>首先引入 maven 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setClassLoader(Apple.class.getClassLoader());<br>        enhancer.setSuperclass(Apple.class);<br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleMethodIntercepter</span>());<br>        <span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> (Apple) enhancer.create();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> apple.eat(<span class="hljs-string">&quot;water&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;result is &quot;</span> + result);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleMethodIntercepter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            before();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, args);<br>            after();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat &quot;</span> + food);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;eat &quot;</span> + food;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6844904098580398088">https://juejin.cn/post/6844904098580398088</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java通配符详解</title>
    <link href="/notes/2023/11/19/%E5%85%AB%E8%82%A1%E7%AF%87%20Java%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%A6%E8%A7%A3%20/"/>
    <url>/notes/2023/11/19/%E5%85%AB%E8%82%A1%E7%AF%87%20Java%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%A6%E8%A7%A3%20/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-通配符详解"><a href="#Java-通配符详解" class="headerlink" title="Java 通配符详解"></a>Java 通配符详解</h1><h2 id="类或接口范型通配符"><a href="#类或接口范型通配符" class="headerlink" title="类或接口范型通配符"></a>类或接口范型通配符</h2><p>类或接口范型可以应用到属性、方法形参、方法局部变量、方法返回类型</p><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>类或接口范型类型可以是任意类型，不指定类型默认 Object 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">localVar</span> <span class="hljs-operator">=</span> t;<br>        <span class="hljs-built_in">this</span>.t = localVar;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>类范型类型只允许是 B 类及其子类，不指定类型默认 B 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">localVar</span> <span class="hljs-operator">=</span> t;<br>        <span class="hljs-built_in">this</span>.t = localVar;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法范型通配符"><a href="#方法范型通配符" class="headerlink" title="方法范型通配符"></a>方法范型通配符</h2><p>方法范型可以由形参类型或形参对象范型确定，可以应用到方法局部变量、方法返回类型</p><h3 id="第一种情况-1"><a href="#第一种情况-1" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>方法范型可以是任意类型，由形参确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> t;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二种情况-1"><a href="#第二种情况-1" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>方法范型只能是 B 类型及其子类型，由形参确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> t;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h3><p>方法范型可以是任意类型，由形参范型确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">test</span><span class="hljs-params">(List&lt;T&gt; t)</span> &#123;<br>        List&lt;T&gt; tmp = t;<br>        <span class="hljs-keyword">return</span> tmp.get(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四种情况"><a href="#第四种情况" class="headerlink" title="第四种情况"></a>第四种情况</h3><p>方法范型只能是 B 类型及其子类型，由形参范型确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; T <span class="hljs-title function_">test</span><span class="hljs-params">(List&lt;T&gt; t)</span> &#123;<br>        List&lt;T&gt; tmp = t;<br>        <span class="hljs-keyword">return</span> tmp.get(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用范型通配符"><a href="#引用范型通配符" class="headerlink" title="引用范型通配符"></a>引用范型通配符</h2><p>引用范型通配符指的是在引用处指定范型范围，所谓引用处可以是属性、静态属性、局部变量、方法形参，下面以局部变量为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Some</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">public</span> T t;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> t;<br>            <span class="hljs-built_in">this</span>.t = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第一种情况-2"><a href="#第一种情况-2" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>这种情况引用直接确定了范型类型，其中<code>Some some3 = new Some()</code>默认是 Object 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Some&lt;B&gt; some1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;&gt;();<br>Some&lt;Object&gt; some2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;&gt;();<br><span class="hljs-type">Some</span> <span class="hljs-variable">some3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>();<br></code></pre></td></tr></table></figure><h3 id="第二种情况-2"><a href="#第二种情况-2" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>这种情况引用允许任意类型，这里我们传入 B 范型的 Some 对象，set 方法失效，get 方法返回 Object</p><p>原理：&lt;?&gt;代表某种确定类型，但是不知道具体是什么类型。因此，set 方法没有办法传入任何对象，而 get 方法只能返回 Object 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Some&lt;?&gt; some4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;B&gt;();<br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> some4.get();<br></code></pre></td></tr></table></figure><h3 id="第三种情况-1"><a href="#第三种情况-1" class="headerlink" title="第三种情况"></a>第三种情况</h3><p>这种情况引用允许 B 类型及其子类型，这里我们传入 B 范型的 Some 对象和 C 范型的 Some 对象，set 方法失效，get 方法返回 B 类型</p><p>原理：&lt;? extends B&gt;代表某种确定类型，我们只知道这种类型是 B 类型及其子类型，但是不知道具体是什么类型。因此，set 方法没有办法传入任何对象，而由于我们能够确定 get 方法返回的一定是 B 类型及其子类型，所以可以确定为 B（可能存在向上转型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Some&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; some5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;B&gt;();<br>Some&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&gt; some6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;C&gt;();<br><span class="hljs-type">B</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> some5.get();<br><span class="hljs-type">B</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> some6.get();<br></code></pre></td></tr></table></figure><h3 id="第四种情况-1"><a href="#第四种情况-1" class="headerlink" title="第四种情况"></a>第四种情况</h3><p>这种情况引用允许 B 类型及其父类型，这里我们传入 B 范型的 Some 对象和 A 范型的 Some 对象，set 方法可以传入 B 类型及其子类型，get 方法返回 Object</p><p>原理：&lt;? super B&gt;代表某种确定类型，我们只知道这种类型是 B 类型及其父类型，但是不知道具体是什么类型。因此，set 方法可以传入 B 类型及其子类型（可能存在向上转型），而 get 方法只能返回 Object 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Some&lt;? <span class="hljs-built_in">super</span> B&gt; some7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;B&gt;();<br>Some&lt;? <span class="hljs-built_in">super</span> B&gt; some8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Some</span>&lt;A&gt;();<br>some7.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>());<br>some7.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>());<br>some8.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>());<br>some8.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>());<br><span class="hljs-type">Object</span> <span class="hljs-variable">object1</span> <span class="hljs-operator">=</span> some7.get();<br><span class="hljs-type">Object</span> <span class="hljs-variable">object2</span> <span class="hljs-operator">=</span> some8.get();<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000005337789">https://segmentfault.com/a/1190000005337789</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞非阻塞、同步异步与多路复用</title>
    <link href="/notes/2023/11/17/%E5%85%AB%E8%82%A1%E7%AF%87%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/notes/2023/11/17/%E5%85%AB%E8%82%A1%E7%AF%87%20%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="阻塞非阻塞、同步异步与多路复用"><a href="#阻塞非阻塞、同步异步与多路复用" class="headerlink" title="阻塞非阻塞、同步异步与多路复用"></a>阻塞非阻塞、同步异步与多路复用</h1><p>下面将统一以网络 IO 经典函数 accept 和 read 进行阐述。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><h3 id="阻塞-read"><a href="#阻塞-read" class="headerlink" title="阻塞 read"></a>阻塞 read</h3><p>系统调用陷入内核态，操作系统服务函数查看内核缓冲区中是否有数据，如果有数据则返回（这里分两种情况，如果内核缓冲区当前数据长度多于传进来的 buffer，则填满 buffer 返回，如果内核缓冲区数据长度不足 buffer，则会把缓冲区中所有数据都填入 buffer 中返回），如果没有数据，则操作系统服务进程阻塞，当网卡中收到数据时会将数据同步到操作系统内存（网络缓冲区）中，同时唤醒操作系统服务进程，操作系统服务进程将数据从内核内存复制到用户内存然后返回用户态。</p><h3 id="非阻塞-read"><a href="#非阻塞-read" class="headerlink" title="非阻塞 read"></a>非阻塞 read</h3><p>和阻塞 read 的唯一区别在于，当系统调用发现内核缓冲区没有数据时会立刻返回用户态继续执行。</p><h3 id="阻塞-accept"><a href="#阻塞-accept" class="headerlink" title="阻塞 accept"></a>阻塞 accept</h3><p>同阻塞 read 类似，系统调用后查看全连接队列中是否有已经建立的 tcp 连接，如果有则返回用户态相应的 socket，如果没有则操作系统服务进程阻塞并等待连接的到来。</p><p>需要说明的是，linux 内核中有两个队列，半连接队列用来存放目前刚进行一次握手（只收到客户端 SYN）的“刚进行一半的连接”，全连接队列用来存放目前已经进行了三次握手的“已经完成的连接”，其中任何连接都是先进入半连接队列再进入全连接队列的。每次 accept 其实就是查看全连接队列，并从中取出一个已经三次握手完成的连接。也就是说，所有 accept 接收的连接其实已经进行过三次握手了。全连接队列满的时候客户端再来连接就会连接失败，全连接队列的最大长度（backlog 参数）可以通过 linux 操作系统中的相关配置文件进行设定。</p><h3 id="非阻塞-accept"><a href="#非阻塞-accept" class="headerlink" title="非阻塞 accept"></a>非阻塞 accept</h3><p>和阻塞 accept 的唯一区别在于，当系统调用后查看全连接队列中没有已经建立的 tcp 连接时会立刻返回用户态继续执行。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步关注两个过程在时间上具有严格的先后顺序，同步并不关心有几个进程&#x2F;线程，比如说 A 操作要在 B 操作开始之前完成，无论是单线程先执行 A 操作再执行 B 操作，还是多线程中某个线程执行完 B 操作后给另一个线程发信号让其开始执行 A 操作，其实都是同步的。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步不关注两个过程在时间上的顺序，但是异步要求至少有两个进程&#x2F;线程并发执行。比如一个线程在某个时刻产生了一个任务，则这个任务被交由其他线程处理（处理时间可能很长&#x2F;很短，可能立即开始处理，也可能过一段时间才会开始处理），处理结束后把结果通过线程间通信的方式返回原线程。</p><h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p>以网络 IO 模型为例，以 accept 和 read 组成，面向并发连接。</p><h3 id="同步阻塞-IO"><a href="#同步阻塞-IO" class="headerlink" title="同步阻塞 IO"></a>同步阻塞 IO</h3><p>假如使用阻塞 IO，则单线程是一定不行的，因为多个不同的阻塞操作之间会互相影响。只能一个线程 accept，建立连接后开一个新的线程负责 read 这个连接。这种方式的缺点是无法应对高并发连接，因为我们不可能开特别多的线程，因为线程&#x2F;进程本身的建立&#x2F;销毁&#x2F;调度是消耗资源的。</p><p>单线程一定是同步的。</p><h3 id="同步非阻塞-IO"><a href="#同步非阻塞-IO" class="headerlink" title="同步非阻塞 IO"></a>同步非阻塞 IO</h3><p>如果使用非阻塞 IO，则单线程就可以处理高并发，在每一次循环中，先 accept 一下，然后对于维护的所有 socket，每个 socket 去 read 一下。这种方式的缺点是，假如一段时间不存在 tcp 连接建立请求，所有 tcp 连接也不发任何信息，因为不存在阻塞所以这时 cpu 会大量空转。</p><p>单线程一定是同步的。</p><h3 id="同步多路复用-IO"><a href="#同步多路复用-IO" class="headerlink" title="同步多路复用 IO"></a>同步多路复用 IO</h3><p>为了利用阻塞的优点并且避免多个阻塞操作相互影响，多路复用采用事件机制将所有的操作汇聚成了一个阻塞操作，即 select 操作。select 操作会阻塞的查看缓冲区中的所有事件（可以是 accept 事件，也可以是某个 socket 的 read 事件等等）。这样我们就可以在每一次循环中，先 select 函数返回所有的事件，再依次处理所有的事件（比如出现了某个 socket 的 read 事件，这时候就要调这个 socket 的 read 函数去读数据，显然此时无论是阻塞 read 还是非阻塞 read 都是能立刻读到数据的）。</p><p>单线程一定是同步的。</p><h3 id="异步非阻塞-IO"><a href="#异步非阻塞-IO" class="headerlink" title="异步非阻塞 IO"></a>异步非阻塞 IO</h3><p>举一个异步非阻塞 read 操作的例子，首先 read 系统调用陷入内核态，查看内核缓冲区发现没有数据，因为是非阻塞的所以要马上返回，但是可以在返回之前开启另一个异步线程，异步线程阻塞等待 IO 数据，并在拿到 IO 数据之后通过线程间通信的方式将数据发送给主线程。</p><p>注意异步阻塞 IO 是不存在的，原因是异步是开多线程的，此时就不需要阻塞等待了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序总结</title>
    <link href="/notes/2023/11/17/%E7%AE%97%E6%B3%95%E7%AF%87%20%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/17/%E7%AE%97%E6%B3%95%E7%AF%87%20%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>时间复杂度$O(n^2)$</li><li>空间复杂度$O(1)$</li><li>稳定</li></ul><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>以从小到大为例，每次把最大数放到后面。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                swap(nums, j, j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>时间复杂度$O(n^2)$</li><li>空间复杂度$O(1)$</li><li>不稳定</li></ul><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><p>以从小到大为例，遍历一遍，找到最大的数和最后一个数交换，再遍历一遍找到最大的数和倒数第二个数交换。</p><h3 id="模板代码-1"><a href="#模板代码-1" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[maxIndex]) &#123;<br>                maxIndex = j;<br>            &#125;<br>        &#125;<br>        swap(nums, maxIndex, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>时间复杂度$O(n^2)$</li><li>空间复杂度$O(1)$</li><li>稳定</li></ul><h3 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h3><p>以从小到大为例，假设前 k 个数已经排好序，对于第 k+1 个数，我们可以查看第 k+1 个数是否大于等于第 k 个数，如果成立则不需要变，如果不成立，我们把第 k 个数后移，再比较第 k+1 个数和第 k-1 个数，直到找到相应位置。</p><h3 id="模板代码-2"><a href="#模板代码-2" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; num) &#123;<br>            nums[j + <span class="hljs-number">1</span>] = nums[j];<br>            j--;<br>        &#125;<br>        nums[j + <span class="hljs-number">1</span>] = num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li>时间复杂度$O(nlogn)$</li><li>空间复杂度$O(logn)$</li><li>不稳定</li></ul><h3 id="算法原理-3"><a href="#算法原理-3" class="headerlink" title="算法原理"></a>算法原理</h3><p>partition 方法的作用是，在一定区间内选定一个数，调整这个区间使得所有比这个数小的数都在它的左边，所有比这个数大的数都在它的右边。关于这个数的选择一般有三种方式：</p><ul><li>选区间第一个数：简单直观，缺点是有可能带来最坏的情况</li><li>选区间随机一个数：不会带来最坏的情况，但是随机选取本身存在消耗</li><li>选区间最左边数、最右边数和中间数的中值：比较好的方式</li></ul><p>partition 方法如何进行调整呢？我们把中间值换到 left，从右边开始遍历（right–），直到找到第一个小于中间值的数，交换中间值和这个小于中间值的数，然后从左边开始遍历（left++），直到找到第一个大于中间值的数，交换中间值和这个大于中间值的数…直到 left&#x3D;&#x3D;right，此时中间值必然在 left 或 right 中，而中间值的左右都是小于&#x2F;大于它的数。</p><p>quickSort 方法的含义是，对 left 到 right 的区间进行排序，首先进行 partition，根据 partition 返回的中间值的位置，将区间切分成两份向下递归。partition 使得左边的数都小于等于中值，右边的数都大于等于中值，这时只要再满足左边有序且右边有序就可以保证整体区间有序了。</p><p>快排的空间复杂度是由递归带来的，快排的时间复杂度考虑的是平均的情况，快排的最坏时间复杂度是$O(n^2)$，最好时间复杂度也是$O(nlogn)$。</p><h3 id="模板代码-3"><a href="#模板代码-3" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>    quickSort(nums, left, partition - <span class="hljs-number">1</span>);<br>    quickSort(nums, partition + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right] &lt; nums[left]) &#123;<br>                swap(nums, left, right);<br>                state = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] &gt; nums[right]) &#123;<br>                swap(nums, left, right);<br>                state = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>时间复杂度$O(nlogn)$</li><li>空间复杂度$O(n)$</li><li>稳定</li></ul><h3 id="算法原理-4"><a href="#算法原理-4" class="headerlink" title="算法原理"></a>算法原理</h3><p>对于一个[left,right]区间，我们对它们排序等价于：将整个区间分成[left,(left+right)&#x2F;2]和[(left+right)&#x2F;2+1,right]两个区间，对两个区间分别排序，然后利用额外的数组空间，对两个已经排好序的数组进行合并，最后将合并好的数组写回原数组。递归的最小条件是$left&#x3D;&#x3D;right$，这时候相当于已经排好序了。</p><p>关于时间复杂度的分析，因为我们总是从中间切分区间，因此递归二叉树一共有$logn$层，而每层加起来有$O(n)$的操作，总体就是$O(nlogn)$的时间复杂度，空间复杂度是由于我们需要另一个数组用于合并操作。稳定是因为我们的判断条件是$if (nums[start1] &lt;&#x3D; nums[start2])$。</p><h3 id="模板代码-4"><a href="#模板代码-4" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    mergeSort(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length], <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] tmpNums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>    mergeSort(nums, tmpNums, left, mid);<br>    mergeSort(nums, tmpNums, mid + <span class="hljs-number">1</span>, right);<br>    merge(nums, tmpNums, left, mid, mid + <span class="hljs-number">1</span>, right);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] tmpNums, <span class="hljs-type">int</span> start1, <span class="hljs-type">int</span> end1, <span class="hljs-type">int</span> start2, <span class="hljs-type">int</span> end2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> start1;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;<br>        <span class="hljs-keyword">if</span> (nums[start1] &lt;= nums[start2]) &#123;<br>            tmpNums[index] = nums[start1];<br>            start1++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tmpNums[index] = nums[start2];<br>            start2++;<br>        &#125;<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (start1 &lt;= end1) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start1; i &lt;= end1; i++) &#123;<br>            tmpNums[index] = nums[i];<br>            index++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start2; i &lt;= end2; i++) &#123;<br>            tmpNums[index] = nums[i];<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start1; i &lt;= end2; i++) &#123;<br>        nums[i] = tmpNums[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>时间复杂度$O(nlogn)$</li><li>空间复杂度$O(1)$ 原地调整</li><li>不稳定</li></ul><h3 id="算法原理-5"><a href="#算法原理-5" class="headerlink" title="算法原理"></a>算法原理</h3><p>以大根堆为例，大根堆的定义为一个完全二叉树，其根节点大于等于左右子树所有节点，且左右子树均为大根堆。（注意，完全二叉树的左右子树一定是完全二叉树），堆排序的关键操作是 heapUp 和 heapDown。</p><p>heapUp 主要用于对于一个现有堆，我们在完全二叉树的末尾添加一个节点，然后自底向上进行调整的过程。对于添加节点的父节点，如果父节点大于等于添加节点，那么不用做任何事。如果父节点小于添加节点，两者交换，然后继续探查添加节点的父节点，直到父节点大于等于添加节点或添加节点被交换到根节点。</p><p>heapDown 主要用于当我们将一个堆的根节点替换为一个其他节点后，自顶向下进行调整的过程。如果根节点有两个子节点（如果根节点有一个子节点，则这个子节点就是更大者），取更大者与根节点相比较，如果更大者小于等于根节点，那么不用做任何事，反之交换根节点与更大者，重复这个过程直到根节点大于等于更大者或根节点延伸到了叶节点。</p><p>heapify 是建堆过程，我们首先初始化一个只有一个元素的堆，然后不断地将元素添加到完全二叉树的末尾并 heapUp 调整。</p><p>heapSort 排序过程我们采用原地调整的方式，交换堆顶的数和完全二叉树的最后一个数，然后 heapDown 调整（大根堆中少一个数，完全二叉树少一个数）。</p><ul><li>heapUp 操作的时间复杂度$O(logn)$</li><li>heapDown 操作的时间复杂度$O(logn)$</li><li>heapify 建堆的时间复杂度$O(nlogn)$</li><li>heapSort 排序的时间复杂度$O(nlogn)$</li></ul><h3 id="模板代码-5"><a href="#模板代码-5" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    heapify(nums);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        swap(nums, <span class="hljs-number">1</span>, i);<br>        heapDown(nums, i - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &lt;= nums[i]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            swap(nums, i - <span class="hljs-number">1</span>, i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        heapUp(nums, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapDown</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lastIndex)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= lastIndex) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(nums[index * <span class="hljs-number">2</span>], nums[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (nums[index] &gt;= max) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            swap(nums, index, nums[index * <span class="hljs-number">2</span>] &gt; nums[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] ? index * <span class="hljs-number">2</span> : index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>            index = (nums[index * <span class="hljs-number">2</span>] &gt; nums[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] ? index * <span class="hljs-number">2</span> : index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index * <span class="hljs-number">2</span> == lastIndex) &#123;<br>        <span class="hljs-keyword">if</span> (nums[index * <span class="hljs-number">2</span>] &gt; nums[index]) &#123;<br>            swap(nums, index, index * <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapUp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">while</span> (index / <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums[index / <span class="hljs-number">2</span>] &gt;= nums[index]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            swap(nums, index / <span class="hljs-number">2</span>, index);<br>            index /= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul><li>最好情况时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><p>适用于数据均匀分布的情况，即当我们切分多个区间时，每个区间的元素数目大致相等。</p><h3 id="算法原理-6"><a href="#算法原理-6" class="headerlink" title="算法原理"></a>算法原理</h3><p>桶排序将原数组划分到称为 「桶」 的多个区间中，然后对每个桶单独进行排序，之后再按桶序和桶内序输出结果。其中对于每个桶进行排序的排序算法可以自己选择。</p><p>找最大最小值和分配桶的过程耗费$O(n)$的时间复杂度和$O(n)$的空间复杂度，假设有 k 个桶，且数据分布均匀，若每个桶都采用$O(n^2)$的排序算法，那么总时间复杂度为$O(n^2&#x2F;k)$，若每个桶都采用$O(nlogn)$的排序算法，总时间复杂度为$O(k*(n&#x2F;k)_log(n&#x2F;k))$，即$O(n_log(n&#x2F;k))$，这时如果 $k&#x3D;n&#x2F;p$，p 是一个常数，那么理论上时间复杂度可以降到$O(n)$。</p><h3 id="模板代码-6"><a href="#模板代码-6" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] bucketSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length, k = n / <span class="hljs-number">3</span>, min = arr[<span class="hljs-number">0</span>], max = arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// k=n/3 个桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 确定 min 和 max</span><br>        min = Math.min(min, arr[i]);<br>        max = Math.max(max, arr[i]);<br>    &#125;<br>    List&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// k 个桶</span><br>        buckets.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()); <span class="hljs-comment">// 每个桶是一个ArrayList&lt;Integer&gt;</span><br>    &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> (max - min) * <span class="hljs-number">1.0</span> / (k - <span class="hljs-number">1</span>); <span class="hljs-comment">// 桶间隔</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123; <span class="hljs-comment">// 遍历arr，根据元素值将所有元素装入对应值区间的桶中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketIdx</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((num - min) / interval); <span class="hljs-comment">// arr[i] (num) 元素应该装入的桶的下标</span><br>        buckets.get(bucketIdx).add(num); <span class="hljs-comment">// 装入对应桶中</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;<br>        Collections.sort(bucket); <span class="hljs-comment">// 桶内排序(调用库函数，从小到大)</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sortedNum : bucket) &#123;<br>            arr[index] = sortedNum; <span class="hljs-comment">// 复用输入数组arr</span><br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/circle/discuss/eBo9UB/">https://leetcode.cn/circle/discuss/eBo9UB/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树总结</title>
    <link href="/notes/2023/11/17/%E7%AE%97%E6%B3%95%E7%AF%87%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93%20%20/"/>
    <url>/notes/2023/11/17/%E7%AE%97%E6%B3%95%E7%AF%87%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93%20%20/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树总结"><a href="#线段树总结" class="headerlink" title="线段树总结"></a>线段树总结</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>线段树是著名的用于高效求解 「区间问题」 的数据结构。只需要维护一个数组，可以以$O(logn)$的时间复杂度，完成数组单点查询、单点修改、区间求和、区间求最大值、区间求最小值的操作。</p><p>例题：力扣题目链接：<a href="https://leetcode.cn/problems/range-sum-query-mutable/">https://leetcode.cn/problems/range-sum-query-mutable/</a></p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们通过数组维护一个完全二叉树，每个节点保存了一个区间的和&#x2F;最大值&#x2F;最小值，数组长度一般粗略的设置为 4n，n 为元素个数。根节点保存了整个区间的和&#x2F;最大值&#x2F;最小值，左子节点保存了[left,(left+right)&#x2F;2]区间的和&#x2F;最大值&#x2F;最小值，右子节点保存了[(left+right)&#x2F;2+1,right]区间的和&#x2F;最大值&#x2F;最小值。所有叶子节点都只保存了单个点的值。上面的切分方法保证了最终是一个完全二叉树。</p><p>如果我们需要$O(logn)$的区间求和操作，则节点就保存区间的和，需要$O(logn)$的区间求最大值，则节点就保存区间的最大值，需要$O(logn)$的区间求最小值，则节点就保存区间的最小值。如果三个操作都需要同时$O(logn)$，则我们需要同时维护 3 个数组。</p><p>如果我们只维护一个区间和数组，那么求区间和的操作是$O(logn)$，求区间最大值&#x2F;最小值操作是$O(n)$。</p><p>观察模板代码中的 sum、min、max 方法，明明是二叉树的递归后序遍历，为什么时间复杂度是$O(logn)$呢？原因在于$if (start &#x3D;&#x3D; left &amp;&amp; end &#x3D;&#x3D; right)$这一条剪枝，模拟一下就可以知道，这条剪枝使得遍历时每一层最多遍历四个节点。</p><p>query 方法和 update 方法的时间复杂度为$O(logn)$是显然的。</p><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p>模板代码维护了三个数组，同时支持 O(logn)$的数组单点查询、单点修改、区间求和、区间求最大值、区间求最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTreeBasic</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] treeSum, treeMax, treeMin;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SegmentTreeBasic</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        n = nums.length;<br>        treeSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * <span class="hljs-number">4</span>];<br>        treeMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * <span class="hljs-number">4</span>];<br>        treeMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n * <span class="hljs-number">4</span>];<br>        build(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            treeSum[index] = nums[left];<br>            treeMax[index] = nums[left];<br>            treeMin[index] = nums[left];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        build(nums, left, mid, index * <span class="hljs-number">2</span>);<br>        build(nums, mid + <span class="hljs-number">1</span>, right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        updateSumNode(index);<br>        updateMinNode(index);<br>        updateMaxNode(index);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> query(id, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> treeSum[index];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (id &lt;= mid) &#123;<br>            <span class="hljs-keyword">return</span> query(id, left, mid, index * <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> query(id, mid + <span class="hljs-number">1</span>, right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> num)</span> &#123;<br>        update(id, num, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            treeSum[index] = num;<br>            treeMax[index] = num;<br>            treeMin[index] = num;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (id &lt;= mid) &#123;<br>            update(id, num, left, mid, index * <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            update(id, num, mid + <span class="hljs-number">1</span>, right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        updateSumNode(index);<br>        updateMinNode(index);<br>        updateMaxNode(index);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> sum(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, left, right, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == left &amp;&amp; end == right) &#123;<br>            <span class="hljs-keyword">return</span> treeSum[index];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (left &lt;= mid) &#123;<br>            sum += sum(start, mid, left, Math.min(mid, right), index * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &gt; mid) &#123;<br>            sum += sum(mid + <span class="hljs-number">1</span>, end, Math.max(mid + <span class="hljs-number">1</span>, left), right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, left, right, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == left &amp;&amp; end == right) &#123;<br>            <span class="hljs-keyword">return</span> treeMax[index];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, rightValue = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (left &lt;= mid) &#123;<br>            leftValue = max(start, mid, left, Math.min(mid, right), index * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &gt; mid) &#123;<br>            rightValue = max(mid + <span class="hljs-number">1</span>, end, Math.max(mid + <span class="hljs-number">1</span>, left), right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(leftValue, rightValue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> min(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, left, right, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == left &amp;&amp; end == right) &#123;<br>            <span class="hljs-keyword">return</span> treeMin[index];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, rightValue = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (left &lt;= mid) &#123;<br>            leftValue = min(start, mid, left, Math.min(mid, right), index * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &gt; mid) &#123;<br>            rightValue = min(mid + <span class="hljs-number">1</span>, end, Math.max(mid + <span class="hljs-number">1</span>, left), right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(leftValue, rightValue);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateSumNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        treeSum[index] = treeSum[index * <span class="hljs-number">2</span>] + treeSum[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateMaxNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        treeMax[index] = Math.max(treeMax[index * <span class="hljs-number">2</span>], treeMax[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateMinNode</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        treeMin[index] = Math.min(treeMin[index * <span class="hljs-number">2</span>], treeMin[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/circle/discuss/H4aMOn/">https://leetcode.cn/circle/discuss/H4aMOn/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树总结</title>
    <link href="/notes/2023/11/16/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%BE%E8%AE%BA%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/11/16/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%BE%E8%AE%BA%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树总结"><a href="#最小生成树总结" class="headerlink" title="最小生成树总结"></a>最小生成树总结</h1><p>生成树是特殊的生成子图，生成子图的定义是点集不变，取边子集。树是连通无圈无向图，树的边数等于点数减 1。最小生成树指的是，边权之和最小的生成树。任意无向连通图必有生成树，因此也必有最小生成树。</p><h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>首先为所有边从小到大排序，然后考虑包含所有点但不含任何边的初始图，依次取最小边尝试加入图中，如果出现圈就丢掉这条边，如果没有出现圈则加入图中，直到图中有点数减 1 条边，这时候我们就找到了一个最小生成树（最小生成树可能不止一个）。</p><h3 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584.连接所有点的最小费用"></a>1584.连接所有点的最小费用</h3><p>力扣题目链接：<a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">https://leetcode.cn/problems/min-cost-to-connect-all-points/</a></p><p>给你一个<code>points</code>&nbsp;数组，表示 2D 平面上的一些点，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p><p>连接点&nbsp;<code>[x<sub>i</sub>, y<sub>i</sub>]</code> 和点&nbsp;<code>[x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;的费用为它们之间的 <strong>曼哈顿距离</strong>&nbsp;：<code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>&nbsp;，其中&nbsp;<code>|val|</code>&nbsp;表示&nbsp;<code>val</code>&nbsp;的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong>&nbsp;一条简单路径时，才认为所有点都已连接。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/d.png" style="height:268px; width:214px; background:#e5e5e5" /></p><pre><strong>输入：</strong>points = [[0,0],[2,2],[3,10],[5,2],[7,0]]<strong>输出：</strong>20<strong>解释：</strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/c.png" style="height:268px; width:214px; background:#e5e5e5" />我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。注意到任意两个点之间只有唯一一条路径互相到达。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>points = [[3,12],[-2,5],[-4,1]]<strong>输出：</strong>18</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>points = [[0,0],[1,1],[1,0],[-1,1]]<strong>输出：</strong>4</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>points = [[-1000000,-1000000],[1000000,1000000]]<strong>输出：</strong>4000000</pre><p><strong>示例 5：</strong></p><pre><strong>输入：</strong>points = [[0,0]]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= points.length &lt;= 1000</code></li>    <li><code>-10<sup>6</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li>    <li>所有点&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;两两不同。</li></ul><h4 id="方法一：Kruskal-算法-并查集"><a href="#方法一：Kruskal-算法-并查集" class="headerlink" title="方法一：Kruskal 算法+并查集"></a>方法一：Kruskal 算法+并查集</h4><p>本题要考虑任意两点间的所有边，我们首先生成所有边，然后从小到大排序，在尝试将边加入图中的时候，用并查集来检查是否会出现圈，因为并查集可以返回任意两点是否连通。</p><ul><li>时间复杂度$O(n^2logn)$</li><li>空间复杂度$O(n^2)$</li></ul><h5 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> source;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> destination;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> length;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Edge</span><span class="hljs-params">(<span class="hljs-type">int</span> source, <span class="hljs-type">int</span> destination, <span class="hljs-type">int</span> length)</span> &#123;<br>            <span class="hljs-built_in">this</span>.source = source;<br>            <span class="hljs-built_in">this</span>.destination = destination;<br>            <span class="hljs-built_in">this</span>.length = length;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionSet</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] father;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            father = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                father[i] = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>            <span class="hljs-keyword">if</span> (father[u] == u) &#123;<br>                <span class="hljs-keyword">return</span> u;<br>            &#125;<br>            father[u] = find(father[u]);<br>            <span class="hljs-keyword">return</span> father[u];<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            <span class="hljs-keyword">return</span> find(x) == find(y);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            x = find(x);<br>            y = find(y);<br>            <span class="hljs-keyword">if</span> (x != y) &#123;<br>                father[y] = x;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        List&lt;Edge&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; points.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; points.length; j++) &#123;<br>                edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Edge</span>(i, j, distance(points, i, j)));<br>            &#125;<br>        &#125;<br>        Collections.sort(edges, (edge1, edge2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (edge1.length == edge2.length) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> edge1.length &gt; edge2.length ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;);<br>        <span class="hljs-type">UnionSet</span> <span class="hljs-variable">unionSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionSet</span>(points.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; edges.size(); i++) &#123;<br>            <span class="hljs-type">Edge</span> <span class="hljs-variable">edge</span> <span class="hljs-operator">=</span> edges.get(i);<br>            <span class="hljs-keyword">if</span> (unionSet.isSame(edge.source, edge.destination)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum += edge.length;<br>            unionSet.join(edge.source, edge.destination);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.abs(points[x][<span class="hljs-number">0</span>] - points[y][<span class="hljs-number">0</span>]) + Math.abs(points[x][<span class="hljs-number">1</span>] - points[y][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集总结</title>
    <link href="/notes/2023/11/16/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/11/16/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集总结"><a href="#并查集总结" class="headerlink" title="并查集总结"></a>并查集总结</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>并查集只用一个数组就可以维护所有元素的集合关系，并查集提供两个方法 join 和 isSame，join 方法可以合并任意两个元素所处集合，isSame 方法可以判断任意两个元素是否处于同一个集合。当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。并查集常常用于连通性问题，不同的连通分量是不同的集合，两点不在同一个集合等同于两点不在同一个连通分量，也就是不连通。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们定义一个长度为元素个数的 father 数组，father[x]&#x3D;y 代表着 x 元素的父亲是 y 元素，我们定义根元素为 father[t]&#x3D;t，即根元素的父亲是它自己。显然对于任何元素，我们可以不断找父亲从而一直追溯到根元素，我们定义如果两个元素的根元素相同等价于两个元素在同一个集合。</p><p>在初始化 father 数组时，我们令所有元素的父亲都是它自己，即 father[i]&#x3D;i，这意味着最开始每个元素各自处于一个集合。</p><p>路径压缩方法可以显著提高并查集的性能，思路也很简单，就是在 find 过程中，一旦找到了根元素，就把寻找路径上的所有节点的 father 都更新为根元素，这样操作不会影响并查集表示的集合关系，但是可以让之后的 find 函数走一步就找到根元素，显著提高效率。</p><ul><li>三种操作的时间复杂度都是$O(logn)$</li><li>空间复杂度$O(n)$</li></ul><p>路径压缩后的并查集时间复杂度在 $O(logn)$与 $O(1)$之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于 O(1)。在第一次查询的时候，相当于是 n 叉树上从叶子节点到根节点的查询过程，时间复杂度是 $O(logn)$，但路径压缩后，后面的查询操作都是 $O(1)$。</p><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] father;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; father.length; i++) &#123;<br>            father[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">if</span> (father[u] == u) &#123;<br>            <span class="hljs-keyword">return</span> u;<br>        &#125;<br>        father[u] = find(father[u]);<br>        <span class="hljs-keyword">return</span> father[u];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(x) == find(y);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        x = find(x);<br>        y = find(y);<br>        <span class="hljs-keyword">if</span> (x != y) &#123;<br>            father[y] = x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">https://leetcode.cn/problems/find-if-path-exists-in-graph/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/redundant-connection/">https://leetcode.cn/problems/redundant-connection/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论最短路总结</title>
    <link href="/notes/2023/11/14/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/11/14/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="图论最短路总结"><a href="#图论最短路总结" class="headerlink" title="图论最短路总结"></a>图论最短路总结</h1><p>图论最短路是研究赋权有向图&#x2F;无向图的单源点&#x2F;多源点最短路问题。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>赋权有向图&#x2F;无向图的单源点最短路问题，要求边权非负。Dijkstra 算法按照从小到大的顺序，输出当前点到所有其他点的最短路长度和最短路径。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>维护两个数组，一个数组是<strong>最短路长度</strong>数组 A，一个数组是<strong>最短路径前一个节点</strong>数组 B。将数组 A 初始化为单源点与所有其他点的直连长度，将数组 B 初始化为单源点。此时数组 A 中最小数对应的节点已经找到了最短路！然后对于除了<strong>单源点和已经找到最短路的节点</strong>之外的所有节点，我们利用新找到的最短路节点对它们进行更新，如果<strong>单源点到新找到节点的最短路</strong>+新找到节点到这个节点的直连距离之和小于 A 数组原来的值，就可以对 A 数组进行更新，同时把 B 数组对应位置置为新找到节点。刷新后，我们又可以找到关于某个节点的最短路，重复这个过程直到所有节点都找到最短路…</p><p>最后得到的 A 数组记录了所有单源点最短路径长度，B 数组记录了所有节点最短路径上的前一个点，需要完整最短路径的话，从后往前追溯即可。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>我们可以把节点分为<strong>已经找到最短路</strong>和<strong>还未找到最短路</strong>两类。A 数组维护的是对于所有还未找到最短路的节点，每个节点考虑和<strong>已经找到最短路</strong>的所有节点直连所能达到的最短，这时我们再考虑整个 A 数组的最小数，则这个最小数对应的一定是一条到这个最小数对应节点的最短路径长度，可以用反证法证明，假设存在一条到这个节点的更短的路径，我们考虑这条路径上这个节点的上一个节点，上一个节点有两种情况，即在<strong>已经找到最短路</strong>的节点集合或<strong>还未找到最短路</strong>的节点集合，即使是在<strong>还未找到最短路</strong>的节点集合中，我们也可以继续向前延伸，一定可以找到一个点在<strong>已经找到最短路</strong>的节点集合中，因此我们可以发现假设存在的这条更短路径中，一定存在一个<strong>还未找到最短路</strong>集合中的点，它的前一个点是<strong>已经找到最短路</strong>集合中的点，那么你这条路径就不可能比我们最小数的最短路径长度还短，矛盾。因此找到的就是最短路。</p><h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure><h2 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h2><h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><p>赋权有向图&#x2F;无向图的多源点最短路问题，要求边权可以为负，但是不可以有负圈（圈指的是闭路，路指的是节点不可重复的路径）。Floyd 算法是迭代后统一输出多源点最短路。</p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p>$u_{i,j}^{1}&#x3D;w_{i,j}$</p><p>$u_{i,j}^{k+1}&#x3D;min{u_{i,j}^{k},u_{i,k}^{k}+u_{k,j}^{k}}$</p><p>i,j 的范围都是{1,2…n}，定义 n 为节点数。</p><p>定义一个 U 矩阵，U 矩阵最开始初始化为邻接矩阵（两点间不存在边的话赋值正无穷），之后按照上面第二个公式不断迭代，最终求出所有的$u_{i,j}^{n+1}$，就是 i 节点到 j 节点的最短路径长度。</p><p>我们还需要维护一个 P 矩阵（和 U 矩阵同维度）。把$p_{i,j}^{1}$初始化为 j。在之后的迭代过程中，如果$u_{i,j}^{k}$更小，则$p_{i,j}^{k+1}&#x3D;p_{i,j}^{k}$，如果$u_{i,k}^{k}+u_{k,j}^{k}$更小，则$p_{i,j}^{k+1}&#x3D;p_{i,k}^{k}$。最终我们求出所有的$p_{i,j}^{n+1}$，就是 i 节点到 j 节点的最短路径中 i 节点的后一个节点。我们可以从前往后追溯得到最短路径。</p><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><p>Floyd 算法采用的其实是动态规划，$u_{i,j}^{k}$的含义是<strong>不通过 k 节点、k+1 节点…n 节点时从顶点 i 到顶点 j 的最短路长度</strong>。递推公式是，当我们有$U^k$矩阵时，对于$u_{i,j}^{k+1}$，考虑两种情况，一种是顶点 k 不在路径中，此时最短路就是$u_{i,j}^{k}$，另一种是顶点 k 在路径中（显然它只会存在一次），则最短路是由节点 k 分开的两条子路的最短路之和，正好就是$u_{i,k}^{k}+u_{k,j}^{k}$。而对于初始化来说，$u_{i,j}^{1}$为不经过任何节点的 i 到 j 最短路，显然是$w_{i,j}$。</p><h3 id="模板代码-1"><a href="#模板代码-1" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组总结</title>
    <link href="/notes/2023/11/13/%E7%AE%97%E6%B3%95%E7%AF%87%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/13/%E7%AE%97%E6%B3%95%E7%AF%87%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组总结"><a href="#树状数组总结" class="headerlink" title="树状数组总结"></a>树状数组总结</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对一个数组做单点修改以及求任意前缀和&#x2F;区间和</p><p>直接操作数组的单点修改时间复杂度 O(1)，求前缀和&#x2F;区间和时间复杂度 O(n)，平均操作时间复杂度 O(n)。额外记录前缀和数组的单点修改时间复杂度 O(n)，求前缀和&#x2F;区间和时间复杂度 O(1)，平均操作时间复杂度 O(n)。</p><p>树状数组这种数据结构的单点修改时间复杂度 O(logn)，求前缀和&#x2F;区间和时间复杂度 O(logn)，平均操作时间复杂度 O(logn)。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>记录一个 A 数组一个 C 数组，A 数组保存每个数，C 数组保存以当前数作为结尾的一定长度的区间和，这个区间的长度&#x3D;$2^n$，n 为当前位置索引的二进制表示的末尾 0 的个数。当我们构建好 A 数组和 C 数组后，如何求任意位置的前缀和呢？假设这个位置索引为 k，那么 k 前缀和&#x3D;C[k]+（k-C[k]区间长度）的前缀和，而 C[k]区间长度是多少呢？根据定义是$2^n$，n 为 k 的二进制表示的末尾 0 的个数。这里其实有一种简便算法，即 C[k]的区间长度&#x3D;k&amp;-k，在模板中我们定义这个函数为 lowbit。接下来我们只需要重复这个过程，直到 0。这里可以明显的看出来，求前缀和操作的时间复杂度是 O(logn)。</p><p>那么接下来如何做单点修改呢？假如说我们要修改位置 k 的数，对于 A 数组我们直接修改即可，对于 C 数组，我们首先要修改 C[k]，然后要修改树状数组中 C[k]的父亲，然后再修改父亲的父亲，直到某个 C 没有父亲为止。当我们把树状数组画出来后，可以很容易地看出 k 的父亲索引为 k+lowbit(k)。因此我们只需要不断地修改，直到超出数组范围为止。这里可以明显的看出来，单点修改操作的时间复杂度也是 O(logn)。</p><p>那么当最初给定一个 nums 数组，如何初始化树状数组呢？我们可以首先初始化 A 数组和 C 数组，里面的元素默认都是 0。根据树状数组的定义，此时其实 A 数组和 C 数组已经满足树状数组的关系了，只不过数组元素都是 0。这时我们可以遍历 nums 数组中的每一个元素，对树状数组依次做单点更新即可。整个初始化过程的时间复杂度是 O(nlogn)。</p><ul><li><p>树状数组空间复杂度$O(n)$</p></li><li><p>构造树状数组时间复杂度$O(nlogn)$</p></li><li><p>单点更新时间复杂度$O(logn)$</p></li><li><p>求任意位置前缀和时间复杂度$O(logn)$</p></li><li><p>求任意区间和时间复杂度$O(logn)$</p></li></ul><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/range-sum-query-mutable/">https://leetcode.cn/problems/range-sum-query-mutable/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] A;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] C;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            update(i, nums[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        index++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">change</span> <span class="hljs-operator">=</span> val - A[index];<br>        A[index] = val;<br>        <span class="hljs-keyword">while</span> (index &lt; C.length) &#123;<br>            C[index] += change;<br>            index += lowbit(index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> prefix(right) - prefix(left - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prefix</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        index++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += C[index];<br>            index -= lowbit(index);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-keyword">return</span> m &amp; -m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Jxianxu/article/details/108214752">https://blog.csdn.net/Jxianxu/article/details/108214752</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广搜与深搜总结</title>
    <link href="/notes/2023/11/12/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E4%B8%8E%E6%B7%B1%E6%90%9C%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/11/12/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E4%B8%8E%E6%B7%B1%E6%90%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="广搜与深搜总结"><a href="#广搜与深搜总结" class="headerlink" title="广搜与深搜总结"></a>广搜与深搜总结</h1><p>所有图论题目的核心考点都是如何将题目信息抽象为一个有向图&#x2F;无向图，至于抽象成图之后如何去做，基本是很固定的套路了。</p><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>主要有两种无向图，一种是有环的，一种是无环的（不连通是森林，连通是树）</p><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>所有搜过的点都不再搜，当且仅当没有连接的点或所有连接的点都已搜过的时候回溯。最终结果是遍历搜索起始点所在的连通分量上的所有点各一次，并针对每个点都得出一条路径（不一定是最短路径）。上述结论适用于有环&#x2F;无环的无向图。</p><ul><li>可用来判断两点之间是否可达</li><li>可用来找到两点之间的一条路径（不一定最短）</li></ul><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>不可以重复访问当前已走过路径上的点，当且仅当没有连接的点或所有连接的点都已经在已走过路径上的时候回溯。最终结果是得到从搜索起始点开始走，保证不重复访问已走过路径上的点的条件下，所能走出的所有路径。上述结论适用于有环&#x2F;无环的无向图。</p><ul><li>可用来找不重复访问已走过路径条件下的所有路径</li><li>可用来找两点间的所有路径</li></ul><h4 id="方式三："><a href="#方式三：" class="headerlink" title="方式三："></a>方式三：</h4><p>不回头的走，即除非回溯，否则不往来时的节点走。当且仅当到达悬挂点（度为 1 的点）时才可以回溯。最终结果是得到从搜索起始点开始走，不回头的走所能走出的所有路径。只适用于连通无环无向图（也就是树），如果应用于有环无向图，则会无限循环。</p><ul><li>可用来找从树中（把树当作图看待）任意节点出发所能走出的所有路径</li><li>可用来找树中（把树当作图看待）任意两节点间的唯一一条路径</li></ul><h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h3><h4 id="方式一：-1"><a href="#方式一：-1" class="headerlink" title="方式一："></a>方式一：</h4><p>所有搜过的点都不再搜，每次队头节点出队后，此节点连接的所有节点中，未进过队的节点才可以进队。最终结果是遍历搜索起始点所在的连通分量上的所有点各一次，并针对每个点都得出一条最短路径。上述结论适用于有环&#x2F;无环的无向图。</p><ul><li>可用来判断两点之间是否可达</li><li>可用来找到两点之间的一条最短路径</li></ul><h4 id="方式二：-1"><a href="#方式二：-1" class="headerlink" title="方式二："></a>方式二：</h4><p>不可以重复访问当前已走过路径上的点，每次队头节点出队后，此节点连接的所有节点中，不在队头节点走过的分支路径上的点才可以进队。最终结果是得到从搜索起始点开始走，保证不重复访问已走过路径上的点的条件下，所能走出的所有路径。上述结论适用于有环&#x2F;无环的无向图。</p><p>注意这种方式下 BFS 和 DFS 找到的所有路径完全一致，和方式一不同，BFS 不会去找最短路径。</p><ul><li>可用来找不重复访问已走过路径条件下从起点出发的所有路径</li><li>可用来找两点间的所有路径</li></ul><h4 id="方式三：-1"><a href="#方式三：-1" class="headerlink" title="方式三："></a>方式三：</h4><p>不回头的走，每次队头节点出队后，此节点连接的所有节点中，除去来时节点的所有节点都可以进队。最终结果是得到从搜索起始点开始走，不回头的走所能走出的所有路径。只适用于无环无向图（也就是树），如果应用于有环无向图，则会无限循环。</p><ul><li>可用来找从树中（把树当作图看待）任意节点出发所能走出的所有路径</li><li>可用来找树中（把树当作图看待）任意两节点间的唯一一条路径</li></ul><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="方式一：-2"><a href="#方式一：-2" class="headerlink" title="方式一："></a>方式一：</h4><p>所有搜过的点都不再搜，当且仅当没有可走的点或所有可走的点都已经搜过的时候才回溯。最终结果是访问搜索起始点所能到达的所有点各一次，注意并不是访问强连通分量（强连通分量中任意两点相互可达）上的点各一次，这和无向图的情况是不同的。需要说明的是，搜到的所有点中任意一点所能到达的所有点也必然全在搜索结果中，这可以用反证法证明，如果搜索结果中的某个点存在一个搜索结果之外的可到达点，那么这个点必然会被 DFS 搜到，矛盾。以上结论同时适用于有环&#x2F;无环有向图。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>84.柱状图中最大的矩形</title>
    <link href="/notes/2023/11/12/Leetcode%2084.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <url>/notes/2023/11/12/Leetcode%2084.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="【LetMeFly】84-柱状图中最大的矩形"><a href="#【LetMeFly】84-柱状图中最大的矩形" class="headerlink" title="【LetMeFly】84.柱状图中最大的矩形"></a>【LetMeFly】84.柱状图中最大的矩形</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p> </p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" /></p><pre><strong>输入：</strong>heights = [2,1,5,6,2,3]<strong>输出：</strong>10<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10</pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" /></p><pre><strong>输入：</strong> heights = [2,4]<b>输出：</b> 4</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 <= heights.length <=10<sup>5</sup></code></li>    <li><code>0 <= heights[i] <= 10<sup>4</sup></code></li></ul><h2 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h2><p>在柱状图中勾勒任何一个矩形，这个矩形的上边沿必定覆盖至少一个柱子的上边沿，沿着任何一个柱子的上边沿去勾勒矩形，勾勒出来的矩形一定是一个符合要求的矩形。因此问题转化为了沿着所有柱子的上边沿可以勾勒出来的所有矩形中，矩形面积最大是多少。根据贪心，我们沿着任何一个矩形的上边沿勾勒时，往两边走肯定越长越好，可以利用单调栈求出任何一个柱子左边和右边第一个更矮的柱子的位置，这样就可以求出所有矩形面积了。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123; <span class="hljs-comment">// 左边第一个小于的-&gt;严格递增，右边第一个小于的-&gt;非严格递增</span><br>        <span class="hljs-type">int</span>[] leftFirstSmaller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length];<br>        Arrays.fill(leftFirstSmaller, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span>[] rightFirstSmaller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length];<br>        Arrays.fill(rightFirstSmaller, -<span class="hljs-number">1</span>);<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peekLast()] &gt;= heights[i]) &#123;<br>                stack.pollLast();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                leftFirstSmaller[i] = stack.peekLast();<br>            &#125;<br>            stack.add(i);<br>        &#125;<br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peekLast()] &gt; heights[i]) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                rightFirstSmaller[num] = i;<br>            &#125;<br>            stack.add(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> (leftFirstSmaller[i] != -<span class="hljs-number">1</span> ? leftFirstSmaller[i] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (rightFirstSmaller[i] != -<span class="hljs-number">1</span> ? rightFirstSmaller[i] - <span class="hljs-number">1</span> : heights.length - <span class="hljs-number">1</span>);<br>            max = Math.max(max, (right - left + <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>42. 接雨水</title>
    <link href="/notes/2023/11/12/Leetcode%2042.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/notes/2023/11/12/Leetcode%2042.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>给定&nbsp;<code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" style="height: 161px; width: 412px;" /></p><pre><strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]<strong>输出：</strong>6<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>height = [4,2,0,3,2,5]<strong>输出：</strong>9</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == height.length</code></li>    <li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>    <li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li></ul><h2 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h2><p>可以看到所有接到的雨水都是由一块块的矩形组成。而每一块矩形的下边沿都至少和一个柱子的上边沿重合，反过来，每个柱子的上边沿作为矩形下边沿所能构成的最大矩形（如果可以构成矩形的话），也必然是一个雨水矩形块。因此我们发现它们有一一对应的关系。也就是说接下来，我们只需要计算每个柱子的上边沿作为矩形下边沿所能构成的最大矩形的面积之和即可（这里要去掉重复矩形，防止一个矩形被计算多次）。我们只需要得到每个柱子的左边和右边第一个更高柱子的位置，就可以算出来最大矩形面积。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n*m)$ n 为柱子个数，m 为最高柱子的高度</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> height)</span> &#123;<br>            <span class="hljs-built_in">this</span>.start = start;<br>            <span class="hljs-built_in">this</span>.end = end;<br>            <span class="hljs-built_in">this</span>.height = height;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Entry) obj;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.start == entry.start) &amp;&amp; (<span class="hljs-built_in">this</span>.end == entry.end) &amp;&amp; (<span class="hljs-built_in">this</span>.height == entry.height);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> start + end + height;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123; <span class="hljs-comment">// 左边第一个大的-&gt;严格单调递减 右边第一个大的-&gt;非严格单调递减</span><br>        <span class="hljs-keyword">if</span> (height.length &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] leftFirstBigger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br>        Arrays.fill(leftFirstBigger, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peekLast()] &lt;= height[i]) &#123;<br>                stack.pollLast();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                leftFirstBigger[i] = stack.peekLast();<br>            &#125;<br>            stack.addLast(i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] rightFirstBigger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[height.length];<br>        Arrays.fill(rightFirstBigger, -<span class="hljs-number">1</span>);<br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peekLast()] &lt; height[i]) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                rightFirstBigger[num] = i;<br>            &#125;<br>            stack.addLast(i);<br>        &#125;<br>        Set&lt;Entry&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (leftFirstBigger[i] != -<span class="hljs-number">1</span> &amp;&amp; rightFirstBigger[i] != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(leftFirstBigger[i], rightFirstBigger[i], height[i]);<br>                <span class="hljs-keyword">if</span> (!set.contains(entry)) &#123;<br>                    set.add(entry);<br>                    sum += (rightFirstBigger[i] - leftFirstBigger[i] - <span class="hljs-number">1</span>) * (Math.min(height[rightFirstBigger[i]], height[leftFirstBigger[i]]) - height[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈总结</title>
    <link href="/notes/2023/11/12/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/12/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%8D%95%E8%B0%83%E6%A0%88%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈总结"><a href="#单调栈总结" class="headerlink" title="单调栈总结"></a>单调栈总结</h1><h2 id="单调栈概述"><a href="#单调栈概述" class="headerlink" title="单调栈概述"></a>单调栈概述</h2><p>单调栈可以以双 O(n)的线性复杂度，得到数组中任意一个数左边&#x2F;右边第一个大于它&#x2F;大于等于它&#x2F;小于它&#x2F;小于等于它的数的位置和值。</p><h2 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h2><p>以严格单调递减栈为例：</p><p>查看栈顶元素，如果小于等于待进栈元素就不断出栈，直到栈顶元素大于待进栈元素或栈空，待进栈元素进栈。</p><h2 id="证明推导"><a href="#证明推导" class="headerlink" title="证明推导"></a>证明推导</h2><p>以严格单调递减栈为例：</p><ul><li>任何一个元素进栈时的栈顶元素就是左边第一个比它大的元素，如果栈空则左边不存在比它大的元素。</li><li>任何一个元素出栈时待进栈的元素就是右边第一个大于等于它的元素，如果元素在最后一个元素进栈后还在栈中，则这个元素右边不存在大于等于它的元素。</li></ul><p>上述结论为什么成立呢？关键在于严格单调递减栈的构造方式，我们采用数学归纳法，假设现在整个栈还没有出现过弹栈的情况，有一个待进栈元素，它向左找，所有小于等于它元素都弹栈，直到找到第一个大于它的栈顶元素就进栈，那么现在很显然栈顶元素和前一个元素之间的所有元素都是小于等于栈顶元素的，那么栈顶元素前一个元素必然是栈顶元素左边第一个比它大的元素。那么现在整个栈已经出现过了弹栈情况，又新来了一个待进栈元素，如果此时栈顶元素大于它，则可以直接进栈，栈顶元素其实就是待进栈元素的左边第一个元素，如果栈顶元素小于等于它，则我们就要弹栈考虑栈顶元素的下一个元素，那么栈顶元素和栈顶元素下一个元素在原序列中的中间元素怎么办呢？这时就要用到数学归纳法了，中间元素是一定小于等于栈顶元素的，因此也就小于等于待进栈元素。因此我们不断向右找，找到的第一个元素必然就是原序列中左边第一个比待进栈元素大的元素。</p><p>上面说的这么多其实就是证明了严格单调递减栈的结构，从左（栈底）到右（栈顶）所有元素都是严格单调递减的，任意两个栈中相邻元素之间的原序列元素，都是小于等于右边元素的。</p><p>从这个结构中，我们就很容易得出”任何一个元素进栈时的栈顶元素就是左边第一个比它大的元素”以及”任何一个元素出栈时待进栈的元素就是右边第一个大于等于它的元素”这两条结论了。</p><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><h2 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h2><table><thead><tr><th>需求</th><th>单调栈类型</th></tr></thead><tbody><tr><td>左边第一个大于当前元素</td><td>严格单调递减栈</td></tr><tr><td>左边第一个大于等于当前元素</td><td>非严格单调递减栈</td></tr><tr><td>左边第一个小于当前元素</td><td>严格单调递增栈</td></tr><tr><td>左边第一个小于等于当前元素</td><td>非严格单调递增栈</td></tr><tr><td>右边第一个大于当前元素</td><td>非严格单调递减栈</td></tr><tr><td>右边第一个大于等于当前元素</td><td>严格单调递减栈</td></tr><tr><td>右边第一个小于当前元素</td><td>非严格单调递增栈</td></tr><tr><td>右边第一个小于等于当前元素</td><td>严格单调递增栈</td></tr></tbody></table><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这篇博客讲单调栈讲的不错：<a href="https://blog.csdn.net/zy_dreamer/article/details/131036101">https://blog.csdn.net/zy_dreamer/article/details/131036101</a></p><p>单调栈和单调队列结构上其实是一样的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划总结</title>
    <link href="/notes/2023/11/11/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/11/11/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划总结"><a href="#动态规划总结" class="headerlink" title="动态规划总结"></a>动态规划总结</h1><h2 id="标准解题步骤"><a href="#标准解题步骤" class="headerlink" title="标准解题步骤"></a>标准解题步骤</h2><ol><li>确定 dp 数组下标的含义</li><li>确定递推公式</li><li>确定 dp 数组如何初始化</li><li>确定遍历顺序</li><li>dp 数组填充完毕后，如何对应得出题目最终解</li></ol><h2 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h2><p>数组下标含义（有的题可能需要稍微变化）：先偷当前这家，当前这家之后的家随便偷，所获的最大收益。</p><p>另一种下标含义的定义方式是：偷当前这家，之后所有家都不偷，之前所有家在不触发警报的情况下随便偷。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p><h2 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h2><p>数组下标含义（有的题可能需要稍微变化）：</p><ul><li>第一种：当天闭市时，持有股票所获最大收益。当天闭市时，未持有股票所获最大收益。</li><li>第二种：当天闭市时，持有股票且当天买入所获最大收益。当天闭市时，持有股票且当天未买入所获最大收益。当天闭市时，未持有股票且当天卖出所获最大收益。当天闭市时，未持有股票且当天未卖出所获最大收益。</li></ul><p>力扣题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><h2 id="子序列系列"><a href="#子序列系列" class="headerlink" title="子序列系列"></a>子序列系列</h2><ul><li><p>最长严格递增子序列</p><p>数组下标含义：dp[i] &#x3D; 最后一个数为 nums[i]的所有子序列中最长严格递增子序列的长度</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p></li><li><p>最长严格递增连续子序列：</p><p>数组下标含义：dp[i] &#x3D; 最后一个数为 nums[i]的所有连续子序列中最长严格递增连续子序列的长度</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p></li><li><p>最长公共连续子序列：</p><p>数组下标含义：dp[i][j] &#x3D; 把 nums1[i]和 nums2[j]对齐，一起向前走，最长能走多远。或者说以 nums1[i]结尾的所有连续子序列和以 nums2[j]结尾的所有连续子序列，相等的最大长度。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p></li><li><p>最长公共子序列：</p><p>数组下标含义：dp[i][j] &#x3D; nums1[0]到 nums1[i]，nums2[0]到 nums2[j]，它们的最长公共子序列长度。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题总结</title>
    <link href="/notes/2023/11/11/%E7%AE%97%E6%B3%95%E7%AF%87%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/11/%E7%AE%97%E6%B3%95%E7%AF%87%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h1><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="01-背包标准模型"><a href="#01-背包标准模型" class="headerlink" title="01 背包标准模型"></a>01 背包标准模型</h3><p>给定一些物品和一个背包，每个物品有重量和价值（都是正整数），背包有容量（自然数），尽可能地往背包中装物品（每个物品可以装也可以不装），问最大价值。其实等价于所有物品子集中满足背包容量条件的最大价值。</p><p>解法是动态规划，$dp[i][j]$代表 0-i 号物品随便装，背包容量为 j 的最大价值，递推公式是如果 i 号物品重量大于背包容量 j，则$dp[i][j]&#x3D;dp[i-1][j]$，如果背包容量 j 可以装下 i 号物品，则需要分类讨论装 i 号物品的情况和不装 i 号物品的情况，即$dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])$。</p><p>初始化第一行即可，如果是二维数组 dp，那么接下来每一行从前往后遍历即可，如果是滚动数组的话，每一次都要从后往前遍历。</p><p>用二维数组做 dp：</p><ul><li>时间复杂度$O(n*m)$，其中 n 为物品个数，m 为背包容量</li><li>空间复杂度$O(n*m)$</li></ul><p>用滚动数组做 dp：</p><ul><li>时间复杂度$O(n*m)$，其中 n 为物品个数，m 为背包容量</li><li>空间复杂度$O(m)$</li></ul><h3 id="最多能装多少重量模型"><a href="#最多能装多少重量模型" class="headerlink" title="最多能装多少重量模型"></a>最多能装多少重量模型</h3><p>给定背包容量，尽可能装，最多能装多少。定义所有物品的价值等于物品的重量，再套 01 背包标准模型，问题转化为了背包容量限制下尽可能装，最多能装多重。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p><h3 id="恰巧装满有多少种情况模型"><a href="#恰巧装满有多少种情况模型" class="headerlink" title="恰巧装满有多少种情况模型"></a>恰巧装满有多少种情况模型</h3><p>给定背包容量，装满背包有多少种方法。</p><p>前面两种模型的数组下标含义是一样的，本模型的数组下标含义变成了：$dp[i][j]$代表 0-i 号物品随便装，背包容量为 j ，恰巧装满一共有多少种情况。递推公式是如果 i 号物品重量大于背包容量 j，则$dp[i][j]&#x3D;dp[i-1][j]$，如果背包容量 j 可以装下 i 号物品，则需要分类讨论装 i 号物品的情况和不装 i 号物品的情况，即$dp[i][j]&#x3D;dp[i-1][j]+dp[i-1][j-weight[i]]$。</p><p>初始化第一行即可，如果是二维数组 dp，那么接下来每一行从前往后遍历即可，如果是滚动数组的话，每一次都要从后往前遍历。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p><h3 id="能否装满模型"><a href="#能否装满模型" class="headerlink" title="能否装满模型"></a>能否装满模型</h3><p>等价于最多能装多少模型中求出来的“最多”是否等于装满</p><p>等价于恰巧装满有多少种情况模型中情况数&gt;0</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p><h3 id="最多能装多少个物品模型"><a href="#最多能装多少个物品模型" class="headerlink" title="最多能装多少个物品模型"></a>最多能装多少个物品模型</h3><p>给定背包容量，最多能装多少个物品</p><p>定义所有物品的价值都等于 1，然后套 01 背包标准模型即可，最大价值即最多数目。</p><p>当背包有两个维度的容量限制的时候就要麻烦一点，需要使用三维 dp。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="完全背包标准模型"><a href="#完全背包标准模型" class="headerlink" title="完全背包标准模型"></a>完全背包标准模型</h3><p>给定一些物品和一个背包，每个物品有重量和价值（都是正整数），背包有容量（自然数），尽可能地往背包中装物品（每个物品可以装 0 到多次），问最大价值。</p><p>解法是动态规划，$dp[i][j]$代表 0-i 号物品随便装（每个物品可以装 0 到多次），背包容量为 j 的最大价值，递推公式是如果 i 号物品重量大于背包容量 j，则$dp[i][j]&#x3D;dp[i-1][j]$，如果背包容量 j 可以装下 i 号物品，则需要分类讨论不装 i 号物品的情况和至少装一个 i 号物品的情况，即$dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-weight[i]]+value[i])$。</p><p>初始化第一行即可，如果是二维数组 dp，那么接下来每一行从前往后遍历即可，如果是滚动数组的话，每一次都要从前往后遍历。</p><p>为什么 01 背包标准模型和完全背包标准模型的滚动数组遍历顺序不同呢？因为递推公式的区别。</p><p>用二维数组做 dp：</p><ul><li>时间复杂度$O(n*m)$，其中 n 为物品个数，m 为背包容量</li><li>空间复杂度$O(n*m)$</li></ul><p>用滚动数组做 dp：</p><ul><li>时间复杂度$O(n*m)$，其中 n 为物品个数，m 为背包容量</li><li>空间复杂度$O(m)$</li></ul><h3 id="恰巧装满有多少种情况模型（组合）"><a href="#恰巧装满有多少种情况模型（组合）" class="headerlink" title="恰巧装满有多少种情况模型（组合）"></a>恰巧装满有多少种情况模型（组合）</h3><p>和 01 背包标准模型迁移到 01 背包恰巧装满有多少种情况模型是一样的。</p><p>只不过由于是完全背包所以分类讨论变成了不装 i 号物品的情况和至少装一个 i 号物品的情况。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p><h3 id="恰巧装满有多少种情况模型（排列）"><a href="#恰巧装满有多少种情况模型（排列）" class="headerlink" title="恰巧装满有多少种情况模型（排列）"></a>恰巧装满有多少种情况模型（排列）</h3><p>和之前的模型都不一样，属于完全的一维 dp。</p><p>dp 数组下标含义是：$dp[i]$代表所有物品随便装（每个物品可以装 0 到多次），背包容量为 i ，恰好装满的排列情况数。</p><p>递推公式中的分类讨论变成了，排列序列的最后一个物品是什么。</p><p>初始化 dp[0]即可，然后从前向后遍历。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></p><h3 id="恰好装满所需最少物品数"><a href="#恰好装满所需最少物品数" class="headerlink" title="恰好装满所需最少物品数"></a>恰好装满所需最少物品数</h3><p>$dp[i][j]$代表 0-i 号物品随便装（每个物品可以装 0 到多次），背包容量为 j ，恰好装满所需最少物品数。</p><p>接下来和完全背包标准模型基本一样，值得一提的是我们可以用-1 或 Integer.MAXVULE 代表 dp[i][j]无法恰好装满。</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p><p>力扣题目链接：<a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>每个物品仍然可以取 0 到多，但是每个物品可取的数目是有上界的。</p><p>转换成 01 背包即可。</p><h2 id="自检"><a href="#自检" class="headerlink" title="自检"></a>自检</h2><p>以下写法是否都掌握了：</p><ul><li>01 背包最大价值问题的二维 dp 和一维 dp</li><li>01 背包恰好装满有多少种情形问题的二维 dp 和一维 dp</li><li>完全背包最大价值问题的二维 dp 和一维 dp</li><li>完全背包恰好装满有多少种情形（组合）问题的二维 dp 和一维 dp</li><li>完全背包恰好装满有多少种情形（排列）问题的特殊 dp</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1049.最后一块石头的重量 II</title>
    <link href="/notes/2023/11/11/Leetcode%201049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%20II/"/>
    <url>/notes/2023/11/11/Leetcode%201049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049.最后一块石头的重量 II"></a>1049.最后一块石头的重量 II</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p><p>有一堆石头，用整数数组&nbsp;<code>stones</code> 表示。其中&nbsp;<code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为&nbsp;<code>x</code> 和&nbsp;<code>y</code>，且&nbsp;<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul>    <li>如果&nbsp;<code>x == y</code>，那么两块石头都会被完全粉碎；</li>    <li>如果&nbsp;<code>x != y</code>，那么重量为&nbsp;<code>x</code>&nbsp;的石头将会完全粉碎，而重量为&nbsp;<code>y</code>&nbsp;的石头新重量为&nbsp;<code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块 </strong>石头。返回此石头 <strong>最小的可能重量 </strong>。如果没有石头剩下，就返回 <code>0</code>。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>stones = [2,7,4,1,8,1]<strong>输出：</strong>1<strong>解释：</strong>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>stones = [31,26,33,21,40]<strong>输出：</strong>5</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= stones.length &lt;= 30</code></li>    <li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h2 id="方法一：01-背包"><a href="#方法一：01-背包" class="headerlink" title="方法一：01 背包"></a>方法一：01 背包</h2><p>本题的难点在于如何将问题转化为 01 背包，我们可以将石头分成两个非空子集，从每个子集中分别取出一个石头来做消除，直到其中至少一个子集为空，这时候剩下的石头重量其实就等于两个非空子集石头重量总和的差值，也就是问题转化为了如何划分子集让它们的总和之差最小，即找到总和最接近 sum&#x2F;2 的子集，这就是典型的 01 背包问题了。显然的是，划分子集互相消除的方式和不断任选两个消除的方式其实是等价的。</p><ul><li>时间复杂度$O(n*sum)$</li><li>空间复杂度$O(sum)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-keyword">if</span> (stones.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> stones[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : stones) &#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (stones[<span class="hljs-number">0</span>] &lt;= i) &#123;<br>                dp[i] = stones[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; stones.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> dp.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= stones[i]) &#123;<br>                    dp[j] = Math.max(dp[j], stones[i] + dp[j - stones[i]]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[dp.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯总结</title>
    <link href="/notes/2023/11/09/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/09/%E7%AE%97%E6%B3%95%E7%AF%87%20%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯总结"><a href="#回溯总结" class="headerlink" title="回溯总结"></a>回溯总结</h1><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p><p>根节点是空节点，根节点分支考虑每一个节点，每一个节点的分支再考虑这个节点之后的每一个节点，递归中有两种情况会返回，一种是 path 中元素数目已够，另一种是 path 中元素数目虽然没够，但是当前节点已经是最后一个节点（之后没有节点了）。</p><p>思考：多重循环和回溯方法有什么区别呢？</p><p>多重循环每层循环次数可变，循环层数固定不可变。回溯方法每层循环次数可变，循环层数也可变（可受变量控制）。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        backtacking(n, k, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtacking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (depth == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            path.add(i);<br>            backtacking(n, k, depth + <span class="hljs-number">1</span>, i);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="情况相乘"><a href="#情况相乘" class="headerlink" title="情况相乘"></a>情况相乘</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p><p>第一个位置考虑所有的情况、第二个位置考虑所有的情况…… 相乘即可</p><h3 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">private</span> Map&lt;Character, List&lt;Character&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        build(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>);<br>        build(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br>        backtracking(<span class="hljs-number">0</span>, digits);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">char</span> c, Character... chars)</span> &#123;<br>        map.put(c, Arrays.asList(chars));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> index, String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        List&lt;Character&gt; characters = map.get(digits.charAt(index));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : characters) &#123;<br>            sb.append(c);<br>            backtracking(index + <span class="hljs-number">1</span>, digits);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p><p>根节点是空节点，根节点分支考虑每一个节点，每一个节点的分支再考虑这个节点之后的每一个节点，递归中只有一种情况会返回，即当前节点已经是最后一个节点（之后没有节点了）。子集的树和组合的树是同一棵树，只不过组合找的是叶子节点中长度等于组合元素个数的节点，而子集找的是所有节点。</p><h3 id="AC-代码-2"><a href="#AC-代码-2" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            backtracking(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可多取的子集"><a href="#可多取的子集" class="headerlink" title="可多取的子集"></a>可多取的子集</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p><p>子集是每个元素可以取或不取，可多取的子集是每个元素可以取 0 到多个。根节点是空节点，根节点分支考虑每一个节点，每一个节点的分支再考虑这个节点及这个节点之后的每一个节点，递归中有两种情况会返回，一种情况是因为某种原因而剪枝，另一种情况是当前分支下面的所有分支已经遍历完。</p><h3 id="AC-代码-3"><a href="#AC-代码-3" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        backtracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; candidates.length; i++) &#123;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br>            backtracking(candidates, target, i);<br>            path.removeLast();<br>            sum -= candidates[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="去重子集"><a href="#去重子集" class="headerlink" title="去重子集"></a>去重子集</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p><p>本题如果允许结果重复或者 candidates 数组中每个元素都不重复，那么就是一个简单的子集回溯，但是本题要求在集合存在重复元素的情况下找到所有不重复子集。如果采用对结果用 map 去重的方式就太低效了，我们可以考虑先排序再在回溯中去重。</p><p>回溯如下：根节点是空节点，根节点分支从左向右考虑集合中的元素构成分支，相同元素只考虑第一个。对于每一个分支，考虑下一个元素，并且仍然相同元素只考虑第一个。最终递归形成的树的所有节点都是去重的子集。递归中只有一种情况会返回，那就是已经没有节点可以走了。</p><p>上述去重过程为什么成立呢？因为其实树中任何一个节点为根的子树都对应着这个节点对应的子集+这个节点元素之后的所有元素构成的子集的所有情况，打个比方，假如排序后集合中连着两个 1，那么第一个 1 对应的所有情况已经把第二个 1 对应的所有情况覆盖了！</p><h3 id="AC-代码-4"><a href="#AC-代码-4" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backtracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == candidates.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (set.contains(candidates[i])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set.add(candidates[i]);<br>            &#125;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br>            backtracking(candidates, target, i + <span class="hljs-number">1</span>, sum);<br>            path.removeLast();<br>            sum -= candidates[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>取排列树的所有叶节点即可。</p><h3 id="AC-代码-5"><a href="#AC-代码-5" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">11</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            nums[i] = <span class="hljs-number">11</span>;<br>            backtracking(nums);<br>            nums[i] = path.getLast();<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="去重全排列"><a href="#去重全排列" class="headerlink" title="去重全排列"></a>去重全排列</h2><p>保证排列树每层相同元素只取一次即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; used.length; i++) &#123;<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        backtracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">21</span>];<br>        Arrays.fill(hash, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (hash[nums[i] + <span class="hljs-number">10</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                hash[nums[i] + <span class="hljs-number">10</span>] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtracking(nums);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="/notes/2023/11/09/Leetcode%20108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/notes/2023/11/09/Leetcode%20108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡 </strong>二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" style="width: 302px; height: 222px;" /><pre><strong>输入：</strong>nums = [-10,-3,0,5,9]<strong>输出：</strong>[0,-3,9,-10,null,5]<strong>解释：</strong>[0,-10,5,null,-3,null,9] 也将被视为正确答案：<img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" style="width: 302px; height: 222px;" /></pre><p><strong>示例 2：</strong></p><img alt="" src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" style="width: 342px; height: 142px;" /><pre><strong>输入：</strong>nums = [1,3]<strong>输出：</strong>[3,1]<strong>解释：</strong>[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>    <li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>    <li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="方法一：递归建树"><a href="#方法一：递归建树" class="headerlink" title="方法一：递归建树"></a>方法一：递归建树</h2><p>二叉搜索树的定义：</p><ul><li>直接定义：每个节点的左子树所有节点均小于当前节点，右子树所有节点均大于当前节点。</li><li>递归定义：根节点的左子树所有节点均小于根节点，根节点的右子树所有节点均大于根节点，且根节点的左右子树均为二叉搜索树。</li></ul><p>二叉平衡树的定义：</p><ul><li>直接定义：每个节点的左子树和右子树的深度之差的绝对值不大于 1。</li><li>递归定义：根节点的左子树和右子树的深度之差的绝对值不大于 1，且左右子树均为二叉平衡树。</li></ul><p>本题是将二叉搜索树和二叉平衡树组合成了平衡二叉搜索树。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(logn)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; j) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = build(nums, i, mid - <span class="hljs-number">1</span>);<br>        root.right = build(nums, mid + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>450. 删除二叉搜索树中的节点</title>
    <link href="/notes/2023/11/09/Leetcode%20450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/notes/2023/11/09/Leetcode%20450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></p><p>给定一个二叉搜索树的根节点 <strong>root </strong>和一个值 <strong>key</strong>，删除二叉搜索树中的&nbsp;<strong>key&nbsp;</strong>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol>    <li>首先找到需要删除的节点；</li>    <li>如果找到了，删除它。</li></ol><p>&nbsp;</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" style="width: 800px;" /></p><pre><strong>输入：</strong>root = [5,3,6,2,4,null,7], key = 3<strong>输出：</strong>[5,4,6,2,null,null,7]<strong>解释：</strong>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。<img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" style="width: 350px;" /></pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> root = [5,3,6,2,4,null,7], key = 0<strong>输出:</strong> [5,3,6,2,4,null,7]<strong>解释:</strong> 二叉树不包含值为 0 的节点</pre><p><strong>示例 3:</strong></p><pre><strong>输入:</strong> root = [], key = 0<strong>输出:</strong> []</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>    <li>节点数的范围&nbsp;<code>[0, 10<sup>4</sup>]</code>.</li>    <li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>    <li>节点值唯一</li>    <li><code>root</code>&nbsp;是合法的二叉搜索树</li>    <li><code>-10<sup>5</sup>&nbsp;&lt;= key &lt;= 10<sup>5</sup></code></li></ul><p>&nbsp;</p><p><strong>进阶：</strong> 要求算法时间复杂度为&nbsp;O(h)，h 为树的高度。</p><h2 id="方法一：理解切分"><a href="#方法一：理解切分" class="headerlink" title="方法一：理解切分"></a>方法一：理解切分</h2><p>二叉搜索树的本质就是切分，根节点切一下将区间分为左边和右边，左子节点切一下将左区间分为左边和右边，右子节点切一下将右区间分为左边和右边，依次进行。</p><p>如果我们要删除一个点，完全可以找到这个切分右边的最近一个切分（即要删除点的右子节点一直向左走直到走不了的那个节点），把这个切分替换到删除点的位置，然后进行适当的调整即可。做这种题本质还是要理解二叉搜索树的每个节点都是一个切分。</p><ul><li>时间复杂度$O(h)$，h 为树的高度</li><li>空间复杂度$O(1)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root, parent = root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.val &lt; key) &#123;<br>                parent = node;<br>                flag = <span class="hljs-number">1</span>;<br>                node = node.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent = node;<br>                flag = <span class="hljs-number">0</span>;<br>                node = node.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node == root) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                    parent.left = <span class="hljs-literal">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent.right = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node == root) &#123;<br>                <span class="hljs-keyword">return</span> node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                    parent.left = node.left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent.right = node.left;<br>                &#125;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node == root) &#123;<br>                <span class="hljs-keyword">return</span> node.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                    parent.left = node.right;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent.right = node.right;<br>                &#125;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (node == root) &#123;<br>                root = node.right;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root;<br>                <span class="hljs-keyword">while</span> (tmp.left != <span class="hljs-literal">null</span>) &#123;<br>                    tmp = tmp.left;<br>                &#125;<br>                tmp.left = node.left;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>                    parent.left = node.right;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> parent.left;<br>                    <span class="hljs-keyword">while</span> (tmp.left != <span class="hljs-literal">null</span>) &#123;<br>                        tmp = tmp.left;<br>                    &#125;<br>                    tmp.left = node.left;<br>                    <span class="hljs-keyword">return</span> root;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent.right = node.right;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> parent.right;<br>                    <span class="hljs-keyword">while</span> (tmp.left != <span class="hljs-literal">null</span>) &#123;<br>                        tmp = tmp.left;<br>                    &#125;<br>                    tmp.left = node.left;<br>                    <span class="hljs-keyword">return</span> root;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>235. 二叉搜索树的最近公共祖先</title>
    <link href="/notes/2023/11/09/Leetcode%20235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/notes/2023/11/09/Leetcode%20235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank">百度百科</a>中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。&rdquo;</p><p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" style="height: 190px; width: 200px;"></p><p>&nbsp;</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<strong>输出:</strong> 6 <strong>解释: </strong>节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code></pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<strong>输出:</strong> 2<strong>解释: </strong>节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。</pre><p>&nbsp;</p><p><strong>说明:</strong></p><ul>    <li>所有节点的值都是唯一的。</li>    <li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="方法一：走出一条路径"><a href="#方法一：走出一条路径" class="headerlink" title="方法一：走出一条路径"></a>方法一：走出一条路径</h2><p>对于二叉搜索树中的一个点，我们将它和根节点相比较就可以得出它是根节点还是左子树中的节点还是右子树中的节点，而两个节点的最近公共祖先一定是唯一的一个节点，这个节点满足一个点在右子树，一个点在左子树。因此我们就可以从根节点开始向下搜出一条路径。<br>二叉搜索树经常不涉及遍历所有节点，而是根据其有序性走出一条路，这时就没必要递归了，迭代法一个循环即可解决。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left,p,q);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right,p,q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：通用方法"><a href="#方法二：通用方法" class="headerlink" title="方法二：通用方法"></a>方法二：通用方法</h2><p>任何二叉树找最近公共祖先通用方法<br>任何节点到根节点存在唯一路径，这个路径上的点都是节点的祖先，我们只需要遍历二叉树保存两个节点对应的两条路径，再找到它们的交点即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;TreeNode&gt; pList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> List&lt;TreeNode&gt; qList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        preorder(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), p, q);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> Math.min(pList.size(), qList.size());<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (pList.get(i) != qList.get(i)) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            res = pList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, ArrayList&lt;TreeNode&gt; list, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        list.add(root);<br>        <span class="hljs-keyword">if</span> (root == p) &#123;<br>            pList = (List&lt;TreeNode&gt;) (list.clone());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == q) &#123;<br>            qList = (List&lt;TreeNode&gt;) (list.clone());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pList.size() &gt; <span class="hljs-number">0</span> &amp;&amp; qList.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (preorder(root.left, list, p, q)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">bool</span> <span class="hljs-operator">=</span> preorder(root.right, list, p, q);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> bool;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/notes/2023/11/09/Leetcode%2098.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/notes/2023/11/09/Leetcode%2098.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul>    <li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li>    <li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>    <li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>&nbsp;</p><p><strong>示例 1：</strong></p><img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" style="width: 302px; height: 182px;" /><pre><strong>输入：</strong>root = [2,1,3]<strong>输出：</strong>true</pre><p><strong>示例 2：</strong></p><img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" style="width: 422px; height: 292px;" /><pre><strong>输入：</strong>root = [5,1,4,null,null,3,6]<strong>输出：</strong>false<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>    <li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li></ul><h2 id="方法一：利用二叉搜索树性质"><a href="#方法一：利用二叉搜索树性质" class="headerlink" title="方法一：利用二叉搜索树性质"></a>方法一：利用二叉搜索树性质</h2><p>二叉搜索树的定义是每个节点的左子树所有节点均小于当前节点，右子树所有节点均大于当前节点，另一种递归定义是，根节点的左子树所有节点均小于根节点，根节点的右子树所有节点均大于根节点，且根节点的左右子树均为二叉搜索树。</p><p>一个二叉树是二叉搜索树的充分必要条件是关于这个二叉树的中序遍历（左中右）是单调递增的，或者关于这个二叉树的中序遍历（右中左）是单调递减的。</p><p>所以本题做一个中序遍历判断是否单调递增即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isStart</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> !inorder(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (inorder(root.left)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isStart &amp;&amp; root.val &lt;= last) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        isStart = <span class="hljs-literal">false</span>;<br>        last = root.val;<br>        <span class="hljs-keyword">if</span> (inorder(root.right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h2><p>从二叉搜索树的定义出发</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isValid;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> min;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isValid, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> min)</span> &#123;<br>            <span class="hljs-built_in">this</span>.isValid = isValid;<br>            <span class="hljs-built_in">this</span>.max = max;<br>            <span class="hljs-built_in">this</span>.min = min;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isBST(root).isValid;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Result <span class="hljs-title function_">isBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">true</span>, root.val, root.val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Result</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isBST(root.left);<br>            <span class="hljs-keyword">if</span> (!left.isValid) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left.max &lt; root.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">true</span>, root.val, left.min);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Result</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isBST(root.right);<br>            <span class="hljs-keyword">if</span> (!right.isValid) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.val &lt; right.min) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">true</span>, right.max, root.val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Result</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isBST(root.left);<br>            <span class="hljs-keyword">if</span> (!left.isValid) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-type">Result</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isBST(root.right);<br>            <span class="hljs-keyword">if</span> (!right.isValid) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left.max &lt; root.val &amp;&amp; root.val &lt; right.min) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">true</span>, right.max, left.min);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>106. 从中序与后序遍历序列构造二叉树</title>
    <link href="/notes/2023/11/08/Leetcode%20106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/notes/2023/11/08/Leetcode%20106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗&nbsp;<em>二叉树</em>&nbsp;。</p><p>&nbsp;</p><p><strong>示例 1:</strong></p><img alt="" src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" /><pre><b>输入：</b>inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<b>输出：</b>[3,9,20,null,null,15,7]</pre><p><strong>示例 2:</strong></p><pre><b>输入：</b>inorder = [-1], postorder = [-1]<b>输出：</b>[-1]</pre><p>&nbsp;</p><p><strong>提示:</strong></p><ul>    <li><code>1 &lt;= inorder.length &lt;= 3000</code></li>    <li><code>postorder.length == inorder.length</code></li>    <li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>    <li><code>inorder</code>&nbsp;和&nbsp;<code>postorder</code>&nbsp;都由 <strong>不同</strong> 的值组成</li>    <li><code>postorder</code>&nbsp;中每一个值都在&nbsp;<code>inorder</code>&nbsp;中</li>    <li><code>inorder</code>&nbsp;<strong>保证</strong>是树的中序遍历</li>    <li><code>postorder</code>&nbsp;<strong>保证</strong>是树的后序遍历</li></ul><h2 id="方法一：典型建树"><a href="#方法一：典型建树" class="headerlink" title="方法一：典型建树"></a>方法一：典型建树</h2><p>这道题是一道典型题，给出一个节点数值不重复的二叉树的中序序列和后序序列，反向构建二叉树。后序遍历序列的最后一个数是根节点，这个数在中序遍历序列的某个中间位置，此位置之前是左子树的中序遍历序列，之后是右子树的中序遍历序列，而后序遍历序列则等同于左子树后序遍历序列+右子树后序遍历序列+根节点。因此问题就可以化成两个子问题从而用递归解决，为了在中序遍历序列中方便的查找数的位置，我们可以使用 map。</p><p>题目 105.从前序与中序遍历序列构造二叉树其实是一样的道理</p><p>力扣题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><p>需要注意的是前序和中序可以唯一确定一棵二叉树，后序和中序可以唯一确定一棵二叉树，但前序和后序不可以唯一确定一棵二叉树！</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(inorder, postorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inEnd &lt; inStart) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postEnd]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> map.get(postorder[postEnd]);<br>        root.left = build(inorder, postorder, inStart, pos - <span class="hljs-number">1</span>, postStart, postStart + pos - <span class="hljs-number">1</span> - inStart);<br>        root.right = build(inorder, postorder, pos + <span class="hljs-number">1</span>, inEnd, postStart + pos - inStart, postEnd - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历总结</title>
    <link href="/notes/2023/11/08/%E7%AE%97%E6%B3%95%E7%AF%87%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93%20/"/>
    <url>/notes/2023/11/08/%E7%AE%97%E6%B3%95%E7%AF%87%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h1><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        preorder(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.add(root.val);<br>        preorder(root.left);<br>        preorder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈方式"><a href="#栈方式" class="headerlink" title="栈方式"></a>栈方式</h3><p>栈方式实现前序遍历的关键在于，不断地重复：访问当前节点、右节点进栈、转移到左节点，如果当前节点为空则弹栈，直到当前节点为空且栈空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                node = stack.pop();<br>            &#125;<br>            res.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(node.right);<br>            &#125;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><h3 id="递归方式-1"><a href="#递归方式-1" class="headerlink" title="递归方式"></a>递归方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        inorder(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorder(root.left);<br>        res.add(root.val);<br>        inorder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈方式-1"><a href="#栈方式-1" class="headerlink" title="栈方式"></a>栈方式</h3><p>栈方式实现中序遍历的关键在于，一直向左走并进栈，直到节点为空，然后弹栈，访问节点，取节点的右子节点重复这个过程，直到节点为空且栈空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                node = stack.pop();<br>                res.add(node.val);<br>                node = node.right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            stack.push(node);<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p>力扣题目链接：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><h3 id="递归方式-2"><a href="#递归方式-2" class="headerlink" title="递归方式"></a>递归方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        postorder(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root.left);<br>        postorder(root.right);<br>        res.add(root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈方式-2"><a href="#栈方式-2" class="headerlink" title="栈方式"></a>栈方式</h3><p>栈方式实现后序遍历的关键在于，第一次访问栈顶节点时不要出栈，第二次访问栈顶节点才出栈，仍然是一直向左走并进栈直到节点为空，这时候查看栈顶节点，如果是第一次查看则取这个节点的右子节点再次一直向左走，如果是第二次查看则这个节点出栈并访问这个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>        <span class="hljs-keyword">public</span> TreeNode node;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> shouldOut;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Entry</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>            <span class="hljs-built_in">this</span>.node = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Stack&lt;Entry&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!stack.peek().shouldOut) &#123;<br>                    stack.peek().shouldOut = <span class="hljs-literal">true</span>;<br>                    node = stack.peek().node.right;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(stack.pop().node.val);<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(node));<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h2><h3 id="队列方式"><a href="#队列方式" class="headerlink" title="队列方式"></a>队列方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            res.add(list);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归方式-3"><a href="#递归方式-3" class="headerlink" title="递归方式"></a>递归方式</h3><p>递归方式访问节点的顺序并不是广度优先的，它本质上是先序遍历二叉树，把每一行的节点按从左到右的顺序存起来，最后拼接成一个序列，然后遍历这个序列才是广度优先遍历顺序。之所以能这么做的原因在于，先序遍历同一行内左边的节点一定比右边的节点先被遍历到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        preorder(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res.size() &lt;= depth) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        List&lt;Integer&gt; list = res.get(depth);<br>        list.add(root.val);<br>        preorder(root.left, depth + <span class="hljs-number">1</span>);<br>        preorder(root.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>239. 滑动窗口最大值</title>
    <link href="/notes/2023/11/07/Leetcode%20239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/notes/2023/11/07/Leetcode%20239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p><p>给你一个整数数组 <code>nums</code>，有一个大小为&nbsp;<code>k</code><em>&nbsp;</em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>&nbsp;个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值 </em>。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3<b>输出：</b>[3,3,5,5,6,7]<b>解释：</b>滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       <strong>3</strong> 1 [3  -1  -3] 5  3  6  7       <strong>3</strong> 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong> 1  3  -1 [-3  5  3] 6  7       <strong>5</strong> 1  3  -1  -3 [5  3  6] 7       <strong>6</strong> 1  3  -1  -3  5 [3  6  7]      <strong>7</strong></pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>nums = [1], k = 1<b>输出：</b>[1]</pre><p>&nbsp;</p><p><b>提示：</b></p><ul>    <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>    <li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>    <li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>本题为单调队列的一种应用。单调队列和优先队列都关注队列中的最小数和最大数，那么它们有哪些不同呢？</p><ul><li>单调队列：一种单调顺序的线性表，进队元素直接进队，出队元素是最早进队的元素，单调队列并不关注于出队元素和进队元素（也没有办法关注），它提供 O(1)的时间复杂度可以随时获取队列中所有元素的最小数或最大数，并且出队进队操作加起来往往是 O(n)的时间复杂度。</li><li>优先队列：大根堆&#x2F;小根堆，进队元素直接进队，出队元素是当前队列最大&#x2F;最小的元素，优先队列可以关注出队元素和进队元素分别是什么，它也提供 O(1)的时间复杂度可以随时获取队列中所有元素的最小数或最大数，但出队进队操作加起来往往是 O(nlogk)的时间复杂度。</li></ul><p>下面介绍单调队列的原理（以单调递减队列为例），对于原队列，我们从最后一个数开始向前遍历，如果前面的数更大则保留，更小或平则丢弃，丢弃是因为，这些数在自己出队之前，队列中一直有着大于等于自己的数，所以自己永远不可能是队列的最大值。然后我们就得到了一个从前到后单调递减的队列，此时队列所有元素的最大值显然是第一个数。接下来考虑进队和出队，对于出队，我们只需要查看第一个数是否需要出队即可，对于进队，我们则从后向前遍历并删掉所有小于等于进队数的元素。综上所述，我们就可以一直维护一个单调队列，它只可以随时返回队列最大值&#x2F;最小值，虽然在接口外看来是一个完整的队列。</p><p>至于单调队列应用于本题，则就是滑动窗口滑动对应一出队一进队，总体下来每个元素最多出队进队一次。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(k)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Deque&lt;<span class="hljs-type">int</span>[]&gt; monotonicQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            add(nums[i], i);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        res[<span class="hljs-number">0</span>] = getMax();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            poll();<br>            add(nums[i], i);<br>            res[i - k + <span class="hljs-number">1</span>] = getMax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> pos)</span> &#123;<br>        <span class="hljs-keyword">while</span> (!monotonicQueue.isEmpty()) &#123;<br>            <span class="hljs-keyword">if</span> (monotonicQueue.peekLast()[<span class="hljs-number">0</span>] &gt; num) &#123;<br>                monotonicQueue.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, pos&#125;);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            monotonicQueue.pollLast();<br>        &#125;<br>        monotonicQueue.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num, pos&#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (monotonicQueue.peekFirst()[<span class="hljs-number">1</span>] == index) &#123;<br>            monotonicQueue.pollFirst();<br>        &#125;<br>        index++;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> monotonicQueue.peekFirst()[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>150. 逆波兰表达式求值</title>
    <link href="/notes/2023/11/02/Leetcode%20150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/notes/2023/11/02/Leetcode%20150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据&nbsp;<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul>    <li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li>    <li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>    <li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>    <li>表达式中不含除零运算。</li>    <li>输入是一个根据逆波兰表示法表示的算术表达式。</li>    <li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p>&nbsp;</p><p><strong>示例&nbsp;1：</strong></p><pre><strong>输入：</strong>tokens = ["2","1","+","3","*"]<strong>输出：</strong>9<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</pre><p><strong>示例&nbsp;2：</strong></p><pre><strong>输入：</strong>tokens = ["4","13","5","/","+"]<strong>输出：</strong>6<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</pre><p><strong>示例&nbsp;3：</strong></p><pre><strong>输入：</strong>tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]<strong>输出：</strong>22<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>    <li><code>tokens[i]</code>&nbsp;是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p>&nbsp;</p><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul>    <li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>    <li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul>    <li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>    <li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h2 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h2><p>逆波兰表达式又称后缀表达式，它是表达式二叉树的后序遍历序列，不同于中缀表达式需要考虑运算符优先级，后缀表达式直接从前向后遍历，遇到运算符就计算前面两个数即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tokens.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Integer.parseInt(tokens[<span class="hljs-number">0</span>]);<br>        &#125;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tokens.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (tokens[i].equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> stack.pop();<br>                stack.push(value1 + value2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[i].equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> stack.pop();<br>                stack.push(value1 - value2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[i].equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> stack.pop();<br>                stack.push(value1 * value2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tokens[i].equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> stack.pop();<br>                stack.push(value1 / value2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(Integer.parseInt(tokens[i]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>225. 用队列实现栈</title>
    <link href="/notes/2023/11/02/Leetcode%20225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/notes/2023/11/02/Leetcode%20225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul>    <li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>    <li><code>int pop()</code> 移除并返回栈顶元素。</li>    <li><code>int top()</code> 返回栈顶元素。</li>    <li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p>&nbsp;</p><p><strong>注意：</strong></p><ul>    <li>你只能使用队列的基本操作 —— 也就是&nbsp;<code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和&nbsp;<code>is empty</code>&nbsp;这些操作。</li>    <li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li></ul><p>&nbsp;</p><p><strong>示例：</strong></p><pre><strong>输入：</strong>["MyStack", "push", "push", "top", "pop", "empty"][[], [1], [2], [], [], []]<strong>输出：</strong>[null, null, null, 2, 2, false]<strong>解释：</strong>MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= x &lt;= 9</code></li>    <li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>    <li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p>&nbsp;</p><p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p><h2 id="方法一：单个队列模拟"><a href="#方法一：单个队列模拟" class="headerlink" title="方法一：单个队列模拟"></a>方法一：单个队列模拟</h2><p>进栈直接进队，出栈的话队列中除了最后一个元素外的所有元素重新进队出队，最后一个元素返回。</p><ul><li>时间复杂度: pop 为 $O(n)$，其他为 $O(1)$</li><li>空间复杂度: $O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.add(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        queue.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (queue.peek() == <span class="hljs-number">0</span>) &#123;<br>                queue.poll();<br>                <span class="hljs-keyword">return</span> num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.add(num);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> pop();<br>        push(pop);<br>        <span class="hljs-keyword">return</span> pop;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>232. 用栈实现队列</title>
    <link href="/notes/2023/11/02/Leetcode%20232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/notes/2023/11/02/Leetcode%20232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul>    <li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>    <li><code>int pop()</code> 从队列的开头移除并返回元素</li>    <li><code>int peek()</code> 返回队列开头的元素</li>    <li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul>    <li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有&nbsp;<code>push to top</code>,&nbsp;<code>peek/pop from top</code>,&nbsp;<code>size</code>, 和&nbsp;<code>is empty</code>&nbsp;操作是合法的。</li>    <li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>["MyQueue", "push", "push", "peek", "pop", "empty"][[], [1], [2], [], [], []]<strong>输出：</strong>[null, null, null, 1, 1, false]<strong>解释：</strong>MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false</pre><ul></ul><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= x &lt;= 9</code></li>    <li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>    <li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>    <li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>一个栈负责进队，一个栈负责出队。进队的时候直接进进队栈，出队或者取队头元素的时候如果出队栈为空，则需要把进队栈的数倒过来。</p><ul><li>时间复杂度 push 和 empty 为$O(1)$, pop 和 peek 为$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 负责进栈</span><br>        stackOut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 负责出栈</span><br>    &#125;<br><br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        dumpstackIn();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        dumpstackIn();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dumpstackIn</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (!stackOut.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span> (!stackIn.isEmpty())&#123;<br>                stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28. 找出字符串中第一个匹配项的下标</title>
    <link href="/notes/2023/10/31/Leetcode%2028.%20%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/"/>
    <url>/notes/2023/10/31/Leetcode%2028.%20%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a>28.找出字符串中第一个匹配项的下标</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p><p>给你两个字符串&nbsp;<code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果&nbsp;<code>needle</code> 不是 <code>haystack</code> 的一部分，则返回&nbsp; <code>-1</code><strong> </strong>。</p><p>&nbsp;</p><p><strong class="example">示例 1：</strong></p><pre><strong>输入：</strong>haystack = "sadbutsad", needle = "sad"<strong>输出：</strong>0<strong>解释：</strong>"sad" 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。</pre><p><strong class="example">示例 2：</strong></p><pre><strong>输入：</strong>haystack = "leetcode", needle = "leeto"<strong>输出：</strong>-1<strong>解释：</strong>"leeto" 没有在 "leetcode" 中出现，所以返回 -1 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>    <li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="方法一：暴力匹配"><a href="#方法一：暴力匹配" class="headerlink" title="方法一：暴力匹配"></a>方法一：暴力匹配</h2><p>以匹配串的每个字符作为起点尝试匹配模式串。</p><ul><li>时间复杂度$O(m*n)$ n 为匹配串长度，m 为模式串长度</li><li>空间复杂度$O(1)$</li></ul><h2 id="方法二：KMP"><a href="#方法二：KMP" class="headerlink" title="方法二：KMP"></a>方法二：KMP</h2><p>这里原理分为两部分，next 数组的生成和字符串匹配过程。</p><p>需要注意的是 KMP 算法只能找到第一个匹配的字符串或者判断是否存在匹配的字符串。</p><h3 id="next-数组生成"><a href="#next-数组生成" class="headerlink" title="next 数组生成"></a>next 数组生成</h3><p>主要采用动态规划的方式，数组下标定义为当前字符一直到第一个字符的最长公共前后缀长度，而只要有前面所有字符的最长公共前后缀长度，我们就可以推出当前字符的最长公共前后缀长度，又因为第一个字符的最长公共前后缀长度为 0，因此我们从左向右遍历就可以生成 next 数组.</p><p>下面讲一下递推公式：</p><p>那么当我们知道前面所有字符的最长公共前后缀，如何求当前字符的最长公共前后缀呢？首先我们已知前一个字符的最长公共前后缀，当前字符的最长公共前后缀最大为前一个字符的最长公共前后缀+1（这个可以用反证法证明，如果存在更长的则前一个字符的最长公共前后缀也必然存在更长的，那前一个字符的最长公共前后缀就不是最长的了，矛盾），这时我们可以比较一下字符串当前字符和前一个字符的最长公共前后缀+1 这个位置的字符是否相等，如果相等的话当前字符最长公共前后缀显然为前一个字符的最长公共前后缀+1，如果不等的话，就要考虑前一个字符的次长公共前后缀，这里为什么可以直接考虑次长公共前后缀呢（仍然用反证法证明，如果存在更长的则前一个字符的次长公共前后缀也必然存在更长的，那它就不是次长了，矛盾）。那么前一个字符的次长公共前后缀是多少呢，其实是前一个字符的最长公共前后缀的位置的字符的最长公共前后缀（这里建议画图理解）。然后我们可以进一步比较字符串当前字符和前一个字符的次长公共前后缀+1 这个位置的字符是否相等，如果相等则当前字符的最长公共前后缀等于前一个字符的次长公共前后缀+1，如果不等的话我们再考虑前一个字符的次次长公共前后缀……</p><p>直到最后可能出现一种情况是，前一个字符的次……长公共前后缀等于 0 了，这时再不等的话，我们直接为当前字符的最长公共前后缀赋 0 即可。</p><h3 id="字符串匹配过程"><a href="#字符串匹配过程" class="headerlink" title="字符串匹配过程"></a>字符串匹配过程</h3><p>为模式串和匹配串分别设置一个指针，指针同时后移，从模式串和匹配串的第一个字符开始向后匹配，找到第一个不匹配的字符，将模式串指针调到这个字符的前一个字符（也就是最后一个匹配的字符）的最长公共前后缀长度的位置，继续匹配，直到找到匹配的第一个字符串，或者匹配到最后没找到。</p><p>next 数组生成的时间复杂度为$O(m)$，空间复杂度为$O(m)$。字符串匹配过程的时间复杂度为$O(n)$，空间复杂度为$O(1)$。至于为什么复杂度是这样我没太想明白，大概是一个平均的复杂度，类似于快排最坏$O(n^2)$，最好$O(n\log n)$，但我们一般认为快排是$O(n\log n)$一样。</p><ul><li>时间复杂度$O(m+n)$</li><li>空间复杂度$O(m)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>      <span class="hljs-keyword">if</span> (needle.length() &gt; haystack.length()) &#123;<br>          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-type">int</span>[] value = kmp(needle);<br>      <span class="hljs-type">int</span> <span class="hljs-variable">haystackIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, needleIndex = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (haystackIndex &lt; haystack.length()) &#123;<br>          <span class="hljs-keyword">if</span> (haystack.charAt(haystackIndex) == needle.charAt(needleIndex)) &#123;<br>              haystackIndex++;<br>              needleIndex++;<br>              <span class="hljs-keyword">if</span> (needleIndex &gt;= needle.length()) &#123;<br>                  <span class="hljs-keyword">return</span> pos;<br>              &#125;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (needleIndex == <span class="hljs-number">0</span>) &#123;<br>              pos = haystackIndex + <span class="hljs-number">1</span>;<br>              haystackIndex++;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              needleIndex = value[needleIndex - <span class="hljs-number">1</span>];<br>              pos = haystackIndex - needleIndex;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] kmp(String s) &#123;<br>      <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>      next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">return</span> next;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (i &lt; s.length()) &#123;<br>          <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>              next[i] = j + <span class="hljs-number">1</span>;<br>              i++;<br>              j++;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>              next[i] = <span class="hljs-number">0</span>;<br>              i++;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              j = next[j - <span class="hljs-number">1</span>];<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0151. 反转字符串中的单词</title>
    <link href="/notes/2023/10/31/Leetcode%20151.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/notes/2023/10/31/Leetcode%20151.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>s = "<code>the sky is blue</code>"<strong>输出：</strong>"<code>blue is sky the</code>"</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>s = " &nbsp;hello world &nbsp;"<strong>输出：</strong>"world hello"<strong>解释：</strong>反转后的字符串中不能存在前导空格和尾随空格。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>s = "a good &nbsp; example"<strong>输出：</strong>"example good a"<strong>解释：</strong>如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>    <li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li>    <li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><ul></ul><p>&nbsp;</p><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用&nbsp;<code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h2 id="方法一：单独处理"><a href="#方法一：单独处理" class="headerlink" title="方法一：单独处理"></a>方法一：单独处理</h2><p>切片，把每个单词单独拿出来，然后反序拼接。这种方式不满足空间 O(1)的要求，</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h2 id="方法二：整体翻转再局部翻转"><a href="#方法二：整体翻转再局部翻转" class="headerlink" title="方法二：整体翻转再局部翻转"></a>方法二：整体翻转再局部翻转</h2><p>一个数组或字符串被分为多个块，如果整体翻转就直接翻转，如果块内翻转就分别翻转，如果块间翻转就先整体翻转再分别块内翻转。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (s.charAt(end) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            end--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            start++;<br>        &#125;<br>        s = s.substring(start, end + <span class="hljs-number">1</span>);<br>        start = s.length() - <span class="hljs-number">1</span>;<br>        end = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                start--;<br>            &#125;<br>            sb.append(s.substring(start + <span class="hljs-number">1</span>, end + <span class="hljs-number">1</span>));<br>            sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">while</span> (start &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(start - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                start--;<br>            &#125;<br>            start--;<br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.substring(<span class="hljs-number">0</span>, sb.charAt(sb.length() - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27; &#x27;</span> ? sb.length() - <span class="hljs-number">1</span> : sb.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2003. 每棵子树内缺失的最小基因值</title>
    <link href="/notes/2023/10/31/Leetcode%202003.%20%E6%AF%8F%E6%A3%B5%E5%AD%90%E6%A0%91%E5%86%85%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%80%BC/"/>
    <url>/notes/2023/10/31/Leetcode%202003.%20%E6%AF%8F%E6%A3%B5%E5%AD%90%E6%A0%91%E5%86%85%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="2003-每棵子树内缺失的最小基因值"><a href="#2003-每棵子树内缺失的最小基因值" class="headerlink" title="2003.每棵子树内缺失的最小基因值"></a>2003.每棵子树内缺失的最小基因值</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/">https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/</a></p><p>有一棵根节点为 <code>0</code>&nbsp;的 <strong>家族树</strong>&nbsp;，总共包含 <code>n</code>&nbsp;个节点，节点编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组 <code>parents</code>&nbsp;，其中&nbsp;<code>parents[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的父节点。由于节点 <code>0</code>&nbsp;是 <strong>根</strong>&nbsp;，所以&nbsp;<code>parents[0] == -1</code>&nbsp;。</p><p>总共有&nbsp;<code>10<sup>5</sup></code>&nbsp;个基因值，每个基因值都用 <strong>闭区间</strong>&nbsp;<code>[1, 10<sup>5</sup>]</code>&nbsp;中的一个整数表示。给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的基因值，且基因值 <strong>互不相同</strong>&nbsp;。</p><p>请你返回一个数组<em>&nbsp;</em><code>ans</code>&nbsp;，长度为&nbsp;<code>n</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是以节点&nbsp;<code>i</code>&nbsp;为根的子树内 <b>缺失</b>&nbsp;的&nbsp;<strong>最小</strong>&nbsp;基因值。</p><p>节点 <code>x</code>&nbsp;为根的 <strong>子树&nbsp;</strong>包含节点 <code>x</code>&nbsp;和它所有的 <strong>后代</strong>&nbsp;节点。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2021/08/23/case-1.png" style="width: 204px; height: 167px;"></p><pre><b>输入：</b>parents = [-1,0,0,2], nums = [1,2,3,4]<b>输出：</b>[5,1,1,1]<b>解释：</b>每个子树答案计算结果如下：- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。</pre><p><strong>示例 2：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2021/08/23/case-2.png" style="width: 247px; height: 168px;"></p><pre><b>输入：</b>parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]<b>输出：</b>[7,1,1,4,2,1]<b>解释：</b>每个子树答案计算结果如下：- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。</pre><p><strong>示例 3：</strong></p><pre><b>输入：</b>parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]<b>输出：</b>[1,1,1,1,1,1,1]<b>解释：</b>所有子树都缺失基因值 1 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == parents.length == nums.length</code></li>    <li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>    <li>对于&nbsp;<code>i != 0</code>&nbsp;，满足&nbsp;<code>0 &lt;= parents[i] &lt;= n - 1</code></li>    <li><code>parents[0] == -1</code></li>    <li><code>parents</code>&nbsp;表示一棵合法的树。</li>    <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>    <li><code>nums[i]</code>&nbsp;互不相同。</li></ul><h2 id="方法一：分类讨论-深度优先搜索"><a href="#方法一：分类讨论-深度优先搜索" class="headerlink" title="方法一：分类讨论+深度优先搜索"></a>方法一：分类讨论+深度优先搜索</h2><p>无论是 2 叉树还是 K 叉树，常见的表示方式就是链表方式和数组方式，本题就是使用数组方式对非完全 K 叉树进行表示。关于数组表示 K 叉树，主要分为三种方法：</p><ul><li>第一种直接表示法，只适用于二叉树，完全二叉树不用动，非完全二叉树需要补所有空节点，然后按照广度优先遍历的顺序存数组，这样任何节点数组下标&#x2F;2 就是父节点，_2 就是左子节点，_2+1 就是右子节点。</li><li>第二种父节点表示法，适用于任何 K 叉树，任何一个节点的数组下标位置都存了此节点父节点的数组下标，根节点存-1，注意二叉树一定是 n 个节点，n-1 条边。</li><li>第三种子节点表示法，适用于任何 K 叉树，任何一个节点的数组下标位置都存了一个 list，这个 list 里面放了此节点的所有子节点的数组下标。</li></ul><p>对于任意 K 叉树，都可以用第二种或第三种方法确定地唯一表示，并且第二种方法表示可以和第三种方法表示互相转换，就比如本题给了第二种表示，我们为了进行 dfs 自己转换成了第三种表示。</p><p>说回本题，本题的关键在于一个分类讨论：如果树中不存在 1 会怎样，存在 1 又会怎样。如果树中不存在 1，那么任意节点的最小缺失基因都是 1。如果树中存在 1，那么这个 1 节点和它所有的父节点（也就是从 1 节点到根节点的这条路径）的最小缺失基因都不是 1，其他所有节点的最小缺失基因都是 1，至于这条路径上所有节点的最小缺失基因，我们可以维护一个 set，结合不断地 dfs，自底向上地把所有的最小缺失基因都求出来。</p><p>关于时间复杂度和空间复杂度，我们发现虽然整个过程做了很多事情，但是它们的复杂度都没有超过 O(n)。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] smallestMissingValueSubtree(<span class="hljs-type">int</span>[] parents, <span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[parents.length];<br>        Arrays.fill(res, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        List&lt;Integer&gt;[] childArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[parents.length];<br>        Arrays.setAll(childArr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntFunction</span>&lt;List&lt;Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; parents.length; i++) &#123;<br>            childArr[parents[i]].add(i);<br>        &#125;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index != -<span class="hljs-number">1</span>) &#123;<br>            set.add(nums[index]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; childArr[index].size(); i++) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> childArr[index].get(i);<br>                <span class="hljs-keyword">if</span> (child != last) &#123;<br>                    preorder(set, childArr[index].get(i), childArr, nums);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (set.contains(num)) &#123;<br>                num++;<br>            &#125;<br>            res[index] = num;<br>            last = index;<br>            index = parents[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(Set&lt;Integer&gt; set, <span class="hljs-type">int</span> root, List&lt;Integer&gt;[] childArr, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root &gt; childArr.length - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        set.add(nums[root]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; childArr[root].size(); i++) &#123;<br>            preorder(set, childArr[root].get(i), childArr, nums);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和</title>
    <link href="/notes/2023/10/30/Leetcode%2015.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/notes/2023/10/30/Leetcode%2015.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]<strong>解释：</strong>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [0,1,1]<strong>输出：</strong>[]<strong>解释：</strong>唯一可能的三元组和不为 0 。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>nums = [0,0,0]<strong>输出：</strong>[[0,0,0]]<strong>解释：</strong>唯一可能的三元组和为 0 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>3 &lt;= nums.length &lt;= 3000</code></li>    <li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>本题可以先暴力搜索$O(n^3)$，然后再去重（每个三元组排个序，再利用 hashmap 去重），但是这种做法非常慢。我们可以采用排序去重的方式，即先排序数组，在找的过程中就不找重复的，这样最后就不用再去重了。具体来说，我们先锚定第一个数和第二个数，利用 map 在剩余的数里面$O(1)$找解，然后右移第二个数，找到下一个不同的数，重复过程直到超出数组长度。然后右移第一个数，找到下一个不同的数，重复过程。</p><ul><li>时间复杂度$O(n^2)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == last) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            last = nums[i];<br>            Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                map.put(nums[j], map.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newLast</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> map.get(nums[j]);<br>                <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                    map.remove(nums[j]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    map.put(nums[j], num - <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[j] == newLast) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                newLast = nums[j];<br>                <span class="hljs-keyword">if</span> (map.containsKey(-<span class="hljs-number">1</span> * nums[i] - nums[j])) &#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    list.add(nums[i]);<br>                    list.add(nums[j]);<br>                    list.add(-nums[i] - nums[j]);<br>                    res.add(list);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h2><p>本题能够用双指针的关键在于一个结论，即对于无序数组的两数之和问题可以用双$O(n)$的哈希表求解，而对于有序数组的两数之和问题既可以用双$O(n)$的哈希表求解，也可以用时间$O(n)$空间 O(1)的双指针求解。对于这个双指针法，其实是设置 left 在最左边的数，right 在最右边的数，然后 right 收缩直到$left+right&#x3D;target$或$left+right&lt;target$，这时将 left 左移一位，然后继续重复过程。</p><p>注意其实四数之和、五数之和都可以用同样的双指针方法，对应时间复杂度$O(n^3)$、$O(n^4)$…</p><p>四数之和：<a href="https://leetcode.cn/problems/4sum/description/">https://leetcode.cn/problems/4sum/description/</a></p><ul><li>时间复杂度$O(n^2)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i]+nums[j]+nums[k];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));<br>                    j++;<br>                    <span class="hljs-keyword">while</span> (j&lt;k&amp;&amp;nums[j]==nums[j-<span class="hljs-number">1</span>]) &#123;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j == k) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    k--;<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) &#123;<br>                        k--;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j == k) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    j++;<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                        j++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j == k) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    k--;<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) &#123;<br>                        k--;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j == k) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="/notes/2023/10/30/Leetcode%20142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/notes/2023/10/30/Leetcode%20142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><p>给定一个链表的头节点 &nbsp;<code>head</code>&nbsp;，返回链表开始入环的第一个节点。&nbsp;<em>如果链表无环，则返回&nbsp;<code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改 </strong>链表。</p><ul></ul><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" /></p><pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1<strong>输出：</strong>返回索引为 1 的链表节点<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</pre><p><strong>示例&nbsp;2：</strong></p><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" /></p><pre><strong>输入：</strong>head = [1,2], pos = 0<strong>输出：</strong>返回索引为 0 的链表节点<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</pre><p><strong>示例 3：</strong></p><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" /></p><pre><strong>输入：</strong>head = [1], pos = -1<strong>输出：</strong>返回 null<strong>解释：</strong>链表中没有环。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>    <li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>    <li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>&nbsp;</p><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h1 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h1><p>利用 set 来存放链表节点，在 java 中链表节点类并没有重写 Object 类的 hashcode 和 equals 方法，因此 set 可以直接针对链表节点对象去重。无环则一直不重复，重复则说明有环，并且可以直接找到入环的第一个节点。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        Map&lt;ListNode, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(head)) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(head, <span class="hljs-number">1</span>);<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h1><p>快指针一次走两步，慢指针一次走一步。无环则快指针走到 null，有环则快慢指针必然相遇，并且相遇点和起始点到入环的第一个节点的距离相同，因此我们可以找到入环的第一个节点。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                <span class="hljs-keyword">while</span> (head != slow) &#123;<br>                    head = head.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <link href="/notes/2023/10/30/Leetcode%2019.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/notes/2023/10/30/Leetcode%2019.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19.删除链表的倒数第 N 个结点"></a>19.删除链表的倒数第 N 个结点</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><p>给你一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" style="width: 542px; height: 222px;" /><pre><strong>输入：</strong>head = [1,2,3,4,5], n = 2<strong>输出：</strong>[1,2,3,5]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>head = [1], n = 1<strong>输出：</strong>[]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>head = [1,2], n = 1<strong>输出：</strong>[1]</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>链表中结点的数目为 <code>sz</code></li>    <li><code>1 &lt;= sz &lt;= 30</code></li>    <li><code>0 &lt;= Node.val &lt;= 100</code></li>    <li><code>1 &lt;= n &lt;= sz</code></li></ul><p>&nbsp;</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>链表不像数组一样可以直接使用下标来取数据，但双指针可以让我们关于链表的操作灵活一些。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            right = right.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) &#123;<br>            head = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (right.next != <span class="hljs-literal">null</span>) &#123;<br>            right = right.next;<br>            left = left.next;<br>        &#125;<br>        left.next = left.next.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>209. 长度最小的子数组</title>
    <link href="/notes/2023/10/30/Leetcode%20209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/notes/2023/10/30/Leetcode%20209.%20%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p><p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p><p>找出该数组中满足其总和大于等于<strong> </strong><code>target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]<strong>输出：</strong>2<strong>解释：</strong>子数组&nbsp;<code>[4,3]</code>&nbsp;是该条件下的长度最小的子数组。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>target = 4, nums = [1,4,4]<strong>输出：</strong>1</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]<strong>输出：</strong>0</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>    <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li></ul><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>    <li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h2 id="方法一：暴力搜索"><a href="#方法一：暴力搜索" class="headerlink" title="方法一：暴力搜索"></a>方法一：暴力搜索</h2><p>连续子数组等同于连续子序列，一个长为 n 的数组&#x2F;字符串的连续子序列个数是$n+C^2_n$，因此我们可以直接两个 for 循环或者递归回溯来暴力搜索。另外看到连续子序列的和，也应该想到用两个前缀和相减求解的可能性。</p><ul><li>时间复杂度$O(n^2)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="方法二：滑动窗口"><a href="#方法二：滑动窗口" class="headerlink" title="方法二：滑动窗口"></a>方法二：滑动窗口</h2><p>对于字符串&#x2F;数组中涉及“连续”的问题，都可以考虑是否能用滑动窗口求解。对于本题，我们的 right 指针一直向右走直到连续子序列的和大于等于 target（如果走到头说明结束了），这时找到的就是所有以第一个数作为起始的连续子序列中的最短，然后 left 指针右移一位，然后再去判断并右移 right 指针。最终的出口有两个，一个是中途 left 超过 right，这时说明存在一个大于等于 target 的数，另一个是 right 走到尽头。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (right &lt; nums.length) &#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">if</span> (sum &gt;= target) &#123;<br>                <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                    res = Math.min(res, right - left + <span class="hljs-number">1</span>);<br>                    sum -= nums[left];<br>                    left++;<br>                &#125;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>275. H 指数 II</title>
    <link href="/notes/2023/10/30/Leetcode%20275.%20H%20%E6%8C%87%E6%95%B0%20II/"/>
    <url>/notes/2023/10/30/Leetcode%20275.%20H%20%E6%8C%87%E6%95%B0%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="275-H-指数-II"><a href="#275-H-指数-II" class="headerlink" title="275.H 指数 II"></a>275.H 指数 II</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/h-index-ii/">https://leetcode.cn/problems/h-index-ii/</a></p><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数，<code>citations</code> 已经按照&nbsp;<strong>升序排列&nbsp;</strong>。计算并返回该研究者的 h<strong><em>&nbsp;</em></strong>指数。</p><p><a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin" target="_blank">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 <code>h</code> 指数是指他（她）的 （<code>n</code> 篇论文中）<strong>总共</strong>有 <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p><p>请你设计并实现对数时间复杂度的算法解决此问题。</p><p>&nbsp;</p><p><strong class="example">示例 1：</strong></p><pre><strong>输入<code>：</code></strong><code>citations = [0,1,3,5,6]</code><strong>输出：</strong>3 <strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 0<code>, 1, 3, 5, 6</code> 次。&nbsp;    由于研究者有 <code>3 </code>篇论文每篇<strong> 至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用<strong> 不多于</strong> <code>3</code> 次，所以她的<em> h </em>指数是 <code>3</code> 。</pre><p><strong class="example">示例 2：</strong></p><pre><strong>输入：</strong>citations = [1,2,100]<strong>输出：</strong>2</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == citations.length</code></li>    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>    <li><code>0 &lt;= citations[i] &lt;= 1000</code></li>    <li><code>citations</code> 按 <strong>升序排列</strong></li></ul><h2 id="方法一：二分"><a href="#方法一：二分" class="headerlink" title="方法一：二分"></a>方法一：二分</h2><p>本题由 274.H 指数发展而来，通过分析可以发现，通过取中做个判断，就可以筛掉一半的解，因此可以使用二分法。<br>我们分析一下出口：</p><ul><li>4-&gt;2,2</li><li>3-&gt;2,1</li><li>2-&gt;1,1</li><li>1-&gt;出口</li></ul><p>因此总能找到出口。</p><ul><li>时间复杂度$O(\log n)$，其中$n &#x3D; len(citations)$</li><li>空间复杂度$O(1)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = citations.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (citations[mid] &gt;= citations.length - mid) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> citations[left] &gt;= citations.length - left ? citations.length - left : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>274.H 指数</title>
    <link href="/notes/2023/10/30/Leetcode%20274.H%20%E6%8C%87%E6%95%B0/"/>
    <url>/notes/2023/10/30/Leetcode%20274.H%20%E6%8C%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274.H 指数"></a>274.H 指数</h1><p>力扣题目链接：<a href="https://leetcode.cn/problems/h-index/">https://leetcode.cn/problems/h-index/</a></p><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code><em>&nbsp;</em>指数</strong>。</p><p>根据维基百科上&nbsp;<a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin" target="_blank">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code><strong> 指数 </strong>是指他（她）至少发表了 <code>h</code> 篇论文，并且每篇论文<strong> 至少</strong> 被引用 <code>h</code> 次。如果 <code>h</code><em> </em>有多种可能的值，<strong><code>h</code> 指数 </strong>是其中最大的那个。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong><code>citations = [3,0,6,1,5]</code><strong>输出：</strong>3 <strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 <code>3, 0, 6, 1, 5</code> 次。&nbsp;    由于研究者有 <code>3 </code>篇论文每篇 <strong>至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用 <strong>不多于</strong> <code>3</code> 次，所以她的 <em>h </em>指数是 <code>3</code>。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>citations = [1,3,1]<strong>输出：</strong>1</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>n == citations.length</code></li>    <li><code>1 &lt;= n &lt;= 5000</code></li>    <li><code>0 &lt;= citations[i] &lt;= 1000</code></li></ul><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>从大到小排序，排序之后从前向后遍历。判断第一个数是否$\geq1$，如果$\geq1$说明至少有 1 个数大于等于 1，继续向下看，如果第二个数$\geq2$，则说明至少有 2 个数大于等于 2，如果第二个数$&lt;2$，则说明不够 2 个数大于等于 2，说明 h 指数是 1，不是 2 更不可能是 3,4…</p><ul><li>时间复杂度$O(n\log n)$，其中$n &#x3D; len(citations)$</li><li>空间复杂度$O(\log n)$</li></ul><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        Arrays.sort(citations);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> citations.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (citations[i] &lt; citations.length - i) &#123;<br>                <span class="hljs-keyword">return</span> citations.length - i - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> citations.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h2><p>数组下标定义为截至目前（包括当前这个数），h 指数的值以及大于等于 h 的数的个数，递归公式为，当我们新增下一个数时，如果下一个数大于等于 h+1 且前面至少有 h 个大于等于 h+1 的数，则 h 指数可以提高 1，否则不变。前面有多少个大于等于 h+1 的数我们是通过大于等于 h 的数的个数减去等于 h 的数的个数求得的，因此我们维护了一个 map。最后初始化 dp[0]并从左到右遍历即可。</p><ul><li>时间复杂度$O(n)$，其中$n &#x3D; len(citations)$</li><li>空间复杂度$O(n)$</li></ul><h3 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[citations.length][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (citations[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        map.put(citations[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; citations.length; i++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> map.getOrDefault(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (citations[i] &gt;= dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &amp;&amp; (dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - num &gt;= dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>])) &#123;<br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>                dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - num + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + (citations[i] &gt;= dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            &#125;<br>            map.put(citations[i], map.getOrDefault(citations[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[citations.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无队列、阻塞队列和消息队列</title>
    <link href="/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20%E6%97%A0%E9%98%9F%E5%88%97%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20%E6%97%A0%E9%98%9F%E5%88%97%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="无队列、阻塞队列和消息队列"><a href="#无队列、阻塞队列和消息队列" class="headerlink" title="无队列、阻塞队列和消息队列"></a>无队列、阻塞队列和消息队列</h1><h3 id="无队列"><a href="#无队列" class="headerlink" title="无队列"></a>无队列</h3><p>无队列的情况意味着任务生成后要在当前线程立即执行，有多少个并发就要同时执行多少个任务，假设同一时间有 1000 个并发，那么就要同时执行 1000 个任务，导致计算负载大小和并发数有关，即我们无法控制计算负载。另一个缺点是对于某些请求，执行完一系列操作再返回会导致接口时间长。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列取数据若队空会阻塞，存数据若队满会阻塞。比如 Java 中 concurrent 包的 ArrayBlockingQueue，就是一个数组实现的线程安全阻塞队列。阻塞队列相比于无队列的优点是：第一，任务生成与任务消费解耦，接口可以直接返回。第二，无论请求并发是多少，任务消费始终以可控的速度执行。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列相比于阻塞队列功能更加强大。主要优点有：第一，以独立服务的方式运行，不占用 JVM 内存，不会导致 JVM 堆内存溢出。第二，往往支持持久化技术，若服务宕机消息数据仍存在。第三，消息数据只有在确认被消费后才会被清除，这意味着消费者取出数据后的消费出现异常时消息队列中的数据不会丢失。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本文件和二进制文件的区别</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="文本文件和二进制文件的区别"><a href="#文本文件和二进制文件的区别" class="headerlink" title="文本文件和二进制文件的区别"></a>文本文件和二进制文件的区别</h1><blockquote><p>文本文件和二进制文件区别：1、文本文件是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等；2、二进制文件是基于值编码的文件</p></blockquote><p><strong>一、文本文件与二进制文件的定义</strong></p><p>大家都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是逻辑上的。这两者只是在编码层次上有差异。</p><p>简单来说，文本文件是基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（这样一个过程，可以看作是自定义编码）。</p><p>从上面可以看出文本文件基本上是定长编码的，基于字符嘛，每个字符在具体编码中是固定的，ASCII 码是 8 个比特的编码，UNICODE 一般占 16 个比特。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。大家可能对 BMP 文件比较熟悉，就拿它举例子吧，其头部是较为固定长度的文件头信息，前 2 字节用来记录文件为 BMP 格式，接下来的 8 个字节用来记录文件长度，再接下来的 4 字节用来记录 bmp 文件头的长度。。。大家可以看出来了吧，其编码是基于值的（不定长的，2、4、8 字节长的值都有），所以 BMP 是二进制文件。</p><p><strong>二、文本文件与二进制文件的存取</strong></p><p>文本工具打开一个文件的过程是怎样的呢？拿记事本来说，它首先读取文件物理上所对应的二进制比特流（前面已经说了，存储都是二进制的），然后按照你所选择的解码方式来解释这个流，然后将解释结果显示出来。一般来说，你选取的解码方式会是 ASCII 码形式（ASCII 码的一个字符是８个比特），接下来，它 8 个比特 8 个比特地来解释这个文件流。例如对于这么一个文件流”01000000_01000001_01000010_01000011”(下划线’_‘，是我为了增强可读性，而手动添加的)，第一个 8 比特’01000000’按 ASCII 码来解码的话，所对应的字符是字符’A’，同理其它 3 个 8 比特可分别解码为’BCD’，即这个文件流可解释成“ABCD”，然后记事本就将这个“ABCD”显示在屏幕上。</p><p>事实上，世界上任何东西要与其他东西通信会话，都存在一个既定的协议，既定的编码。人与人之间通过文字联络，汉字“妈”代表生你的那个人，这就是一种既定的编码。但注意到这样一种情况，汉字“妈”在日本文字里有可能是你生下的那个人，所以当一个中国人Ａ与日本Ｂ之间用“妈”这个字进行交流，出现误解就很正常的。用记事本打开二进制文件与上面的情况类似。记事本无论打开什么文件都按既定的字符编码工作（如 ASCII 码），所以当他打开二进制文件时，出现乱码也是很必然的一件事情了，解码和译码不对应嘛。例如文件流’00000000_00000000_00000000_00000001’可能在二进制文件中对应的是一个四字节的整数 int1，在记事本里解释就变成了”NULL_NULL_NULL_SOH”这四个控制符。</p><p>文本文件的存储与其读取基本上是个逆过程，不再累述。而二进制文件的存取显然与文本文件的存取差不多，只是编／解码方式不同而已，也不再叙述。</p><p><strong>三、文本文件与二进制文件的优缺点</strong></p><p>因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点，这个找本编码的书来看看就比较清楚了。一般认为，文本文件编码基于字符定长，译码容易些；二进制文件编码是变长的，所以它灵活，存储利用率要高些，译码难一些（不同的二进制文件格式，有不同的译码方式）。关于空间利用率，想想看，二进制文件甚至可以用一个比特来代表一个意思(位操作)，而文本文件任何一个意思至少是一个字符．</p><p>很多书上还认为，文本文件的可读性要好些，存储要花费转换时间(读写要编译码)，而二进制文件可读性差，存储不存在转换时间（读写不要编解码，直接写值）．这里的可读性是从软件使用者角度来说的，因为我们用通用的记事本工具就几乎可以浏览所有文本文件，所以说文本文件可读性好；而读写一个具体的二进制文件需要一个具体的文件解码器，所以说二进制文件可读性差，比如读 BMP 文件，必须用读图软件．而这里的存储转换时间应该是从编程的角度来说的，因为有些操作系统如 windows 需要对回车换行符进行转换(将’\n’，换成’\r\n’，所以文件读写时，操作系统需要一个一个字符的检查当前字符是不是’\n’或’\r\n’).这个在存储转换在 Linux 操作系统中并不需要，当然，当在两个不同的操作系统上共享文件时，这种存储转换又可能出来(如 Linux 系统和 Windows 系统共享文本文件)。关于这个转换怎样进行，我将在下一篇文章《Linux 文本文件与 Windows 文本文件间的转换》给出^_^</p><p><strong>四、Ｃ的文本读写和二进制读写</strong></p><p>应该说Ｃ的文本读写与二进制的读写是一个编程层次上的问题，与具体的操作系统有关，所以＂用文本方式读写的文件一定是文本文件，用二进制读写的文件一定是二进制文件”这类观点是错误的．下面的讲述非明确指出操作系统类型，都暗指 windows．Ｃ的文本方读写与二进制读写的差别仅仅体现在回车换行符的处理上．文本方式写时，每遇到一个’\n’(0AH 换行符)，它将其换成’\r\n’(0D0AH，回车换行)，然后再写入文件；当文本读取时，它每遇到一个’\r\n’将其反变化为’\n’，然后送到读缓冲区．正因为文本方式有’\n’－－’\r\n’之间的转换，其存在转换耗时．二进制读写时，其不存在任何转换，直接将写缓冲区中数据写入文件．</p><p>总地来说，从编程的角度来说，Ｃ中文本或二进制读写都是缓冲区与文件中二进制流的交互，只是文本读写时有回车换行的转换．所以当写缓冲区中无换行符’\n’(0AH)，文本写与二进制写的结果是一样的，同理，当文件中不存在’\r\n’(0DH0AH)时，文本读与二进制读的结果一样．</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么 jdk 要按照操作系统和系统架构分类</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E4%B8%BA%E4%BB%80%E4%B9%88%20jdk%20%E8%A6%81%E6%8C%89%E7%85%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E7%B1%BB/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E4%B8%BA%E4%BB%80%E4%B9%88%20jdk%20%E8%A6%81%E6%8C%89%E7%85%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么-jdk-要按照操作系统和系统架构分类"><a href="#为什么-jdk-要按照操作系统和系统架构分类" class="headerlink" title="为什么 jdk 要按照操作系统和系统架构分类"></a>为什么 jdk 要按照操作系统和系统架构分类</h1><p>JDK 包括 JRE（Java 运行环境）和 Java 工具（编译器（javac.exe）、反编译工具（javap.exe）等），其中 JRE 又包含 Java 虚拟机 JVM（java.exe）和 java 基础类库。</p><p>上面提到的 jvm、编译器等等都是由 C&#x2F;C++实现的可执行文件。因此不同的操作系统其系统调用接口不同、基础库不同，这就决定了为不同操作系统编写的相关 java 工具的源码肯定有所不同，其次不同的 CPU 架构其指令集不同，这意味着即使源码相同的情况下编译出来的可执行文件（机器指令序列）也一定是不同的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>float和double的存储</title>
    <link href="/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20float%E5%92%8Cdouble%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <url>/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20float%E5%92%8Cdouble%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="float-和-double-的存储"><a href="#float-和-double-的存储" class="headerlink" title="float 和 double 的存储"></a>float 和 double 的存储</h1><h2 id="浮点数存储方式"><a href="#浮点数存储方式" class="headerlink" title="浮点数存储方式"></a>浮点数存储方式</h2><p>符号位+尾数+阶码的存储方式，符号位占 1bit 表示正负，尾数表示数值，阶码表示 2 的多少次方。对于一个非 0 的二进制小数，首先确定符号位，然后我们可以把它调整成 1.XXX 这种形式，去掉 1.后面就是尾数，超出的部分直接舍去，其次就是调整过程中乘的阶码，阶码可正可负，比如阶码有 8 位，就是-127 到 128。</p><h2 id="为什么会出现误差"><a href="#为什么会出现误差" class="headerlink" title="为什么会出现误差"></a>为什么会出现误差</h2><p>首先十进制整数和二进制整数是一一对应的，因此 long、int、short、byte 等只要不溢出是不会出现误差的。</p><p>而 float 和 double 会出现误差的原因是，大部分十进制有限小数在二进制中是无限小数，而浮点数在内存中是以尾数+阶码的方式保存的，有一定的精度范围，因此二进制无限小数会被截断从而损失精度，更进一步的，两个以尾数+阶码的方式存储的浮点数进行加减乘除运算的过程也可能出现精度之外的溢出。当然由于所有二进制的有限小数在十进制中都是有限小数，所以如果前面两个地方都没出现精度损失，那么运算结果作为二进制有限小数可以转化为十进制有限小数，这一步是不会出现误差的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是串流、推流、拉流</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B2%E6%B5%81%E3%80%81%E6%8E%A8%E6%B5%81%E3%80%81%E6%8B%89%E6%B5%81/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B2%E6%B5%81%E3%80%81%E6%8E%A8%E6%B5%81%E3%80%81%E6%8B%89%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是串流、推流、拉流"><a href="#什么是串流、推流、拉流" class="headerlink" title="什么是串流、推流、拉流"></a>什么是串流、推流、拉流</h1><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol><li><p>通过摄像头或录屏功能进行视频采集，视频的原始数据格式是一个个 RGB 帧或 YUV 帧，通过话筒进行音频采集，音频的原始数据格式是离散数据 PCM</p></li><li><p>将视频的原始数据格式（一个个 RGB 帧）进行编码（比如编码成 h.264 格式），将音频的原始数据格式（PCM）进行编码（比如编码成 AAC 格式），音视频编码的意义在于，在不损失音视频质量或一定的损失限度内尽可能地压缩数据量大小。</p></li><li><p>将编码后的视频数据、音频数据以及元数据组合为多媒体容器格式，多媒体容器格式有支持流媒体特性的和不支持流媒体特性的。支持流媒体特性的多媒体容器格式有 flv、ts 等，不支持流媒体特性的、面向存储的多媒体容器格式 avi、asf（wma&#x2F;wmv）、mp4、mkv、rmvb（rm&#x2F;ra）等。这里拿 mp4 举例，mp4 作为一个不支持流媒体特性的、面向存储的多媒体容器，mp4 视频文件只能丢给播放器进行解封装和解码，然后同步并播放，mp4 视频文件本身通过网络传输的话，它对于网络传输来说只是一个二进制文件，只能进行整个文件的传输，比如利用迅雷下载一个服务器上的电影，下载完整个 mp4 视频后可以丢给播放器播放。如果希望流式传输 mp4 视频，则需要先将其转换为支持流媒体特性的多媒体容器格式如 flv。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -re -i &quot;xxxx.mp4&quot; -vcodec libx264 -acodec aac -f flv rtmp://xxx.xxx.xxx.xxx:Xxx/xxxx<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-f flv表示将mp4容器格式转化为flv容器格式，rtmp协议只支持flv流媒体容器格式</span><br></code></pre></td></tr></table></figure><p>而对于支持流媒体特性的多媒体容器格式（如 flv），它们支持流媒体传输协议（如 rtmp 协议）从容器中取出一个个小的数据包，每个数据包里面可能只包括几帧的视频数据、对应的音频数据和元数据，并通过网络传输。常用的流传输协议有 RTSP、RTMP、HLS 等。</p></li><li><p>网络的另一端在收到一个个数据包进行前面的逆过程，解封装产生音视频数据和元数据、解码生成原始数据格式的视频（RGB 帧）和音频（PCM）、缓存、同步、播放，达到实时播放的效果。</p></li></ol><p><strong>可以看下这篇文章：</strong><a href="https://zhuanlan.zhihu.com/p/542144590">做直播，我们是认真的：Web 音视频串流与 WebRTC - 知乎 (zhihu.com)</a></p><h4 id="推流与拉流（都是串流）"><a href="#推流与拉流（都是串流）" class="headerlink" title="推流与拉流（都是串流）"></a>推流与拉流（都是串流）</h4><p><strong>推流：</strong>将视频文件或者实时录制的视频数据按照特定的支持流媒体特性的多媒体容器格式以及特定的流媒体传输协议，流式推送到服务器或网络的另一端。</p><p><strong>拉流：</strong>请求服务器发送服务器上缓存的某个实时视频流数据（从推流端的容器中实时取出的一个个小的数据包），即流式地拉取，实时地播放。</p><p><strong>在直播业务中为什么主播会推流到流媒体服务器而不是直接推流到观看用户的客户端：</strong>因为主播端的推流设备无法高并发地响应成千上万用户的拉流请求，而推到流媒体服务器后，服务器是具有这种能力的，另外流媒体服务器还具有转码、录制回放、监管鉴黄等功能。</p><p><img src="D:\Desktop\Dasi\Yan0\图片\什么是串流、推流、拉流-p2.png"></p><p><img src="D:\Desktop\Dasi\Yan0\图片\什么是串流、推流、拉流-p1.png"></p><h4 id="点播与组播"><a href="#点播与组播" class="headerlink" title="点播与组播"></a>点播与组播</h4><p>点播：通过优酷观看视频，流式传输的是流媒体服务器上的视频</p><p>组播：通过斗鱼观看直播，流式传输的是流媒体服务器上缓存的某主播的实时视频数据</p><h4 id="网络流媒体协议的联系与区别"><a href="#网络流媒体协议的联系与区别" class="headerlink" title="网络流媒体协议的联系与区别"></a>网络流媒体协议的联系与区别</h4><p><img src="D:\Desktop\Dasi\Yan0\图片\什么是串流、推流、拉流-p3.png"></p><p><strong>主要看下面这篇文章：</strong></p><p><a href="https://blog.csdn.net/yinshipin007/article/details/126752517">(110 条消息) 网络流媒体协议的联系与区别(RTP RTCP RTSP RTMP HLS)_音视频开发老马的博客-CSDN 博客_流媒体协议对比</a></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://blog.csdn.net/weixin_44299027/article/details/122711869">(110 条消息) 【流媒体】推流与拉流简介_No8g 攻城狮的博客-CSDN 博客_推流和拉流</a></p><p><a href="https://www.zhihu.com/question/359315470/answer/922995305?ivk_sa=1024320u">(10 封私信 &#x2F; 80 条消息) 什么是串流（Streaming）？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_30795127/article/details/97887249">(110 条消息) 多媒体容器格式概述 ①_weixin_30795127 的博客-CSDN 博客</a></p><p><a href="https://baijiahao.baidu.com/s?id=1648291079053253824&wfr=spider&for=pc">多媒体容器格式的变迁，体现着我们对美好事物的不断追求 (baidu.com)</a></p><p><a href="https://www.zhihu.com/question/447381364/answer/2823303501?utm_id=0">(10 封私信 &#x2F; 80 条消息) 直播间如何搭建？ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是dll文件、lib文件</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E4%BB%80%E4%B9%88%E6%98%AFdll%E6%96%87%E4%BB%B6%E3%80%81lib%E6%96%87%E4%BB%B6/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20%E4%BB%80%E4%B9%88%E6%98%AFdll%E6%96%87%E4%BB%B6%E3%80%81lib%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-dll-文件、lib-文件"><a href="#什么是-dll-文件、lib-文件" class="headerlink" title="什么是 dll 文件、lib 文件"></a>什么是 dll 文件、lib 文件</h1><p><strong>DLL（Dynamic Link Library，动态链接库）</strong>，在 Windows 系统中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，也就是 DLL 文件，放置于系统中。当我们执行某一个程序时，相应的 DLL 文件就会被调用。一个应用程序可有多个 DLL 文件，一个 DLL 文件也可能被几个应用程序所共用，这样的 DLL 文件被称为共享 DLL 文件。<strong>DLL 文件一般被存放在 C:\Windows\System 目录下。</strong></p><p>例如，在 Windows 操作系统中，Comdlg32 DLL 执行与对话框有关的常见函数。因此，每个程序都可以使用该 DLL 中包含的功能来实现“打开”对话框。这有助于促进代码重用和内存的有效使用。</p><p><strong>通过使用 DLL，程序可以实现模块化，由相对独立的组件组成。</strong>例如，一个计帐程序可以按模块来销售。可以在运行时将各个模块加载到主程序中（如果安装了相应模块）。因为模块是彼此独立的，所以程序的加载速度更快，而且模块只在相应的功能被请求时才加载。</p><p>此外，可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。例如，您可能具有一个工资计算程序，而税率每年都会更改。当这些更改被隔离到 DLL 中以后，您无需重新生成或安装整个程序就可以应用更新。</p><h3 id="程序使用-DLL-的优点"><a href="#程序使用-DLL-的优点" class="headerlink" title="程序使用 DLL 的优点"></a>程序使用 DLL 的优点</h3><p><strong>1、使用较少的资源</strong></p><p>当多个程序使用同一个函数库时，DLL 可以减少在磁盘和物理内存中加载的代码的重复量。这不仅可以大大影响在前台运行的程序，而且可以大大影响其他在 Windows 操作系统上运行的程序。</p><p><strong>2、推广模块式体系结构</strong></p><p>DLL 有助于促进模块式程序的开发。这可以帮助您开发要求提供多个语言版本的大型程序或要求具有模块式体系结构的程序。模块式程序的一个示例是具有多个可以在运行时动态加载的模块的计帐程序。</p><p><strong>3、简化部署和安装</strong></p><p>当 DLL 中的函数需要更新或修复时，部署和安装 DLL 不要求重新建立程序与该 DLL 的链接。此外，如果多个程序使用同一个 DLL，那么多个程序都将从该更新或修复中获益。当您使用定期更新或修复的第三方 DLL 时，此问题可能会更频繁地出现。</p><p>我最近在 github 上下载了一个项目，需要配到 fftw 的第三方库，可是看到一堆 dll 文件，lib 文件，def 文件，头都晕了，不知道这些东西是什么，怎么用，下面就我查询的资料做一个小结。</p><p>据说，出现.lib .dll 这种文件的原因是为了保护源代码，这个以后机会我做个详细的查询，再写一篇文章，这里不做细述。</p><p>用 OpenCV 的开源库来举个例子看一下就知道了：</p><p>bin 文件夹里面放的都是 dll 文件；</p><p>lib 文件夹里面放的都是伴随 dll 文件的动态 lib 文件；</p><p>staticlib 文件夹里面放的才是真正的静态 lib 文件，和 dll 文件是独立的；</p><p>所以可以看出，lib 文件是有静态 lib 和动态 llib 之分的。</p><h2 id="第一部分：静态-lib-文件，动态-lib-文件和-dll-文件的区别："><a href="#第一部分：静态-lib-文件，动态-lib-文件和-dll-文件的区别：" class="headerlink" title="第一部分：静态 lib 文件，动态 lib 文件和 dll 文件的区别："></a>第一部分：静态 lib 文件，动态 lib 文件和 dll 文件的区别：</h2><h3 id="1-静态-lib-文件"><a href="#1-静态-lib-文件" class="headerlink" title="1. 静态 lib 文件"></a>1. 静态 lib 文件</h3><p><a href="https://blog.csdn.net/woainishifu/article/details/53445535">这篇文章(点我点我 o((&gt;ω&lt; ))o)</a>讲过如何生成并调用 lib 文件，其实那个使用“static Library”选项生成的 lib 文件就是静态 lib 文件。我们已经知道，在调用这种类型的 lib 文件的时候，只需要配置好头文件.h 的路径和库文件.lib 的路径，自己的程序就可以正确加载这些第三方代码为自己所用。这是因为：</p><p>静态 lib 文件实际上就是任意个 obj 文件的集合，而 obj 文件就是 cpp 文件编译之后产生的一种文件，一个 cpp 文件编译之后只会产生一个 obj 文件，而多个 obj 文件就可以连接生成 lib 文件。就像上一篇文章讲的那样，如果你工程里只有一个 lib.h 和 lib.cpp，那么编译后产生的 lib 文件实际上就是 lib.obj 文件的一个集合，但是如果你工程里还有其他的很多个 cpp 文件，那么就会在编译之后生成许多 obj 文件，然后最终只链接生成一个 lib 文件。</p><p>所以，<strong>静态 lib 文件实际上是包含了所有的导出声明和实现。你如果把这个 lib 文件链接到自己的程序之后，这个 lib 文件中的所有代码都会嵌入进来，哪怕你只用到了其中一部分，剩下没用到的也进了你的代码。</strong>这就不难想象会造成的后果了，虽然方便，但是如果大部分你都用不到，自然会导致你的库体积没有意义地变大，失去了使用动态库的灵活性，而且发布新的版本时必须要发布新的应用程序才行，而不是简单打个补丁就好。就是因为这种缺点，才会出现动态 dll 调用这种方式。（注：这世上所有事情的出现都是有理由的，如果静态 lib 能完成我们想要的功能，而没有缺点的话，就不会有第二种替代方案 dll 的出现！）</p><h3 id="2-动态-lib-文件和-dll-文件"><a href="#2-动态-lib-文件和-dll-文件" class="headerlink" title="2. 动态 lib 文件和 dll 文件"></a>2. 动态 lib 文件和 dll 文件</h3><p>把这两个放在一起来说，是因为一个 dll 工程生成一个 dll 文件的时候，总是伴随着生成一个 lib 文件，这个 lib 文件其实是一个动态的 lib，它的大小比静态 lib 要小很多，因为这个 lib 文件其实只是包含了一些函数索引信息，记录了 dll 中那些函数的入口和位置，dll 中才是具体的函数实现。那么为什么有了 dll，还要有一个 lib 呢？</p><p>这就是动态库链接的过程了，首先配置好动态 lib 库目录和动态 dll 目录，以及头文件的目录。（注：如何配置这些路径，请看我的下一篇文章）然后在你的代码中 include 用到的头文件，代码完成之后有两个过程：（1）编译：这个过程只需要用到这里的动态 lib 文件<strong>【注：在静态 lib 的情况下，仍然只是在编译阶段用到 lib 文件，只不过静态 lib 文件包含了完整的实现，所以编译生成 exe 之后就可以直接用了而已】</strong>，然后和你的代码打包到一起。（2）运行：这个过程就需要用到 dll 文件了，上面打包好的东西里面，只是记录下了那些用到的函数的入口和具体位置，并没有真正的实现代码，所以在运行期间，就由那些入口找到正确的位于 dll 中的位置，然后直接执行那些函数就行了。</p><p>从上面过程中也可以看出一个很清楚的事实：<strong>dll 其实就是 exe，只不过它没有 main 函数，所以不能单独执行而已。</strong>事实上， 在实际的使用过程中我们也发现，很多应用程序都并不是一个完整的单独可执行文件，它们被分割成一些单独的相对对立的动态链接库，只有在执行应用程序的时候，用到的 dll 才会被调用。这也就是为什么你经常打开某些程序，会出现“无法加载 XXX.dll”的原因了(<strong>我在这里栽了很多坑啊，其实就是 dll 文件的原因</strong>) (：冷漠.jpg</p><h2 id="第二部分：静态-lib-和动态-dll-使用注意事项"><a href="#第二部分：静态-lib-和动态-dll-使用注意事项" class="headerlink" title="第二部分：静态 lib 和动态 dll 使用注意事项"></a>第二部分：静态 lib 和动态 dll 使用注意事项</h2><p>通过第一部分的叙述，我们可以总结如下：</p><h3 id="1-调用静态-lib-库，需要用到的文件是："><a href="#1-调用静态-lib-库，需要用到的文件是：" class="headerlink" title="1. 调用静态 lib 库，需要用到的文件是："></a>1. 调用静态 lib 库，需要用到的文件是：</h3><p>（1）.h 文件，包含函数的声明，数据结构等东西，在调用 lib 的时候，需要把该头文件包含进你的代码；</p><p>（2）.lib 文件，包含具体的实现。</p><h3 id="2-调用动态-dll-库，需要用到的文件是："><a href="#2-调用动态-dll-库，需要用到的文件是：" class="headerlink" title="2. 调用动态 dll 库，需要用到的文件是："></a>2. 调用动态 dll 库，需要用到的文件是：</h3><p>\1. .h 文件，如上，同样需要包含到你的代码；<br>\2. .lib 文件，包含一些函数的入口和具体位置，必须在编译阶段引入这个文件，否则会报错。【根据查到的资料，如果没有这个动态 lib 文件或者不想用 lib 文件，需要用 Win32 的 API 函数 LoadLibrary 和 GetProcAddress 来装载】<br>\3. .dll 文件，实际的实现，在程序运行时动态调用。（3）.dll 文件，实际的实现，在程序运行时动态调用。</p><p><strong>正常情况下，你发行一个软件的过程应该是这样的：（选用第二种动态调用 dll 的方式）</strong></p><p>你的项目分成独立的几个模块，每个模块都有一个 dll 文件，然后有一个最终的程序入口 exe 文件，最后把 dll 文件和 exe 文件发行给用户。当用户每次点击这个 exe 文件的时候，自然会动态调用用到的 dll 文件。注意这个过程就不再需要什么.h 和.lib 了，那是别人调用你的库，再进行加工写代码时才需要做的事。上面说过 dll 其实就是个不能单独打开执行的 exe 而已，所以你最终发行给用户的只能是 dll 和 exe，当然你完全可以把所有的东西只打包在一个 exe 中。但是当你的软件非常大的时候，这样进行更新维护就非常不方便，如果有问题就得重新发行一次 exe，但是如果把各个模块单独弄成 dll，你只需要打个补丁，对那些有问题的 dll 进行更换就行了。</p><p>另外一个是把你的 dll 写好给别人拿来调用，以免别人做重复的工作。这个时候你刚开始提供的时候，就需要把.h 文件，.lib 文件，.dll 文件都提供给对方，然后如果你代码里面有改动，只需要重新编译一次 dll 给对方，替换掉原来的 dll 就可以了，非常方便！！！当然前提是，你的函数接口写得好。进行修改时只需要修改内部实际的代码，并不需要对接口改来改去！</p><p><strong>def 文件用于确定函数的导出名称,这会在链接的时候用到</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="/notes/2023/10/29/%E6%80%BB%E7%BB%93%E7%AF%87%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/notes/2023/10/29/%E6%80%BB%E7%BB%93%E7%AF%87%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络笔记"><a href="#计算机网络笔记" class="headerlink" title="计算机网络笔记"></a>计算机网络笔记</h1><h4 id="第一章概述"><a href="#第一章概述" class="headerlink" title="第一章概述"></a>第一章概述</h4><p>网络中的节点可以是计算机、集线器、交换机或路由器。</p><p>网络把许多计算机连接在一起，而互连网（internet）则把许多网络通过一些路由器连接在一起，是网络的网络。</p><p>互联网（Internet）不同于 internet，指的是当前全球最大的、最开放的特定互连网，它采用 TCP&#x2F;IP 协议族作为通信规则。</p><p>互连网服务提供者 ISP 可以向 IP 地址管理机构申请整块的 IP 地址，并且 ISP 拥有自己的通信线路和路由器等连网设备，任何机构或个人只要向某个 ISP 交纳规定的费用，就可以从该 ISP 获取所需 IP 地址的租用权，并可以通过此 ISP 接入互联网。</p><p>计算机之间的通信实际上指的是两个主机的进程之间的通信。</p><p>相比于电路交换机制（在通信过程中始终占用端到端的通信资源），计算机网络采用分组交换机制（存储转发技术），分组交换机制的最大好处是提高了网络占用率和路线选择的灵活性，而存储转发技术的好处在于既不轻易丢弃分组，又争取以最快的方式把到达的分组转移出去，至于转移给谁则由维护的转发表决定。</p><p>计算机网络性能指标：速率&#x2F;数据率、带宽、吞吐量、时延（发送时延+传播时延+处理时延+排队时延）、往返时间 RRT、利用率。带宽和吞吐量是一个意思，都指的是每秒传输数据量的大小，然而实际带宽&#x2F;吞吐量和有效带宽&#x2F;吞吐量是有区别的，实际带宽&#x2F;吞吐量指的是信道实际每秒传输数据量的大小，有效带宽&#x2F;吞吐量指的是每秒传输有效数据量的大小。对于 UDP 来说，造成有效带宽&#x2F;吞吐量小于实际带宽&#x2F;吞吐量的因素包括：协议头的损耗、不可避免的丢包损耗。对于 TCP 来说，造成有效带宽&#x2F;吞吐量小于实际带宽&#x2F;吞吐量的因素包括：协议头的损耗、重传的损耗、拥塞控制算法的慢启动带来的损耗。</p><p>网络协议主要有三个要素：语法（数据与控制信息的结构或格式）、语义（对于不同的控制信息要完成何种动作或做出何种响应）、同步（约定事件的实现顺序）。</p><p>在计算机网络体系结构中，每一层都需要基于下层提供的服务，设计本层协议完成一些功能，并向上层提供更好的服务。</p><p>互联网的重要设计理念：网络核心部分越简单越好（最多负责到 IP 层），把一切复杂的部分让网络的边缘部分去实现。</p><p>下面是一个简单架构概述：</p><p>应用层（HTTP）：HTTP 分组给到下层发送缓冲区，被完整发到对面后再给到上层。因此可以看作 HTTP 分组发出，过一会，对面可靠地收到。</p><p>运输层（TCP）：提供网络中任意两台主机间的任意两个进程&#x2F;线程间的可靠字节流传输。上层下来的应用层分组放入发送缓冲区字节流的末尾，确定发送窗口大小，把发送窗口内的比特流分片并组装成 TCP 报文段，交给下层，TCP 报文段是网络中任意两台主机间的任意两个进程&#x2F;线程间的不可靠分组传输。重传时间到后，发送缓冲区字节流的头部被确认的一段字节流被丢掉，调整发送窗口长度，把发送窗口内的比特流分片并组装成 TCP 报文段交给下层，依次重复。因此可以看作字节流是一段一段地可靠传输传输给对方的。</p><p>网络层：提供网络中任意两台主机间的不可靠 IP 数据报传输。具体是根据 IP 数据报首部的目的 IP 查询路由表得到下一跳，然后把 IP 数据报和 MAC 地址给到下层（下层的点到点传输也可能因为出现比特差错而丢掉），IP 数据报一跳一跳最终到达另一台主机，取出 IP 数据报的数据部分（也就是 TCP 报文段），根据 TCP 报文段首部的目标 port 给予这个端口绑定的相应进程。但是 IP 数据报的传输是不可靠的，在途中可能出现比特差错（网卡给到内存的期间）、丢失（分组转发时排队被丢弃、在数据链路层因为检错被丢弃等）、重复、失序（后发的 IP 数据报先到）。</p><p>数据链路层：提供两点间（两点直连&#x2F;两点位于同一个局域网内）的无比特差错以太网帧传输。具体来讲，对于两点直连是将 IP 数据报加入首部和尾部封装成帧，将一个个帧组装成比特流交付物理层，另一端收到比特流后分帧，进行差错检测后将 IP 数据报交付上层，这种情况下以太网帧的首部和尾部的作用主要是分帧和检错。对于两点位于同一个局域网内的情况，局域网内所有网卡都会收到比特流，它们在分帧后会检查以太网帧首部的 MAC 地址是不是自己，不是自己则会丢弃，是自己才会进行差错检测后将 IP 数据报交付上层，这种情况下以太网帧的首部和尾部的作用主要是分帧、检错以及保存 MAC 地址。</p><p>物理层：提供物理链路两端的有损比特流传输。具体是将比特流转换成数字信号，经过调制器将数字信息调制到载波上生成模拟信号，传输到另一端，模拟信号经过解调器恢复出数字信号，最后转换为比特流。</p><h4 id="第二章物理层"><a href="#第二章物理层" class="headerlink" title="第二章物理层"></a>第二章物理层</h4><p>物理层作用：将比特流转换成数字信号，经过调制器将数字信息调制到载波上生成模拟信号，传输到另一端，模拟信号经过解调器恢复出数字信号，最后转换为比特流。对数据链路层提供的服务是：提供物理链路两端的有损比特流传输。</p><p>通信的目的是传送消息（如话音、文字、图像等），数据是运送消息的实体，信号则是数据的电气或电磁体现。</p><p>信噪比定义：信号的平均功率与噪声的平均功率之比</p><p>单工（单向通信）、半双工（双向交替通信）、全双工（双向同时通信）</p><p>物理传输媒体：</p><ul><li>导引型传输媒体：电缆、光缆</li><li>非导引型传输媒体：无线传输</li></ul><p>信道中的频分复用和时分复用</p><h4 id="第三章数据链路层"><a href="#第三章数据链路层" class="headerlink" title="第三章数据链路层"></a>第三章数据链路层</h4><p>数据链路层作用：将 IP 数据报加入首部和尾部封装成帧，将一个个帧组装成比特流交付物理层，另一端收到比特流后分帧，进行差错检测后将 IP 数据报交付上层。对网络层提供的服务是：在物理层提供物理链路两端的有损比特流传输的基础上，对于两点（无论是点对点（点对点信道），还是以太网&#x2F;局域网中的两点（广播信道），在以太网中无论是集线器的结构还是以太网交换机的结构），都可以选择对应的数据链路层协议，向上层提供两点间的无比特差错的分组传输服务。</p><p>数据链路层使用的信道主要有两种类型：点对点信道和广播信道。这个信道可以理解为物理层给数据链路层提供的传输有损比特流的抽象信道，也可以理解为物理层的实际信道（缆线），这两个是对应的。</p><p>局域网属于数据链路层的范围，因为局域网关注的是在同一局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器的转发，而网络层关注的是网络互连问题，即分组怎样从一个网络经过路由器转发到另一个网络。</p><p>一般的网络适配器（既有硬件，也有软件），包括了数据链路层和物理层这两层的功能。</p><p>数据链路层要解决的三个基本问题：</p><ol><li>封装成帧：帧首部和帧尾部分别加入帧定界符（帧开始符“SOH”，帧结束符“EOT”），所能传送的帧的数据部分长度上限——最大传送单元 MTU，注意 IP 数据报的长度如果超过 MTU 就会被分片，而 IP 数据报自身最大长度限制是 65535 字节，因此上层给下来的 TCP 报文段最长不能超过（65535-20 首部）字节。</li><li>透明传输：透明传输指的是“无论什么样的比特组合数据，都能够按照原样没有差错地通过这个数据链路层”，这里我们通过转义字符“ESC”解决了数据部分出现帧定界符的问题（利用转义字符的二义性功能）。</li><li>差错检测：在帧首部或帧尾部加入冗余码（帧检验序列 FCS），使用循环冗余检验 CRC 检错技术，对接收端收到的每一帧进行检测，如果没有差错就接受，有差错就丢弃。</li></ol><p>注意数据链路层只实现了无比特差错传输，但这还不是可靠传输，所谓“可靠传输”就是“发送端发送什么，接收端就收到什么”，而传输差错可以分为两大类，一类是比特差错，一类是传输差错，包含帧丢失、帧重复和帧失序。数据链路层和网络层的不可靠交付是由更高层的确认重传机制（比如 TCP）来解决的，但站在这两层的角度，它们并不知道这是重传帧，而是当作新的数据帧来发送。</p><p>如果要求数据链路层向上提供可靠传输，则需要在 CRC 检错的基础上增加帧编号、确认重传机制，现在一般只有在通信质量较差时才需要数据链路层可靠传输。</p><p>点对点信道协议 PPP 协议</p><p>PPP 协议是用户计算机与 ISP 进行通信所使用的数据链路层协议，PPP 协议满足数据链路层的三个基本问题，并且不提供比 IP 协议更多的功能（不需要纠错，不需要序号，不需要流量控制），提供比上层 IP 协议更多的功能没有意义，因为最后都会被 IP 层覆盖。</p><p>PPP 协议包含三个组成部分：一个将 IP 数据报封装成帧的方法、一个链路控制协议 LCP、一个网络控制协议 NCP。</p><p>局域网（又名以太网）的拓扑分为：星形网、环形网、总线网</p><p>适配器（又称网卡）是计算机主机（包括路由器）上负责处理物理层和数据链路层的设备，适配器上装有自己的处理器和存储器，对外（局域网）以电缆串行方式传输，对内（计算机）以主板总线 I&#x2F;O 并行方式传输。具体过程如下：在发送端适配器接收计算机传过来的 IP 数据报，采用相应的数据链路层协议封装成帧，一个个帧连成比特流，比特流转化为数字信号，经过调制后发送。在接收端首先进行解调生成数字信号，转换为比特流，根据相应协议进行分帧，进行差错检测等过程后将 IP 数据报上交给计算机。</p><p>计算机的硬件地址就在适配器的存储 ROM 中，而计算机的软件地址则在计算机的存储器中。</p><p>广播信道协议 CSMA&#x2F;CD 协议</p><p>总线的特点是当一台计算机发送数据时，总线上所有的计算机都能检测到这个数据，而 MAC 地址正是用于标记目的地址与源地址以实现总线上的一对一通信。</p><p>CSMA&#x2F;CD 协议控制物理层：不停地监听信道，如果信道保持空闲就开始发送帧并持续监听信道，若在争用期内一直未检测到碰撞在可以放心发送完这个帧，否则立刻停止发送数据，等待一段时间后再次循环。</p><p>集线器工作在物理层，它的每个端口仅仅转发比特，因此以集线器为中心的星形以太网本质上仍然是一个总线结构。</p><p>三种以太网帧：</p><ul><li>单播帧：一对一</li><li>多播帧：一对多</li><li>广播帧：一对全体</li></ul><p>可以说 CSMA&#x2F;CD 协议保证了同一时间总线上只有一个计算机在发送以太网帧，MAC 地址保证了以太网帧的接收，两者共同实现了总线上点对点的有损比特流通信，接下来需要设计以太网帧实现数据链路层的基本功能即可。</p><p>网桥工作在数据链路层，可以对收到的帧根据其目的 MAC 地址进行转发和过滤，以太网交换机实质是一个多端口网桥，它的每一个端口都直接与一个单台主机或另一个以太网交换机相连，且一般都工作在全双工，以太网交换机还具有并行性，能同时连接多对端口，使多对主机能同时通信。</p><p>交换式以太网相比于共享总线以太网的优点是从一个总线碰撞域扩展到 N 个端口碰撞域，同一时间可以有多个计算机发送比特流，并且比特流只会朝着目标 MAC 地址的线路传输。</p><p>以太网交换机根据发过来的以太网帧的源 MAC 和端口维护交换表，并在交换表中查不到该往哪个端口转发时采用广播方式。</p><h4 id="第四章网络层"><a href="#第四章网络层" class="headerlink" title="第四章网络层"></a>第四章网络层</h4><p>网络层作用：对运输层提供的服务是：在数据链路层提供两点（直接连接或处在同一个以太网中的计算机或路由器）间的无比特差错分组传输服务的基础上，通过根据目的 IP 选择下一跳路由器&#x2F;计算机的功能，向运输层提供互联网任意两端点（任意计算机或路由器）间的不可靠分组传输服务（不可靠是指既有可能出现比特差错，也有可能出现传输差错）。</p><p>网络层要设计得尽量简单，向其上层只提供简单灵活的、无连接的、尽最大努力交付的数据报服务，网络层不提供服务质量的承诺，所传送的分组可能丢失、重复和失序。</p><p>网际协议 IP（Internet Protocal）是 TCP&#x2F;IP 体系中两个最重要的协议之一，与 IP 协议配套使用的还有三个协议：地址解析协议 ARP、网际控制报文协议 ICMP、网际组管理协议 IGMP。</p><p>网络层分组在传送途中的每一次转发都成为一“跳（hop）”，每一跳两端的两个节点都必定直接连接在同一个网络上，即位于同一个以太网内或两个节点直接连接。</p><p>IP 地址就是给连接到互联网上的每一台主机（或路由器）的每一个接口，分配一个在全世界范围内是唯一的 32 位的标识符，IP 地址&#x3D;&lt;网络号&gt;+&lt;主机号&gt;。</p><p>分类 IP 地址：A 类地址、B 类地址、C 类地址、D 类地址、E 类地址</p><p>127.0.0.1 被保留作为本地软件环回测试本主机的进程之间的通信之用，若主机发送一个目的地址为环回地址（如 127.0.0.1）的 IP 数据报，则主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。</p><p>全 0 和全 1 的主机号一般不指派，全 0 表示“网络地址”，全 1 表示该网络上的所有主机。</p><p>无分类编址 CIDR：CIDR 和传统 IP 分配最大的区别就是网络前缀的位数不再是固定的数，尽管并不会改变 IPV4 的 IP 数量，但 CIDR 能提供更大的灵活性。举个例子，在 CIDR 中，128.14.32.0&#x2F;19 和 128.14.32.0&#x2F;21 都是有效的网络地址，且指的是同一个主机的同一个端口的 IP 地址，但是两者的含义不同，前者的网络前缀位数少，说明是一个更大的网络，而后面的网络前缀位数多两位，说明是前面 19 位网络下的一个 21 位细分网络。</p><p>地址掩码只是用来方便计算机通过按位与运算计算网络前缀的。</p><p>IP 地址管理机构在分配 IP 地址时只分配网络前缀，而剩下的主机号由得到该网络前缀的单位自行分配。</p><p>IP 地址是标志一台主机（或路由器）和一条链路的接口，当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络前缀必须是不同的。</p><p>一个网络是具有相同网络前缀的主机的集合，用转发器或交换机连接起来的若干个局域网仍可认为是一个网络，是一个更大的局域网，具有相同的网络前缀，具有不同网络前缀的局域网必须使用路由器进行互连。</p><p>当两个路由器直接相连时（点对点信道），两个端口分不分配 IP 地址均可。</p><p>IP 数据报在转发过程中的源 IP 地址和目的 IP 地址始终保持不变，而对应的 MAC 帧中的源 MAC 地址和目的 MAC 地址是不断变化的，路由器只会根据目的 IP 地址进行转发。</p><p>地址解析协议 ARP：已经知道了局域网内的某个计算机（或路由器）的 IP 地址，需要找出其相应的 MAC 地址。ARP 协议主要使用广播+高速缓存+生存时间的方式，当主机 A 要想本局域网上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址，如果有就能查出对应的 MAC 地址，如果查不到就局域网广播“我的 IP 是 XXX，MAC 是 XXX，我想知道 IP 为 XXX 的主机的 MAC 地址”，主机 B 在收到后单播回响应分组，A、B 主机都以一定的生存时间缓存 IP-MAC 对应信息。</p><p>注意当 IP 数据报的总长度超过数据链路层设置的最大传输单元 MTU 时，需要进行分片，即将 IP 数据报的数据部分分成好几片，分别加上首部组成多个小的 IP 数据报，在接收端的网络层再对分片进行拼接。</p><p>IP 数据报首部格式中的首部检验和只负责 IP 数据报的首部检验，之所以在数据链路层提供 CRC 的基础上还需在网络层进行检验的目的是，考虑 MAC 帧和 IP 数据报的互相转换过程（从数据链路层到网络层，从网卡到内存）可能带来的比特差错。</p><p>转发表的形式：最长前缀匹配。</p><p>加速查找转发表的方法：唯一前缀+二叉线索树</p><p>网络层的网际控制报文协议 ICMP，ICMP 报文整体作为 IP 数据报的数据部分发送，允许主机或路由器报告差错情况和提供有关异常情况的报告，ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通性，PING 是应用层直接使用网络层 ICMP 的一个例子，它没有通过运输层的 TCP 或 UDP。</p><p>IPV6 有 128 位，例：68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF</p><p>IPV4 向 IPV6 过渡：要么路由器支持双协议栈，要么采用隧道技术，即将 IPV6 数据报作为 IPV4 数据报的数据部分进行传输。</p><p>路由选择协议需要保证最终一定能到达+选出的整体路径尽可能好，路由选择协议包括内部网关协议和外部网关协议，内部网关协议作用于整个自治系统内部，外部网关协议作用于所有自治系统之间，所谓自治系统指的是在单一技术管理下的许多网络、IP 地址以及路由器。</p><p>内部网关协议 RIP：适用于小型网络，能找到两点间跳数最少的路径，采用的方法是相邻路由器不断交换当前本路由器所知道的全部信息直至收敛，特点是坏消息传播慢好消息传播快。</p><p>内部网关协议 OSPF：适用于大型网络，每个路由器都使用泛洪法向本自治系统中所有其他路由器发送本路由器和相邻所有路由器的“度量”，这个“度量”可以是费用、距离、时延、带宽等等。这样每个路由器都知道了整个自治系统的拓扑信息，利用 Dijkstra 可以得到自己的路由表。</p><p>外部网关协议 BGP：一个自治系统中的路由器要到达另一个自治系统中的路由器，中间可能经过多个自治系统，由于不同自治系统采取不同的 IGP 协议，有着不同的线路质量衡量方式，因此 BGP 协议无法简单地以线路质量在多个自治系统间选择路由，只要求满足可达性即可，具体 BGP 协议过程参考 P171。</p><p>路由器的结构：路由器有多个输入端口用于接收，多个输出端口用于发送，每个端口都需要网络适配器进行物理层和数据链路层的处理，且无论输出端口还是输入端口都设有 IP 数据报的缓存区，一旦满了就会将后来的 IP 数据报丢弃，产生溢出。</p><p>IP 多播：在一对多通信中，多播相比于单播可以大大节约网络资源，互联网范围内的多播要靠多播路由器来实现，多播路由器可以识别多播数据报（当然也可以转发普通的单播 IP 数据报），IPV4 地址中的所有 D 类地址被划分为多播组标识符，所有多播数据报的目的地址写入的就是多播组标识符，一个计算机如果参加了某个多播组，那么它既有自己的 IP 地址也有自己的多播组标识符。IP 多播需要两种协议，第一种是 IGMP 协议，作用是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组，这样才可以进行局域网内的多播交付。第二种是多播路由选择协议，目的是针对多播 IP 数据报进行路由选择。</p><p>如果要设置一个不接入公网的本地网络，那么 IP 理论上是可以自己分配的，但是一旦这个本地网络中有路由器通过 ISP 接入了公网，随意分配的本地 IP 和公网 IP 就会产生二义性问题，因此我们规定了 IPV4 中的三个地址块只能用于本地 IP 地址，在互联网中的所有路由器，对目的地址是本地地址的 IP 数据报一律不进行转发。显然，全世界可能有很多本地互联网具有相同的 IP 地址，但这并不会引起麻烦，因为这些本地地址仅在本机构内部使用。</p><p>虚拟专用网 VPN 可以让分隔世界两地的两个局域网拥有相同的网络前缀，并且在使用时就像是同一个子网，另一种远程接入 VPN 允许用户计算机在远端通过互联网接入公司的子网，，VPN 主要用到隧道技术，具体见 P187。</p><p>网络地址转换 NAT：一个本地局域网要和外部通信，可以采用本地局域网全部分配公网 IP 的方式，也可以采用全部分配本地 IP+NAT 的方式，后者只需要局域网中有一个装有 NAT 软件的路由器，并且路由器的对外端口分配了公网 IP 即可。注意普通路由器在转发分组时是工作在网络层的，而 NAT 路由器还需要查看和转换运输层的端口号。具体见 P188。IP 数据报的首部只包含源 IP 和目的 IP，UDP 数据报和 TCP 报文段的首部才包含源端口和目的端口。</p><h4 id="第五章运输层"><a href="#第五章运输层" class="headerlink" title="第五章运输层"></a>第五章运输层</h4><p>运输层作用：对应用层提供的服务是：在网络层提供网络中任意两主机间的不可靠 IP 数据报传输的基础上，使用不同的协议，可以向上层提供网络中任意两主机的任意两进程&#x2F;线程间的可靠 TCP 字节流传输&#x2F;不可靠 UDP 数据报分组传输。</p><p>在应用层和运输层之间的界面上，设置了一些本计算机应用层中的各进程在和运输层交互时的层间接口。当应用层要发送数据时，应用进程就把数据发送到适当的端口，然后运输层从该端口读取数据，当运输层收到对方主机发来的数据时，就把数据发送到适当的端口，然后应用进程就从该端口读取这些数据。</p><p>端口号分为：服务器端使用的端口号（最主要是熟知端口号），客户端使用的端口号</p><p>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能，差错检测范围是整个 UDP 数据报。</p><p>UDP 是无连接的、尽最大努力交付的、面向报文的（不会对应用层下来的分组进行分片，而是一整个打包成 UDP 数据报）、没有拥塞控制、支持一对多。</p><p>TCP 是面向连接的、点对点的、可靠交付的、全双工通信的、面向字节流的。</p><p>利用自动重传请求 ARQ，可以在不可靠的传输网络上实现可靠的通信。具体来讲，发送端只有在接收到确认分组后才会进行下一个分组的发送，因为发送端接收到确认分组说明接收端一定在某一时刻收到了正确的分组，而一定时间内发送端没有收到确认分组就会进行分组的重传，这里没有收到确认分组的原因可能是分组发送过程中出现丢失&#x2F;出错&#x2F;拥塞中，也可能是确认分组返回的过程中出现丢失&#x2F;出错&#x2F;拥塞中，但无论哪种情况，重传都有助于发送端尽快收到确认分组以便进行下一分组的传输。</p><p>连续 ARQ 用来解决 ARQ 的信道利用率低的问题，发送窗口中的所有分组都会被依次发送，接收端的确认分组会告诉发送端截止到哪个分组之前的分组都接收到，发送窗口滑动，如果超时没有收到确认，将会对发送窗口所有分组进行重传。连续 ARQ 的可靠通信可以抽象地理解为：发送端发送几个连续分组，过一会接收端接收到了，过了一会发送端发送后面的几个连续分组，以此类推。</p><p>TCP 可靠传输的实现是把连续 ARQ 中的分组变成了字节流，它的发送窗口长度以字节为单位，但是具体发送过程是取出一些字节，分片后加入首部组成 TCP 报文段并交由网络层发送，其次 TCP 可靠传输的实现还多出了发送缓存和接收缓存。TCP 可靠传输可以抽象地理解为：发送端给接收端发送一段字节流，过一会发送端又给接收端发送一段字节流以此类推。TCP 提供可靠字节流传输服务，发送端把发送进程的应用层分组组合成字节流，接收端把字节流拆分成应用层分组发给接收进程。</p><p>TCP 报文段也具有差错检测的功能，差错检测范围是整个 TCP 报文段。TCP 报文段和 UDP 数据报地位很像，都是生成后直接交付网络层传输，都直接享受网络层的两主机间不可靠 IP 数据报传输服务，两者都可能丢失、出错或拥塞。</p><p>TCP 流量控制见 P236，TCP 拥塞控制见 P238</p><p>TCP 不像 UDP 一样直接传输应用层分组，TCP 传输应用层分组前要先建立连接，这个建立连接指的是通信双方要互知存在、协定参数。</p><p>TCP 三次握手见 P247，四次挥手见 P249</p><h4 id="第六章应用层"><a href="#第六章应用层" class="headerlink" title="第六章应用层"></a>第六章应用层</h4><p>某些计算机应用需要网络进程间通信，而运输层提供的仅是网络进程间的分组传输，因此需要针对不同应用的需求设计不同的应用层协议来实现相应的特定通信，应用层协议依然需要设计语法、语义、同步这三要素。</p><p>应用层很多协议都是基于客户服务器方式，这里的客户和服务器都指的是进程，客户是服务请求方，服务器是服务提供方。</p><p>域名系统 DNS 的作用是让人们可以根据域名查到 IP，它被设计成一个联机分布式数据库系统，DNS 报文会被打包成 UDP 数据报发送。</p><p>域名格式：四级域名.三级域名.二级域名.顶级域名。一个单位一旦拥有了一个域名，它就可以自己决定是否要进一步划分其下属的子域，而不必得到上级机构的批准，域名树的树叶就是单台计算机的名字，它不能再继续往下划分了。</p><p>根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器。当计算机要查询域名时，首先向本地域名服务器递归查询，如果查不到，本地域名服务器会向根域名服务器迭代查询。</p><p>文件传送协议 FTP：基于 TCP，对一个远端计算机中某个文件的修改是通过先传送一份到本地，本地修改，再把修改后的文件传送回去。</p><p>简单文件传送协议 TFTP：基于 UDP。</p><p>万维网是一个分布式的超媒体系统。万维网应用指的是：点击一个超文本中的超链接，显示出另一个超文本&#x2F;超媒体，然而这个超文本&#x2F;超媒体是来自于网络中另一台计算机上的资源，这显然需要网络进程间通信，也就是需要应用层协议。</p><p>域名查询应用需要网络进程间通信，需要设计应用层 DNS 协议来实现特定通信，文件传送应用需要网络进程间通信，应用层的 FTP 协议的特定通信只是实现方式之一，万维网应用需要网络进程间通信，应用层的 HTTP 协议实现的特定通信是主要方式，当然也有其他应用层协议。</p><p>统一资源定位符 URL 是用来表示互联网中某个资源的位置和准备用哪种应用层协议的特定通信来获取这个资源。</p><p>URL 格式：协议:&#x2F;&#x2F;主机名:端口&#x2F;路径</p><p>主机名是万维网文档所存放的主机的域名，通常以 www 开头，端口号经常被省略掉，因为往往使用默认端口号，如 HTTP 默认端口 80（意思是大多数万维网服务器默认把 HTTP 内容分发进程绑定到 80 端口）。</p><p>使用 HTTP 的 URL 的路径为空的话，默认是请求主页 HTML 资源。</p><p>HTTP 协议过程：客户进程与一直运行着的服务器进程三次握手建立 TCP 连接，客户进程发送 HTTP 请求报文，服务器进程进行相应处理，服务器进程回复 HTTP 响应报文，四次挥手断开 TCP 连接。HTTP 报文是 ASCII 码串结构。HTTP&#x2F;1.1 相比于 HTTP&#x2F;1.0 使用的是持续连接+非流水线方式&#x2F;流水线方式。HTTP&#x2F;2.0</p><p>代理服务器又称为万维网高速缓存，它可以构成内容分发网络 CDN，具体见 P279。</p><p>在 HTTP 中使用 Cookie 可以帮助万维网服务器识别用户，但使用 Cookie 需要得到用户同意。Cookie 具体工作方式是：用户第一次连接万维网服务器时，万维网服务器为用户产生一个识别码，它将识别码和用户 Session 的对应关系存储起来并且将识别码发送给用户，接下来用户的所有 HTTP 请求报文都会带有这个识别码，因此万维网服务器每次都能够识别这个用户。</p><p>超文本标记语言 HTML 是一种制作万维网页面的标准语言。</p><p>万维网的信息检索系统：万维网储存了海量的信息，如果我们不知道要找的信息在何网点，就需要使用万维网的搜索工具。</p><ul><li>全文检索搜索引擎：引擎在各个网站爬取信息，并建立一个很大的在线索引数据库供用户查询。如谷歌。</li><li>分类目录搜索引擎：利用各个网站向搜索引擎提交的网站信息，建立分类目录的数据库供用户查询。如新浪网。</li></ul><p>动态主机配置协议 DHCP：连接到互联网的计算机的协议软件需要配置的项目包括：IP 地址、子网掩码、默认路由器的 IP 地址、域名服务器的 IP 地址。当网络情况发生变化时（比如接入到了新的子网中），就需要重新配置 IP 地址，DHCP 提供了即插即用连网机制，允许一台计算机加入新的网络和获取 IP 地址而不用手动参与。具体见 P304。</p><p>操作系统向外提供的 API 的原理：当某个应用进程启动系统调用时，控制权就从应用进程传递给了操作系统，操作系统执行完内部过程后，控制权被归还到应用进程。</p><p>如果我们还有一些特定的应用需要互联网的支持，但这些应用又不适用于当前的已经标准化的互联网应用层协议，这时我们可以通过调用操作系统向外提供的 API 来操纵位于操作系统中的 TCP&#x2F;IP 协议软件。当应用进程要进行网络通信时，操作系统会为此进程创建一个套接字（套接字指的是网络通信所需系统资源集合，如存储器空间、网络带宽等），建立一个套接字描述符到套接字的映射并把套接字描述符返回给应用进程，之后应用进程进行的网络操作都可以使用这个套接字描述符。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称性加密与非对称性加密</title>
    <link href="/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86/"/>
    <url>/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="对称性加密与非对称性加密"><a href="#对称性加密与非对称性加密" class="headerlink" title="对称性加密与非对称性加密"></a>对称性加密与非对称性加密</h1><h3 id="对称性加密"><a href="#对称性加密" class="headerlink" title="对称性加密"></a>对称性加密</h3><p>客户端和服务端采用同种加密算法，网络传输的是密文，缺点是中间节点知道了加密算法仍可以截获数据包并解密出明文，是不安全的。</p><h3 id="加入动态因子的对称性加密"><a href="#加入动态因子的对称性加密" class="headerlink" title="加入动态因子的对称性加密"></a>加入动态因子的对称性加密</h3><p>客户端和服务端仍采用同种加密算法，但加密算法中加入了动态因子，这也意味着如果中间节点不知道动态因子是不可以解密的，但是动态因子最初也需要从一方传递给另一方，这个传递只能采用普通的对称性加密，因此动态因子有被截获的可能，所以仍然不安全。</p><h3 id="非对称性加密"><a href="#非对称性加密" class="headerlink" title="非对称性加密"></a>非对称性加密</h3><p>由服务器生成一对公钥和密钥，公钥加密后公钥不可解密只有私钥可以解密，私钥加密后公钥可以解密，客户端发起 https 请求时会首先去服务器默认的 443 端口请求一份公钥，这个公钥是公共的，任意中间节点截获查看都不会有影响。接下来客户端发送的 http 请求会经过公钥加密，其他有公钥的节点截获后是无法解密的，服务器可以用私钥解密，服务器发送的 http 响应会经过私钥的加密，其他节点可以用公钥解密，但是一旦解密就无法再次加密（因为其他节点没有服务器私钥），所以这个信息就不会被客户端正常接收。</p><p>非对称性加密存在一个安全问题：如果客户端在请求服务器公钥的时候，有一个中间的虚假服务器返回了假公钥并向真实服务器请求了真公钥，这个过程客户端是不知道的，客户端认为自己在和真实服务器通信，但其实客户端用假公钥加密的 http 请求到达虚假服务器后被假私钥解密，然后用真公钥加密再发给真实服务器，真实服务器返回给虚假服务器的 http 响应先被真公钥解密再通过假私钥加密然后发给客户端，客户端用假公钥解密。</p><p>这也是为什么只是自己给服务器配了私钥公钥后，浏览器会提示是不安全的 https 连接。</p><h3 id="非对称性加密-CA-机构"><a href="#非对称性加密-CA-机构" class="headerlink" title="非对称性加密+CA 机构"></a>非对称性加密+CA 机构</h3><p>非对称性加密存在的安全问题可以被 CA 机构解决，CA 机构支持为服务器付费生成并颁发数字证书，用户请求某个服务器的公钥时可以直接从服务器 443 端口拿到证书。那么 CA 机构是如何保证服务器公钥不被篡改地返回客户端的呢？CA 机构本身也有着自己的公钥私钥，但是 CA 机构的公钥是内置在所有用户的操作系统里面的（因此客户端可以不经过网络就知道 CA 机构的公钥），服务器返回的证书是经过 CA 机构私钥加密后的服务器公钥，如果有中间节点拦截了这个数据包并利用自己操作系统中内置的 CA 机构公钥进行解密，虽然能够获知某个服务器的公钥，但是由于中间节点不知道 CA 机构服务器的私钥因此没有办法重新加密，因此中间节点也就不能篡改服务器公钥的发放。</p><h3 id="非对称性加密-CA-机构-自签名"><a href="#非对称性加密-CA-机构-自签名" class="headerlink" title="非对称性加密+CA 机构+自签名"></a>非对称性加密+CA 机构+自签名</h3><p>自签名指的是服务器自己作为自己的 CA 机构，完成 CA 机构的工作，这里 CA 机构公钥一般使用的都是客户端普遍内置的公钥。对于服务器来说，自己进行的自签名证书是可以保证服务器与客户端的安全通信的，但是客户端可能认为自签名证书 https 连接是不安全的，因为不是权威 CA 机构。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wireshark教程</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20wireshark%E6%95%99%E7%A8%8B/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20wireshark%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="wireshark-教程"><a href="#wireshark-教程" class="headerlink" title="wireshark 教程"></a>wireshark 教程</h1><p>首先是最基本的概念：wireshark 最多深入到数据链路层，抓的是检错后的无比特差错的以太网帧，并将其逐层拆分并分析信息。wireshark 抓的以太网帧并不一定都能将分组传输到最上面的应用层，因为从数据链路层往上走还可能会出问题，IP 数据报的排队丢失、IP 数据报的差错检测，接下来拿出 TCP 报文段或者 UDP 数据报，对于 UDP 数据报，UDP 差错检测，没问题的话分组能够到对应端口的进程，对于 TCP 报文段，TCP 差错检测没问题后，又涉及到是重传分组 or 不是重传分组。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unicode和UTF-8的关系</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20Unicode%E5%92%8CUTF-8%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20Unicode%E5%92%8CUTF-8%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unicode-和-UTF-8-的关系"><a href="#Unicode-和-UTF-8-的关系" class="headerlink" title="Unicode 和 UTF-8 的关系"></a>Unicode 和 UTF-8 的关系</h1><p>ASCII 定长编码 1 字节，Unicode 定长编码 2 字节，UTF-8 变长编码 1-3 字节。Unicode 和 UTF-8 均兼容 ASCII 码。<br><a href="https://blog.csdn.net/evelynnJava/article/details/123339476">(122 条消息) Unicode 和 UTF-8 的区别_、wook 的博客-CSDN 博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis总结</title>
    <link href="/notes/2023/10/29/Essay%20Redis%E6%80%BB%E7%BB%93/"/>
    <url>/notes/2023/10/29/Essay%20Redis%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-总结"><a href="#Redis-总结" class="headerlink" title="Redis 总结"></a>Redis 总结</h1><p>Redis 是非关系型数据库，最大特点是数据放在内存中，这也是 Redis 做增删改查原子操作速度快以及 Redis 不能存放大量数据的原因。</p><p>Redis 的应用离不开它的 5+4 种数据类型，即 String（字符串）、Hash（哈希）、Set（无序不可重复）、Sorted Set（排序不可重复）、List（有序可重复） 和 BitMap（位图）、Stream（消息队列）、Geospatial（地理位置）、HyperLogLog（不精确地统计每天登陆人数）。</p><p>Redis 的典型应用场景包括：二级缓存（二级缓存的增删改查分别是怎么做的，需要怎么上锁，查询时可能会出现的缓存穿透、缓存雪崩和缓存击穿需要如何解决），存放会话信息（验证码、登录信息等等），分布式各种功能（分布式非阻塞式锁、分布式 ID 生成等等）。</p><p>Redis 剩余的各种细碎应用只需要根据需求选择合适的数据类型即可。</p><h2 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h2><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>对于高频数据添加 Redis 缓存可以有效缩短请求时间，减轻关系型数据库比如 mysql 的负载压力。</p><p>二级缓存的增删改查</p><ul><li>增：直接在 mysql 中增加相应条目</li><li>删：先删除 Redis 中对应条目（不论是否存在），再删 mysql 中对应的条目</li><li>改：先修改 mysql 中对应的条目，再删除 Redis 中对应条目（不论是否存在）</li><li>查：如果 Redis 命中就直接返回，如果没命中再查 mysql，查不到就返回空，查到就放到 Redis 中然后返回。</li></ul><p>二级缓存的增删改查一定要互斥执行，锁用 synchronized 或 Redis 分布式锁甚至自己写的锁都行，但是一定要上锁否则会出现很多数据一致性问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>攻击者发起大量关于不存在条目的请求，都会穿透缓存打到 mysql 上，给数据库造成巨大压力。解决方式是如果遇到空查询就往缓存中放相应的空条目，这样关于此条目的查询除了第一次会直接打到数据库上，之后都会被缓存拦截。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>同一时间大量 key 失效，或缓存直接宕机导致大量流量直接打到数据库。解决方式是尽量避免同一时间大量 key 失效，比如缓存失效时间加随机值。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>热点 key 失效导致产生高并发的缓存重建，给数据库和服务器带来压力。解决方式有两种，第一种方式是由最早的线程进行缓存重建，其他的线程轮询等待，直到缓存重建完成后所有的线程再返回最新数据。第二种方式是由最早的线程单开一个线程进行缓存重建，所有的线程在重建完成前都先直接返回旧数据，采用这种方式时不能为 Redis 中的 key 设置 expire 时间，而是需要使用逻辑时间。需要注意的是这两种方式都需要上锁来保证最早的线程能够执行相应代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP黏包半包分析</title>
    <link href="/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20TCP%E9%BB%8F%E5%8C%85%E5%8D%8A%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <url>/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20TCP%E9%BB%8F%E5%8C%85%E5%8D%8A%E5%8C%85%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-黏包半包分析"><a href="#TCP-黏包半包分析" class="headerlink" title="TCP 黏包半包分析"></a>TCP 黏包半包分析</h1><h2 id="黏包-粘包"><a href="#黏包-粘包" class="headerlink" title="黏包&#x2F;粘包"></a>黏包&#x2F;粘包</h2><p>现象：发送 abc 和 def，接收 abcdef</p><p>原因：</p><ul><li>操作系统层（TCP&#x2F;IP 协议栈）<ul><li>发送端：一种情况是当程序不断地发送短字节，也就是向内核内存的发送缓冲区不断拷贝数据，由于通过网卡实际发送本身属于 IO 操作，因此速度肯定小于内存拷贝，因此短字节自然而然就在发送缓冲区中粘起来了。第二种情况是，linux 内核有一种 nagle 算法，算法为了节省报头损耗，会等待发送窗口填充满才会发送，如果发送的字节数短于发送窗口，就会等待接下来的数据“粘”过来。</li><li>接收端：当第一段字节到达接收缓冲区的时候没有及时读出，等到第二段字节到达的时候，自然而然的就在接收缓冲区中粘起来了。</li></ul></li><li>应用层：和各种语言的网络框架本身的应用层设计实现有关系，以 netty 为例，接收方 ByteBuf 设置太大就可能粘住。</li></ul><h2 id="半包-拆包"><a href="#半包-拆包" class="headerlink" title="半包&#x2F;拆包"></a>半包&#x2F;拆包</h2><p>现象：发送 abcdef，接收 abc 和 def</p><p>原因：</p><ul><li>操作系统层（TCP&#x2F;IP 协议栈）<ul><li>发送端：一种情况是要发送的数据长度大于发送窗口长度，此时一定会拆包。第二种情况是，要发送的数据长度大于 MSS（MSS&#x3D;mtu-40），此时数据一定会被拆分为多个 TCP 报文段，只要拆分成多个 TCP 报文段，就有可能导致最终结果拆包。</li><li>接收端：如果一次只读出接收缓冲区中的一段数据，就有可能造成拆包。</li></ul></li><li>应用层：和各种语言的网络框架本身的应用层设计有关系，以 netty 为例，接收方 ByteBuf 小于实际发送数据量就有可能拆包。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>短连接：每次要发送一条数据都经历：建立连接、发送数据、断开连接的过程。因为只发送一条数据，所以不会出现粘包，但可能出现拆包。</li><li>定长消息：服务端和客户端协定一个定长消息长度，客户端所有单个数据长度都小于等于这个最大长度，长度不够的补特定符号。这样发送端无论出现了各种粘和拆，但是接收端始终按定长收，就不会出现任何粘包和拆包。</li><li>分隔符：发送端在每条数据的前后设置分隔符，这样发送端无论出现了各种粘和拆，但是接收端始终依照分隔符接收，就不会出现任何粘包和拆包。分隔符的方式接收端要一个字节一个字节的查，效率非常低。</li><li>携带消息长度信息：每次发送消息时，先发送消息长度再发消息内容，这样客户端可以按照长度直接切出消息内容。是比较好的方式。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问修饰符选择</title>
    <link href="/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E9%80%89%E6%8B%A9/"/>
    <url>/notes/2023/10/29/%E5%85%AB%E8%82%A1%E7%AF%87%20%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="访问修饰符选择"><a href="#访问修饰符选择" class="headerlink" title="访问修饰符选择"></a>访问修饰符选择</h1><p>平时在写代码时，属性、静态属性、方法、静态方法如何选择访问修饰符呢？</p><h3 id="对于静态方法和静态属性"><a href="#对于静态方法和静态属性" class="headerlink" title="对于静态方法和静态属性"></a>对于静态方法和静态属性</h3><p>静态方法和静态属性一般都是工具类，我们关心的是可以在哪调用的问题。</p><ul><li>private：希望只能在本类调用</li><li>default：希望只能在本包调用</li><li>protected：希望子类都可以调用</li><li>public：希望任何地方都可以调用</li></ul><h3 id="对于方法和属性"><a href="#对于方法和属性" class="headerlink" title="对于方法和属性"></a>对于方法和属性</h3><p>我们关心的是这个方法或者属性的可见性问题。</p><ul><li>private：希望仅本类可见</li><li>default：希望本包的对象或子类都可见</li><li>protected：希望子类无论在哪都可见</li><li>public：希望任何包的对象或子类都可见</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股文</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git中的merge操作</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20git%E4%B8%AD%E7%9A%84merge%E6%93%8D%E4%BD%9C/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20git%E4%B8%AD%E7%9A%84merge%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="git-中的-merge-操作"><a href="#git-中的-merge-操作" class="headerlink" title="git 中的 merge 操作"></a>git 中的 merge 操作</h1><p>branch 相关的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 查看所有分支<br>git branch<br><br>// 创建一个name分支<br>git branch name<br><br>// 切换到name分支<br>git checkout name<br><br>// 合并name分支到当前分支<br>git merge name<br></code></pre></td></tr></table></figure><p><code>git merge name</code>命令用于将其他分支合并到当前所在工作分支上，当前工作分支的内容会由于 merge 操作产生更新，但是其他分支则完全不受影响，<code>git merge</code>通常与其他几个 git 命令一起使用，包括使用<code>git checkout</code>命令来选择当前工作分支，以及使用<code>git branch -d</code>命令来删除已经合并过的废弃分支。</p><p>merge 合并的情形主要有两种，一种是快进合并，一种是三路合并。</p><p>快进合并的情形：master 分支分出一个 b1 分支后，master 分支没有进行任何改变，b1 分支做了一些文件的<strong>增删改</strong>，这时在 master 分支下<code>git merge b1</code>，b1 分支会完全覆盖 master 分支，而不会产生任何的 conflict</p><p>三路合并的情形：master 分支分出一个 b1 分支后，master 分支做了一些文件的<strong>增删改</strong>，b1 分支也做了一些文件的<strong>增删改</strong>，这时在 master 分支下<code>git merge b1</code>，这时就不是 b1 分支简单地覆盖 master 分支，而是需要对 b1 分支中<strong>新增文件、删除文件和修改文件</strong>做出分类讨论。</p><ul><li>对于 b1 分支中的新增文件：如果 master 分支中没有新增同名文件，则直接 merge，不会产生 conflict，如果 master 分支中也新增了同名文件，则会产生 conflict，需要手动决策。</li><li>对于 b1 分支中的删除文件：如果 master 分支中的对应文件没有变化或也被删除了，则直接 merge，不会产生 conflict，如果 master 分支中的对应文件被修改了，则会产生 conflict，需要手动决策。</li><li>对于 b1 分支中的修改文件：如果 master 分支中的对应文件没有变化，则直接 merge，不会产生 conflict，如果 master 分支中的对应文件被修改或删除了，则会产生 conflict，需要手动决策。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git&amp;github必备技能</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20git&amp;github%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20git&amp;github%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="git-github-必备技能"><a href="#git-github-必备技能" class="headerlink" title="git&amp;github 必备技能"></a>git&amp;github 必备技能</h1><p><a href="https://backlog.com/git-tutorial/cn/">猴子都能懂的 GIT 入门 | 贝格乐（Backlog）</a></p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p><p>官方 hello world 入门教程，实操一遍提交代码的流程</p><p>进阶：</p><p>github 漫游指南</p><p>开源指北</p><p>git 官方文档，跟着文档敲一遍命令，有个大致印象即可</p><p>帮助理解：</p><p><a href="https://blog.csdn.net/qq_34246965/article/details/107553644">(93 条消息) 解决 git pull 出现冲突 多重超详细分析_叶孤崖的博客-CSDN 博客_git pull 冲突</a></p><p>注意命令行下的 git 默认是不使用代理的（即使开了 vpn），所以执行 git push 等命令时会因为网络问题报错，这时就需要我们手动为 git 配置代理，以下是开了 clash 后的配置命令（7890 是 clash 的默认端口号）。</p><p>git config –global http.proxy <a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a></p><p>git config –global https.proxy <a href="https://127.0.0.1:7890/">https://127.0.0.1:7890</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言头文件的作用</title>
    <link href="/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20C%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/notes/2023/10/29/%E9%9A%8F%E7%AC%94%E7%AF%87%20C%E8%AF%AD%E8%A8%80%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言头文件的作用"><a href="#C-语言头文件的作用" class="headerlink" title="C 语言头文件的作用"></a>C 语言头文件的作用</h1><p>C 语言某个源文件中要调用某个外部函数（其他一起编译的源文件中的函数&#x2F;静态库中的函数&#x2F;动态库中的函数），只需要在源文件中声明此函数即可，c 编译器眼里只有源文件，参与编译的也只有源文件。c 语言的外部函数调用在编译时不需要定义，只要有个声明，编译器就会在调用处填入一个待定地址，之后由链接器在其他一起编译的源文件&#x2F;静态库&#x2F;动态库中去寻找真正函数并进行链接，对于其他一起编译的源文件&#x2F;静态库是直接把相应函数的机器码链接过来，对于动态库是把相应函数的机器码的地址链接过来。所以你只需要知道别人写的函数签名，你就能调用别人写的函数，只要你在源文件里写一下声明就行。</p><p>那么问题来了，难道每次使用别人的代码，都要我自己先去查别人的文档，知道函数的声明，然后自己写一遍 extern void xxx();声明吗?于是程序员们就一起约定，你写了 c 文件之后，要把里面的函数声明和需要导出的宏一起存在另一个文件里，然后别人直接把这个文件里的内容复制粘贴在自己的源文件里，并且把别人写的源文件或者编译好的库也参与编译和链接，就能使用别人的成果了，这个文件就是头文件，这个复制粘贴的过程就是#include。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
