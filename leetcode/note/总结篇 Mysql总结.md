---
title: Mysql总结
date: 2024-01-08 09:41:54
tags: [Mysql, 八股文]
---

# Mysql 总结

## 基础篇

### Mysql 的一条语句是如何执行的

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317093516.png)

Server 层是上层，负责建立连接、分析和执行 SQL。底层存储引擎层负责数据的存储和提取，支持 **InnoDB（默认存储引擎）**、MyISAM、Memory 等多个存储引擎。

1. 客户端与 server 层建立 tcp 连接并校验用户名密码
2. 对传过来的 sql 进行解析，词法分析识别关键词，语法分析构建语法树。
   ![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317094400.png)
3. 预处理 sql，检查表和字段是否存在，将 `select *`中的`*`扩展为全部字段
4. 确定 SQL 语句的执行计划，比如当有多个索引的时候，基于查询成本的考虑来决定选择使用哪个索引，我们可以在查询语句最前面加个 `explain` 命令来输出本条 sql 的执行计划。
   ![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317095333.png)
5. 执行 sql，下面举几个例子

- 主键等值：把条件交给存储引擎，存储引擎直接返回一条
- 全表扫描：存储引擎返回第一条记录，执行器判断并返回客户端，存储引擎返回下一条记录

### Mysql 一行记录是如何存储的

#### 数据存储在哪个文件

每一个数据库有一个文件夹，当我们给这个数据库创建一个 t_order 表的时候，文件夹中会存在三个文件

- db.opt：用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm：存放表结构
- t_order.ibd：存放表数据

#### 表空间文件的结构是怎么样的

InnoDB 存储引擎的逻辑存储结构大致如下图：
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317102558.png)

- 页是 InnoDB 存储引擎磁盘管理的最小单元，页的大小固定 16KB。数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。
- 区可以使得 B+树中每层双向链表相邻的页的物理位置也相邻，这样可以使用顺序 IO 提高速度

#### InnoDB 行格式 COMPACT

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317103104.png)

- 变长字段长度列表：用来存放当前记录所有变长字段的长度
- NULL 值列表：存放所有可以为 NULL 的字段是否为 NULL，每个字段用 1bit 表示
- row_id：隐式主键，如果建表时存在主键或者不存在主键但是存在非空唯一索引，这个字段就没有用了，否则会设置隐式自增主键
- trx_id：事务 id，表明这条记录是由哪个事务生成的
- roll_pointer：指向 undolog 上一个版本的指针

#### varchar(n) 中 n 最大取值为多少

Mysql 一行记录最大长度为 65535 字节，所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 <= 65535。

#### 行溢出后，MySQL 是怎么处理的

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。

## 索引篇

索引的定义就是帮助存储引擎快速查找数据的一种数据结构，形象的说就是索引是数据的目录。

所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。

### 从数据页的角度看 B+ 树

InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。

#### 一个数据页里面是什么样的

一个数据页里面存放了多条记录，数据页中的记录按照「主键」顺序组成单向链表。当按照主键进行查询的时候，由于是单链表的结构所以只能遍历整个链表。为提高查询效率引入了分组的方式，页目录中的每个槽都索引了分组的最后一条记录，因此每次查询时可以先用二分法查到相应的槽，然后再去槽对应的分组中遍历得到记录。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317142341.png)

#### B+ 树是如何进行查询的

InnoDB 里的 B+ 树中的每个节点都是一个数据页，非叶子节点的数据页只存放索引不存放记录数据，叶子节点的数据页存放的是记录数据。

比如说我们要查找主键为 6 的记录，首先在根叶子节点二分法定位槽，然后遍历链表找到大于等于 1 且小于 7 对应页 30。在页 30 非叶子节点二分法定位槽，然后遍历链表找到大于等于 5 对应页 16。在页 16 叶子节点二分法定位槽，然后遍历链表找到主键为 6 的记录。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317151626.png)

#### 聚簇索引和二级索引

索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：

- 聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；
- 二级索引的叶子节点存放的是主键值，而不是实际数据。

因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。

#### 回表和索引覆盖

如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。

### 为什么 MySQL 采用 B+ 树作为索引

磁盘读写的最小单位是扇区，扇区的大小只有 `512B` 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。

MySQL 的索引结构应该满足以下两点：

- 能在尽可能少的磁盘 I/O 次数下查找记录
- 既能高效查找某条记录，也能高效查找某个范围内的记录

#### 可能的索引结构

首先我们需要明确，数据页在存储上并不是连续存储的。

- 二分法：把每个数据页地址组成一个连续存储的数组，并按照主键 id 从小到大排列，然后就可以二分查找了。二分法查找单条记录或者范围记录的时间复杂度都是 O(log(n))，远差于 B+树。
- 平衡二叉搜索树（AVL）：把每个数据页地址组成一个 AVL 树，AVL 树的查找、插入、删除时间复杂度都是 O(log(n))，而二分法的插入、删除时间复杂度是 O(n)。但 AVL 树无法高效范围查找。
- B 树：相当于平衡多叉搜索树，相比于 AVL 树查询效率得到提升，IO 次数更少，但仍然无法高效范围查找（只能遍历树）。
- B+树：和 B 树的区别在于，记录只存在叶子结点，并且每层节点之间由双向链表连接。相比于 B 树，因为非叶子节点不存记录数据，所以非叶子节点可以存更多的索引，因此整体结构更加扁平，查询的磁盘 IO 次数更少，且支持高效范围查找。

### MySQL 单表不要超过 2000W 行

MySQL 单表不要超过多少行这个问题和表结构有哪些字段以及字段类型有关。核心问题是希望聚簇索引的 B+树层数不要超过 3 层，否则太高的磁盘 IO 次数会导致查询效率降低。

我们假设：

- 非叶子节点内指向其他页的数量为 x
- 叶子节点内能容纳的数据行数为 y
- B+ 数的层数为 z

则行数$Total =x^{z-1}y$，一个数据页大概能存 1280 个索引，即$x=1280$，我们假设一行数据占 1KB 大小，那么一个数据页大概能存 15 行记录。算下来，当 B+树层数为 3 时最多能存约 2450w 行记录。

### 索引失效有哪些

- 对索引使用左或者左右模糊匹配：也就是 `like %xx%` 或者 `like %xx%` 这两种方式
- 对索引使用函数或对索引进行表达式计算：如果查询条件中对索引字段使用函数，就会导致索引失效。B+树是按照索引字段原来的值构建的，经过函数映射后当然不再适用。
- 对索引隐式类型转换：比如下面的例子，phone 是 varchar 类型，自动转换为数字
  ```sql
  select * from t_user where phone = 1300000001;
  ```
- 联合索引非最左匹配：单字段索引在排序时直接按单字段排序即可，而联合索引在排序时先按第一个字段排序，第一个字段相同时再按第二个字段排序，以此类推。因此联合索引要能正确使用需要遵循最左匹配原则，以下情况会走联合索引：
  ```sql
  where a=1；
  where a=1 and b=2 and c=3；
  where a=1 and b=2；
  ```
  以下情况会全表扫描：
  ```sql
  where b=2；
  where c=3；
  where b=2 and c=3；
  ```
  以下情况会部分走联合索引的**索引下推**：`a = 1`会走联合索引，在查到一条记录后不会回表查整行记录再判断`c=3`，而是先判断 c，如果`c=3`才会回表查整行数据并返回。
  ```sql
  where a = 1 and c = 3；
  ```
- WHERE 子句中的 OR：id 字段是主键，age 字段没有索引。那么下面这条 sql 走全表扫描，这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
  ```sql
  select * from t_user where id = 1 or age = 18;
  ```

### count(\*) 和 count(1) 有什么区别

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240317221540.png)

server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。

- count(主键字段) ：全扫描聚簇索引或二级索引，判断主键字段是否为 NULL，count 加一
- count(1)：全扫描聚簇索引或二级索引，count 加一
- count(\*)：等价于 count(0)
- count(字段)：如果字段是普通字段则全表扫描，如果是索引字段则全扫描索引

#### 为什么要通过遍历的方式来计数

一方面在有 where 条件限制的时候，肯定要遍历。另一方面在没有 where 条件限制的时候，因为 innodb 存储引擎有着事务隔离的 MVCC 机制，因此不能用一个量来衡量整个表的行数，也需要遍历。
