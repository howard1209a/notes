---
title: SpringCloud总结
date: 2023-11-23 20:26:09
tags: [SpringCloud, 八股文]
---

# SpringCloud 总结

分布式架构相比于单体架构具有低耦合、业务拆分的特点，但也引入了一些问题比如数据一致性问题、复杂调用关系等等。微服务是一种分布式架构标准，微服务强调拆分粒度小、每个微服务独立程度高、每个微服务向外提供标准接口。

微服务拆分原则需要遵守：

- 不同微服务，不要重复开发相同业务
- 微服务数据独立，不要访问其它微服务的数据库

SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配。SpringCloud和SpringBoot之间存在版本兼容关系。

SpringCloud 中的各种微服务之间采用 http 协议进行接口调用。RestTemplate 组件提供了 http 借口调用的实现。

## 微服务注册中心

微服务注册中心支持服务提供者注册信息，支持服务消费者获取服务提供者的注册信息。相比于服务提供者的接口地址写死在服务消费者代码中的方式，微服务注册中心一方面支持随时的服务提供者变动，另一方面也支持微服务调用的负载均衡。

### Eureka

Eureka 支持服务提供者注册服务信息，支持服务消费者定时拉取服务信息。服务提供者通过心跳的方式（默认 30s）告知 Eureka 自己的健康状态。

我们可以直接在 SpringBoot 中启动一个 Eureka 微服务（通过引入相关依赖、配置 yml 文件、配置注解），然后将其他微服务作为服务提供者注册到 Eureka（通过引入相关依赖、配置 yml 文件），最后作为服务消费者的任何微服务都可以拉取 Eureka 中的服务注册信息进行相应的微服务接口调用（通过引入相关依赖、配置 yml 文件、配置注解）。

微服务接口调用的负载均衡是通过 Ribbon 实现的，Ribbon 默认是采用懒加载。负载均衡接口 IRule 有一些默认的接口实现比如轮询（RoundRobin）、权重、区域优先等等。

### Nacos

Nacos 是阿里的产品，相比 Eureka 功能更丰富。Nacos 直接提供了操作系统可以直接运行的 bin 文件（依赖 jre）。

#### 服务注册与拉取

Nacos 将一个服务分为了多个集群（通常一个集群指的是某区域的一个机房），每个集群又分为了多个实例。微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。

我们同样可以通过引入相关依赖、配置 yml 文件、操作 Nacos 的 web 控制台的方式，完成服务提供者的集群注册、负载权重配置、服务消费者拉取信息等操作。

Nacos 注册中心对于服务提供者除了心跳检测还会主动询问，除了服务消费者会定时拉取 Nacos 注册中心信息外，Nacos 还会向服务消费者主动推送变更消息。

#### 配置管理与热更新

我们可以在 Nacos 的 web 控制台上创建 yaml 配置，并将需要热更新的配置放在其中，这样微服务的配置信息就由 bootstrap.yaml、Nacos 在线 yaml 和 application.yml 共同组成，我们通过@Value 注解或@ConfigurationProperties 注解就可以读取热更新配置。当然上述过程还是需要通过引入相关依赖、配置 yml 文件、配置注解来完成。

Nacos 在线 yaml 配置有两种：

- `[spring.application.name]-[spring.profiles.active].yaml`，例如：userservice-dev.yaml

- `[spring.application.name].yaml`，例如：userservice.yaml

`[spring.application.name].yaml`不包含环境，因此可以被多个环境共享。

## 微服务远程调用

单体应用只需要提供接口给用户即可，但微服务由于其高内聚低耦合的特点，一方面微服务接口的实现需要依赖其他微服务接口，另一方面微服务接口也需同时提供给用户和其他微服务。

### RestTemplate

### Feign

Feign 是一种接口声明式的 http 微服务调用请求，我们可以对每个微服务声明一个接口，在里面为微服务的每个服务接口声明一个方法，可以指定微服务名称（用来从注册中心拉取信息）、请求方式（Get）、资源路径、pojo 返回类型。Feign 的微服务调用和 RPC 有点像。

Feign 底层依赖的 http 请求框架有多种，如果选择支持 http 连接池的框架则可能会带来性能优化。

## 微服务网关

### Gateway

Gateway 基于响应式编程，提供了权限控制、请求路由和服务限流等核心功能。

- 权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。
- 路由和负载均衡：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。
- 限流：当请求流量过高时，在网关中按照对应微服务能够接受的速度来放行请求，避免服务压力过大。

引入相关依赖、配置 yml 文件即可启动 Gateway 网关微服务。

#### 过滤器

过滤器可以对路由的请求或响应做加工处理，比如添加请求头等。Gateway 提供了多种类型的过滤器实现，我们可以在 yml 文件中配置路由过滤器和默认过滤器（只可以使用 Gateway 提供的过滤器），我们也可以实现自己的全局过滤器，通过编写自定义逻辑实现登陆状态判断、权限校验、请求限流等功能。

多个过滤器执行的先后顺序取决于 order 值。

#### 跨域问题

application.yml 中可以进行配置。

## 微服务部署

大型项目微服务很多，多个微服务之间可能存在依赖冲突，但每个微服务都单独部署在一个服务器不太实际，Docker 可以解决微服务间的依赖兼容性问题。

### Docker

#### Docker 实现机制

- Docker 可以将应用、函数库、依赖、配置与操作系统上层环境一同打包，之后只需要加上 Linux 内核即可运行。
- 多个 Docker 容器间通过 Namespace 技术进行进程隔离，通过 Cgroups 技术进行进程资源限制。这也是我们进入 Docker 容器内部感觉像是一个完整操作系统的原因。

需要明确的是，Linux 操作系统由 Linux 内核以及系统上层环境（也就是各种发行版：Ubuntu、Centos 等，它们的 Linux 内核是一致的）组成。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。操作系统本身提供的系统接口、函数库等等是对内核指令的封装，使用更加方便。Docker 的打包实际上是打包系统上层环境的，因此 Docker 应用可以在任何 Linux 操作系统上运行，因为它只需要 Linux 内核即可。

Docker 镜像是分层的，这使得多个 Docker 镜像间可以共享相同层。

#### Docker 与虚拟化技术对比

Docker 的实现可以基于 Linux 内核原生运行，本质就是一个进程，不需要任何虚拟化，因此硬盘占用低、启动速度快。

Vmware 这种虚拟化技术，是在宿主操作系统的基础上，用软件虚拟出一套计算机硬件（这个中间层称为 Hypervisor），再基于虚拟出来的这套硬件安装任何想要的操作系统。因此应用运行在虚拟机上时，想要操作底层真实硬件需要依次通过虚拟机操作系统、Hypervisor、宿主机操作系统、底层真实硬件。因此硬盘占用大、启动慢、性能差。

#### Docker 关键点

- 文件挂载：支持目录挂载、文件挂载。一方面方便修改配置文件，一方面容器删除后数据保留（如 mysql）。
- 构建镜像：
  - 把当前容器构建为镜像
  - Dockerfile 构建镜像
- DockerCompose：DockerCompose 脚本可以自动化构建镜像、运行容器。DockerCompose 可以实现微服务的自动部署。
- 网络通信：
  - Docker 容器和外部网络通信需要在运行 Docker 容器的时候映射端口
  - Docker 容器与 Docker 容器之间的网络通信时，IP 写 Docker 容器名字即可，Docker 底层做好了实现。
- 镜像仓库：可以搭建公司私有仓库。
