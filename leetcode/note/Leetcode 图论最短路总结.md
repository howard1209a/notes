---
title: 图论最短路总结
date: 2023-11-14 21:59:59
tags: [Leetcode, 图论, 最短路问题]
---

# 图论最短路总结

图论最短路是研究赋权有向图/无向图的单源点/多源点最短路问题。

## Dijkstra 算法

### 适用范围

赋权有向图/无向图的单源点最短路问题，要求边权非负。Dijkstra 算法按照从小到大的顺序，输出当前点到所有其他点的最短路长度和最短路径。

### 算法流程

维护两个数组，一个数组是**最短路长度**数组 A，一个数组是**最短路径前一个节点**数组 B。将数组 A 初始化为单源点与所有其他点的直连长度，将数组 B 初始化为单源点。此时数组 A 中最小数对应的节点已经找到了最短路！然后对于除了**单源点和已经找到最短路的节点**之外的所有节点，我们利用新找到的最短路节点对它们进行更新，如果**单源点到新找到节点的最短路**+新找到节点到这个节点的直连距离之和小于 A 数组原来的值，就可以对 A 数组进行更新，同时把 B 数组对应位置置为新找到节点。刷新后，我们又可以找到关于某个节点的最短路，重复这个过程直到所有节点都找到最短路...

最后得到的 A 数组记录了所有单源点最短路径长度，B 数组记录了所有节点最短路径上的前一个点，需要完整最短路径的话，从后往前追溯即可。

### 算法原理

我们可以把节点分为**已经找到最短路**和**还未找到最短路**两类。A 数组维护的是对于所有还未找到最短路的节点，每个节点考虑和**已经找到最短路**的所有节点直连所能达到的最短，这时我们再考虑整个 A 数组的最小数，则这个最小数对应的一定是一条到这个最小数对应节点的最短路径长度，可以用反证法证明，假设存在一条到这个节点的更短的路径，我们考虑这条路径上这个节点的上一个节点，上一个节点有两种情况，即在**已经找到最短路**的节点集合或**还未找到最短路**的节点集合，即使是在**还未找到最短路**的节点集合中，我们也可以继续向前延伸，一定可以找到一个点在**已经找到最短路**的节点集合中，因此我们可以发现假设存在的这条更短路径中，一定存在一个**还未找到最短路**集合中的点，它的前一个点是**已经找到最短路**集合中的点，那么你这条路径就不可能比我们最小数的最短路径长度还短，矛盾。因此找到的就是最短路。

### 模板代码

```java
待补充
```

## Floyd 算法

### 适用范围

赋权有向图/无向图的多源点最短路问题，要求边权可以为负，但是不可以有负圈（圈指的是闭路，路指的是节点不可重复的路径）。Floyd 算法是迭代后统一输出多源点最短路。

### 算法流程

$u_{i,j}^{1}=w_{i,j}$

$u_{i,j}^{k+1}=min\{u_{i,j}^{k},u_{i,k}^{k}+u_{k,j}^{k}\}$

i,j 的范围都是{1,2...n}，定义 n 为节点数。

定义一个 U 矩阵，U 矩阵最开始初始化为邻接矩阵（两点间不存在边的话赋值正无穷），之后按照上面第二个公式不断迭代，最终求出所有的$u_{i,j}^{n+1}$，就是 i 节点到 j 节点的最短路径长度。

我们还需要维护一个 P 矩阵（和 U 矩阵同维度）。把$p_{i,j}^{1}$初始化为 j。在之后的迭代过程中，如果$u_{i,j}^{k}$更小，则$p_{i,j}^{k+1}=p_{i,j}^{k}$，如果$u_{i,k}^{k}+u_{k,j}^{k}$更小，则$p_{i,j}^{k+1}=p_{i,k}^{k}$。最终我们求出所有的$p_{i,j}^{n+1}$，就是 i 节点到 j 节点的最短路径中 i 节点的后一个节点。我们可以从前往后追溯得到最短路径。

### 算法原理

Floyd 算法采用的其实是动态规划，$u_{i,j}^{k}$的含义是**不通过 k 节点、k+1 节点...n 节点时从顶点 i 到顶点 j 的最短路长度**。递推公式是，当我们有$U^k$矩阵时，对于$u_{i,j}^{k+1}$，考虑两种情况，一种是顶点 k 不在路径中，此时最短路就是$u_{i,j}^{k}$，另一种是顶点 k 在路径中（显然它只会存在一次），则最短路是由节点 k 分开的两条子路的最短路之和，正好就是$u_{i,k}^{k}+u_{k,j}^{k}$。而对于初始化来说，$u_{i,j}^{1}$为不经过任何节点的 i 到 j 最短路，显然是$w_{i,j}$。

### 模板代码

```java
待补充
```
