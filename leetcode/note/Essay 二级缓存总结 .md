---
title: 二级缓存总结
date: 2024-02-13 22:56:17
tags: [Java, 八股文]
---

# 二级缓存总结

## 正确的二级缓存方式

首先需要说明的是，二级缓存的增删改查如果上互斥锁的话，将完全保证数据一致性，但是会极大影响效率，所以我们一般不会上锁，而是采用以下的方式

### 增

在数据库中增加相应条目，此前数据库中一定是没有这些条目的，否则会报异常

### 删

先删除数据库中相应条目，再删除缓存中相应条目，此前数据库中可能有这些条目，也可能没有这些条目，并不影响

### 改

先修改数据库中相应条目，再删除缓存中相应条目，此前数据库中可能有这些条目，也可能没有这些条目，并不影响

### 查

先查缓存，如果有数据就直接返回，如果没有数据就查数据库，如果没有数据就返回空，有数据的话存入缓存后返回，此前数据库中可能有这些条目，也可能没有这些条目，并不影响

## 并发数据一致性分析

那么为什么上述的增删改查方式几乎不会出现数据一致性问题呢？首先需要明确几点

1. 数据库保证了关于相同条目操作的原子性
2. 缓存保证了关于相同条目操作的原子性
3. 前后两个操作之间存在顺序性，比如改操作，先改数据库再删缓存
4. 数据库的读写时间远远长于缓存的读写时间

下面是四种操作的时序图，其中查询只考虑了缓存没查到的情况，因为缓存查到了就会直接返回，并不会带来数据一致性问题
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214143806.png)

首先明确如下两种情况是结果等价的，比如我们把改和查 2 放在一起，其中改操作的第一步修改数据库操作完成后，根据顺序性，当前线程下一步的删除缓存开始执行，根据原子性，另一个线程的查询数据库开始执行。由于数据库的读写时间远远长于缓存的读写时间，所以可以等价于先执行删除缓存，再执行查询数据库，这在结果上是一样的。即结果等价于改和查 2 是串行执行的。
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214144903.png)

接下来考虑增、删、改、查 1、查 2 这几种操作的任意并发情况，其实从结果上来看等价于所有操作都是串行执行的，因此不会出现数据库和缓存之间的数据一致性问题。
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214151609.png)

## 一些额外的操作

上面我们已经证明了正确的增删改查操作不会带来并发数据一致性问题，然而有时我们会有一些额外的操作，这些操作也是不会带来数据一致性问题的。

### 手动缓存失效或超时缓存失效

比如我们设置一个接口，让相应缓存条目失效，或者设置缓存本身的超时失效。

### 读缓存

比如我们设置一个接口，读缓存中的相应条目，或查操作本身第一步就是读缓存。

## 为什么先改再删而不是先删再改

之所以先改再删是为了将耗时长的数据库读写操作放在前面，将耗时短的缓存读写操作放在后面，这样才能保证串行等价性。

而如果先删再改的话，就有可能出现一方包裹另一方或者交替执行的非串行执行方式，如下图所示
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214154830.png)

### 先删再改并发问题实例

下面这种情况很容易发生
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214155219.png)

### 先改再删并发问题实例

下面这种情况几乎不可能发生
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240214155336.png)

## 为什么删除缓存而不是更新缓存

删除一个数据，相比更新一个数据更加轻量级，操作执行的更快，因此出现数据一致性问题的概率更小。从另外一个角度来看，删除缓存也可以及时清理掉不频繁访问的缓存。

## 超时缓存失效的兜底方案

无论任何时候，我们都不保证二级缓存百分百的一致性，先改再删的小概率事件、程序异常等原因都可能造成二级缓存的数据一致性问题，而前面也已经说明了手动或自动的缓存失效并不会对二级缓存带来问题，所以我们可以定期地手动清除缓存，或者设置超时缓存失效来兜底，这样即使出现了数据不一致的情况，也能在一段时间后恢复一致。

## 删除缓存失败的解决办法

比如在数据库和缓存都有值的情况下进行改操作，先改数据库，成功了，然后删除缓存失败了，此时缓存中就一直是旧值了。

解决方法有两种

- 重试机制。
- 订阅 MySQL binlog，再操作缓存

### 重试机制

本质是当删除缓存失败的时候，不断地重试，因为删除缓存失败本来就是小概率事件，所以几次重试几乎可以认为一定成功。

可以利用消息队列完成，之前是修改数据库后直接删除缓存，现在是修改数据库后就生产一条消息到 mq 中，由消费者消费这条消息并删除缓存，如果消费者删除缓存失败，就重新获取消息进行重试。
