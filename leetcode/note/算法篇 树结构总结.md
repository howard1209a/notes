---
title: 树结构总结
date: 2024-03-08 14:54:00
tags: [Leetcode总结]
---

# 树结构总结

## 二叉搜索树

- 全局定义：每个节点的左子树所有节点均小于当前节点，右子树所有节点均大于当前节点。
- 递归定义：根节点的左子树所有节点均小于根节点，根节点的右子树所有节点均大于根节点，且根节点的左右子树均为二叉搜索树。

## 平衡二叉树

- 全局定义：每个节点的左子树和右子树的深度之差的绝对值不大于 1。
- 递归定义：根节点的左子树和右子树的深度之差的绝对值不大于 1，且左右子树均为平衡二叉树。

## AVL 树

AVL 树本质是平衡二叉搜索树，其插入、删除、查找的时间复杂度均为$log(n)$。由于 AVL 树对平衡性的要求比较严格（任意节点左右子树高度之差小于等于 1），因此插入、删除速度相比红黑树更慢（需要做较多的调整），查找速度相比红黑树更快。

## 红黑树

红黑树是一种自平衡的二叉搜索树，其插入、删除、查找的时间复杂度均为$log(n)$。但由于红黑树的平衡条件相较于 AVL 更为宽松，因此插入、删除速度相比于 AVL 树更快（需要做的调整较少），查找速度相比于 AVL 树更慢。

- 红黑树是二叉搜索树，这也意味着它满足二叉搜索树的定义
- 红黑树的平衡条件包括以下四点
  1. 所有 null 节点都是黑色，这里 null 节点指的是叶节点的左右节点。
  2. 红色节点之间不能相邻
  3. 红黑树中的节点到其任意叶子节点路径上的黑节点个数相同。
  4. 新插入的节点都是红色，在平衡过程中可能变色。

对于一个节点来说，既然左右子树路径上的黑色节点个数相同，因此决定左右子树高度差的因素就是红节点的个数，最极端的情况就是一条子树没有任何红节点，另一条子树尽可能多的有红节点，即红黑节点交替出现（因为红节点之间不能相邻）。因此左右子树高度差不会超过一倍。这保证了红黑树插入、删除、查找的时间复杂度均为$log(n)$。

红黑树做查找操作时，直接当成普通的二叉搜索树来查找即可。

红黑树做插入、删除操作时，先只关注红黑树的二叉搜索树性质，相当于对二叉搜索树做插入、删除操作。然后再进行颜色调整和节点调整以满足四点平衡条件，如果仅仅调整颜色就满足四点平衡条件，那么就已经找到了红黑树。如果还需要调整节点，则需要注意调整过程中不要破坏二叉搜索树性质。整个过程分类讨论情况较多。

具体分类讨论可参考链接资料

### 参考资料

https://gufeijun.com/post/map/2/

## B 树

B 树和 B-树是一个概念。

B 树和平衡二叉搜索树的不同之处是：B 树属于多叉树又名**平衡多路查找树**，数据库索引技术里大量使用着 B 树和 B+树的数据结构。其中**多路**指的是 B 树是 k 叉树而不是二叉树，**查找树**指的是 B 树仍然具有搜索树的切分性质，**平衡**指的是 B 树的结构就是平衡的，这点从 B 树自身形态以及插入删除的操作对自身形态的维护可以大致看出来。

### B 树构建规则

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308190735.png)

构建 B 树需要满足以下几点

1. 排序方式：所有节点关键字是按递增次序排列。
2. 子节点数：非叶节点的子节点数 >1、且子节点数量<=M，其中 M 是树的阶数。
3. 关键字数：枝节点的关键字数量大于等于 ceil(M/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数 如 ceil(1.1)结果为 2）。
4. 所有叶子节点均在同一层。

观察上图可以看出，首先是 M 把区间切成两半，然后左区间被 D 和 G 切了两刀，右区间被 Q 和 T 切了两刀，然后 D 左边的区间又被 A 和 C 切...

### B 树查询

比如说查 E，每一层都用二分来查，首先小于 M 往左走，然后大于等于 D 且小于 G，判断不等于 D，往对应子节点走，大于等于 E 且小于 F，判断等于 E，因此查到。

### B 树插入

定义一个 5 阶树（平衡 5 路查找树），现在我们要把 3、8、31、11、23、29、50、28、53 这些数字依次插入到五阶树中，注意关键字数最多为 4。

首先插入 3、8、31、11
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308192708.png)

然后插入 23、29，插入 23 的时候就要拆分了，11 被提起来，发现没有父节点，就新创建一个父节点然后把 11 放进去
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308192952.png)

最后插入 50、28、53，其中插入 28 的时候再次进行拆分，29 被提到已经存在的父节点
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308193216.png)

### B 树删除

B 树的删除过程涉及复杂的调整

### B 树特点

B 树的特点是每个节点都既包含索引数据又包含记录数据。

### 参考资料

https://zhuanlan.zhihu.com/p/27700617

## B+树

B+树在 B 树的基础上进行了改进，首先非叶子结点只存储索引数据不再存储记录数据，所有的记录数据都存储在叶子结点。其次所有叶子结点之间通过指针形成了双向链表。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308195837.png)

### B+树查询

比如要查 E 节点，判断 E 属于小于 G 的区间还是大于等于 G 的区间，向子节点走，然后判断 E 属于小于 c、大于等于 c 且小于 E、大于等于 E，向子节点走，最后判断 E 属于小于 E、大于等于 E 且小于 F 还是大于等于 F，结果是 E 大于等于 E 且小于 F，再判断 E 是否等于 E，查到结束。

### B+树插入

假设现在构建一棵四阶 B+树，首先插入 A，直接作为根节点。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308200846.png)

然后插入 B、C、D，插入 D 时超过了节点容量，需要拆分

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308200908.png)

把 C 提出来，放入父节点，父节点不存在就创建一个，然后分成 AB 和 CD 两个节点，并用指针连接它们

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201050.png)

下面插入 M，M 大于等于 C，走到右子节点并插入。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201355.png)

下面插入 L，超过了节点容量，L 被提出来放入父节点，然后拆分

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201532.png)

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201656.png)

后续非叶节点超过容量时，J 被提起放入父节点，父节点不存在就创建一个

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201935.png)

剩下的被拆分成了 CH 和 L

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308202122.png)

### innodb 存储引擎索引结构为什么选择 B+树而不是 B 树

B+树相比于 B 树主要有以下优势

1. 虽然 B 树不搜索到叶子结点就可以查到记录，但是由于 B 树的非叶子结点存储了记录数据，导致对于固定容量的非叶子结点（非叶子结点的大小有限，需要满足在一定次数的磁盘 IO 后完成对节点的数据读取），B+树相比于 B 树可以存储更多的索引，也就意味着 B+树相比于 B 树更加扁平，一次查询的 IO 次数反而要少。
2. B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除上的效率相比于 B 树更高，调整的复杂度更低。
3. B+ 树叶子节点之间用双向链表连接了起来，有利于范围查询，而 B 树要实现范围查询只能通过树的遍历来完成。

### 参考资料

https://blog.csdn.net/weixin_52622200/article/details/118530154

https://zhuanlan.zhihu.com/p/27700617
