---
title: 树结构总结
date: 2024-03-08 14:54:00
tags: [Leetcode总结]
---

# 树结构总结

## 二叉搜索树

- 全局定义：每个节点的左子树所有节点均小于当前节点，右子树所有节点均大于当前节点。
- 递归定义：根节点的左子树所有节点均小于根节点，根节点的右子树所有节点均大于根节点，且根节点的左右子树均为二叉搜索树。

## 平衡二叉树

- 全局定义：每个节点的左子树和右子树的深度之差的绝对值不大于 1。
- 递归定义：根节点的左子树和右子树的深度之差的绝对值不大于 1，且左右子树均为二叉平衡树。

## AVL 树

AVL 树本质是平衡二叉搜索树，其插入、删除、查找的时间复杂度均为$log(n)$，但由于 AVL 树对平衡性的要求比较严格（任意左右子树高度之差小于等于 1），因此插入、删除速度比较慢（需要做较多的调整），查找速度稍快一些。

## 红黑树

红黑树是一种自平衡的二叉搜索树，其插入、删除、查找的时间复杂度均为$log(n)$，但由于红黑树的平衡条件相较于 AVL 更为宽松，因此插入、删除速度较快（需要做的调整较少），查找速度稍慢一些。

- 红黑树是二叉搜索树，这也意味着它满足二叉搜索树的定义
- 红黑树的平衡条件包括以下四点
  1. 所有 null 节点都是黑色
  2. 红色节点之间不能相邻
  3. 红黑树中的节点到其任意叶子节点路径上的黑节点个数相同。
  4. 新插入的节点都是红色，在平衡过程中可能变色。

对于一个节点来说，既然左右子树路径上的黑色节点个数相同，因此决定左右子树高度差的因素就是红节点的个数，最极端的情况就是一条子树没有任何红节点，另一条子树尽可能多的有红节点，即红黑节点交替出现（因为红节点之间不能相邻）。因此左右子树高度差不会超过一倍。这保证了红黑树插入、删除、查找的时间复杂度均为$log(n)$。

红黑树做查找操作时，直接当成普通的二叉搜索树来查找即可。

红黑树做插入、删除操作时，先只把红黑树当成一个普通的二叉搜索树来做插入、删除操作，然后再进行颜色调整和节点调整以满足四点平衡条件，如果仅仅调整颜色就满足四点平衡条件，那么就已经找到了红黑树，如果还需要调整节点，则需要注意调整过程中不要破坏二叉搜索树性质。整个过程分类讨论情况较多。

### 参考资料

https://gufeijun.com/post/map/2/

## B 树

B 树和 B-树是一个概念。

B 树和平衡二叉搜索树的不同之处是：B 树属于多叉树又名**平衡多路查找树**，数据库索引技术里大量使用着 B 树和 B+树的数据结构。其中**多路**指的是 B 树是 k 叉树而不是二叉树，**查找树**指的是 B 树仍然具有搜索树的切分性质，**平衡**指的是 B 树的结构就是平衡的，这点从 B 树的形态以及插入删除的操作就可以看出来。

### B 树构建规则

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308190735.png)

构建 B 树需要满足以下几点

1. 排序方式：所有节点关键字是按递增次序排列。
2. 子节点数：非叶节点的子节点数 >1、且子节点数量<=M，其中 M 是树的阶数。
3. 关键字数：枝节点的关键字数量大于等于 ceil(m/2)-1 个且小于等于 M-1 个（注：ceil()是个朝正无穷方向取整的函数 如 ceil(1.1)结果为 2）。
4. 所有叶子节点均在同一层。

观察上图可以看出，首先是 M 把区间切成两半，然后左区间被 D 和 G 切了两刀，右区间被 Q 和 T 切了两刀，然后 D 左边的区间又被 A 和 C 切...

### B 树查询

比如说查 E，每一层都用二分来查，首先小于 M 往左走，然后大于等于 D 且小于 G，判断不等于 D，往对应子节点走，大于等于 E 且小于 F，判断等于 E，因此查到。

### B 树插入

定义一个 5 阶树（平衡 5 路查找树），现在我们要把 3、8、31、11、23、29、50、28、53 这些数字依次插入到五阶树中，注意关键字数最多为 4。

首先插入 3、8、31、11
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308192708.png)

然后插入 23、29，插入 23 的时候就要拆分了，11 被提起来，发现没有父节点，就新创建一个父节点然后把 11 放进去
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308192952.png)

最后插入 50、28、53，其中插入 28 的时候再次进行拆分，29 被提到已经存在的父节点
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308193216.png)

### B 树删除

我们要删掉 28，根据要求每个节点的关键字数必须大于等于 ceil(5/2)-1，所以这里需要进行调整
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308193449.png)

### B 树特点

B 树在每个节点保存更多的数据，减少了树的高度，从而提升了查找的性能。在数据库应用中，B 树的每个节点存储的数据量大约为 4K, 这与磁盘数据块的大小相同，每次对磁盘进行 IO 数据读取时，同一个磁盘块的数据会被一次性读取出来，所以每一次磁盘 IO 都可以读取到 B 树中一个节点的全部数据。

### 参考资料

https://zhuanlan.zhihu.com/p/27700617

## B+树

B+树是在 B 树的基础上又一次的改进，其主要对两个方面进行了提升，一方面是查询的稳定性，另外一方面是在数据排序方面更友好。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308195837.png)

### B+树构建规则

1. B+树的非叶子节点不保存具体的数据，所有的数据最终都会保存到叶子节点。因为所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样，这样一来 B+树的查询速度也就会比较稳定。而 B 树可以中途查到节点返回，查询速度不稳定。
2. B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。因为叶子节点都是有序排列的，所以 B+树对于数据的排序有着更好的支持。

### B+树查询

比如要查 E 节点，判断 E 属于小于 G 的区间还是大于等于 G 的区间，向子节点走，然后判断 E 属于小于 c、大于等于 c 且小于 E、大于等于 E，向子节点走，最后判断 E 属于小于 E、大于等于 E 且小于 F、大于等于 F，然后发现等于 E。

### B+树插入

假设现在构建一棵四阶 B+树，首先插入 A，直接作为根节点。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308200846.png)

然后插入 B、C、D，插入 D 时超过了节点容量，需要拆分
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308200908.png)

把 C 提出来，放入父节点，父节点不存在就创建一个，然后分成 AB 和 CD 两个节点，并用指针连接它们
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201050.png)

下面插入 M，M 大于等于 C，走到右子节点并插入。

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201355.png)

下面插入 L，超过了节点容量，L 被提出来放入父节点，然后拆分
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201532.png)

![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201656.png)

后续非叶节点超过容量时，J 被提起放入父节点，父节点不存在就创建一个
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308201935.png)

剩下的被拆分成了 CH 和 L
![](https://raw.githubusercontent.com/howard1209a/image-resource/main/note/20240308202122.png)

### B+树和 B 树的对比

1. B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定。
2. B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。
3. B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
4. B 树相对于 B+树的优点是，如果经常查询的数据离根节点很近，则可以提高查询效率。

### 参考资料

https://blog.csdn.net/weixin_52622200/article/details/118530154

https://zhuanlan.zhihu.com/p/27700617
