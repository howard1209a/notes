---
title: Redis总结
date: 2023-10-29 12:48:14
tags: [Redis, 八股文]
---

# Redis 总结

Redis 是非关系型数据库，最大特点是数据放在内存中，这也是 Redis 做增删改查原子操作速度快以及 Redis 不能存放大量数据的原因。

Redis 的应用离不开它的 5+4 种数据类型，即 String（字符串）、Hash（哈希）、Set（无序不可重复）、Sorted Set（排序不可重复）、List（有序可重复） 和 BitMap（位图）、Stream（消息队列）、Geospatial（地理位置）、HyperLogLog（不精确地统计每天登陆人数）。

Redis 的典型应用场景包括：二级缓存（二级缓存的增删改查分别是怎么做的，需要怎么上锁，查询时可能会出现的缓存穿透、缓存雪崩和缓存击穿需要如何解决），存放会话信息（验证码、登录信息等等），分布式各种功能（分布式非阻塞式锁、分布式 ID 生成等等）。

Redis 剩余的各种细碎应用只需要根据需求选择合适的数据类型即可。

## Redis 缓存

### 二级缓存

对于高频数据添加 Redis 缓存可以有效缩短请求时间，减轻关系型数据库比如 mysql 的负载压力。

二级缓存的增删改查

- 增：直接在 mysql 中增加相应条目
- 删：先删除 Redis 中对应条目（不论是否存在），再删 mysql 中对应的条目
- 改：先修改 mysql 中对应的条目，再删除 Redis 中对应条目（不论是否存在）
- 查：如果 Redis 命中就直接返回，如果没命中再查 mysql，查不到就返回空，查到就放到 Redis 中然后返回。

二级缓存的增删改查一定要互斥执行，锁用 synchronized 或 Redis 分布式锁甚至自己写的锁都行，但是一定要上锁否则会出现很多数据一致性问题。

### 缓存穿透

攻击者发起大量关于不存在条目的请求，都会穿透缓存打到 mysql 上，给数据库造成巨大压力。解决方式是如果遇到空查询就往缓存中放相应的空条目，这样关于此条目的查询除了第一次会直接打到数据库上，之后都会被缓存拦截。

### 缓存雪崩

同一时间大量 key 失效，或缓存直接宕机导致大量流量直接打到数据库。解决方式是尽量避免同一时间大量 key 失效，比如缓存失效时间加随机值。

### 缓存击穿

热点 key 失效导致产生高并发的缓存重建，给数据库和服务器带来压力。解决方式有两种，第一种方式是由最早的线程进行缓存重建，其他的线程轮询等待，直到缓存重建完成后所有的线程再返回最新数据。第二种方式是由最早的线程单开一个线程进行缓存重建，所有的线程在重建完成前都先直接返回旧数据，采用这种方式时不能为 Redis 中的 key 设置 expire 时间，而是需要使用逻辑时间。需要注意的是这两种方式都需要上锁来保证最早的线程能够执行相应代码。
