---
title: 阻塞非阻塞、同步异步与多路复用
date: 2023-11-17 19:46:57
tags: [计算机基础, 计算机网络, 八股文]
---

# 阻塞非阻塞、同步异步与多路复用

下面将统一以网络 IO 经典函数 accept 和 read 进行阐述。

## 阻塞与非阻塞

### 阻塞 read

系统调用陷入内核态，操作系统服务函数查看内核缓冲区中是否有数据，如果有数据则返回（这里分两种情况，如果内核缓冲区当前数据长度多于传进来的 buffer，则填满 buffer 返回，如果内核缓冲区数据长度不足 buffer，则会把缓冲区中所有数据都填入 buffer 中返回），如果没有数据，则操作系统服务进程阻塞，当网卡中收到数据时会将数据同步到操作系统内存（网络缓冲区）中，同时唤醒操作系统服务进程，操作系统服务进程将数据从内核内存复制到用户内存然后返回用户态。

### 非阻塞 read

和阻塞 read 的唯一区别在于，当系统调用发现内核缓冲区没有数据时会立刻返回用户态继续执行。

### 阻塞 accept

同阻塞 read 类似，系统调用后查看缓冲区中是否有 tcp 连接建立请求，有则取其中一个 tcp 连接建立请求，经过 tcp 三次握手建立 tcp 连接，进行内核态相关资源的分配（如 tcp 接收/发送缓冲区内存），然后返回用户态相应的 socket。如果缓冲区中没有 tcp 连接建立请求，则操作系统服务进程阻塞并等待连接的到来。

需要说明的是，linux 内核中有两个队列，半连接队列用来存放目前刚进行一次握手（只收到客户端 SYN）的“刚进行一半的连接”，全连接队列用来存放目前已经进行了三次握手的“已经完成的连接”，其中任何连接都是先进入半连接队列再进入全连接队列的。每次 accept 其实就是查看全连接队列，并从中取出一个已经三次握手完成的连接。也就是说，所有 accept 接收的连接其实已经进行过三次握手了。全连接队列满的时候客户端再来连接就会连接失败，全连接队列的最大长度（backlog 参数）可以通过 linux 操作系统中的相关配置文件进行设定。

### 非阻塞 accept

和阻塞 accept 的唯一区别在于，当系统调用发现内核缓冲区没有 tcp 连接建立请求时会立刻返回用户态继续执行。

## 同步与异步

### 同步

不同关注两个过程在时间上具有严格的先后顺序，同步并不关心有几个进程/线程，比如说 A 操作要在 B 操作开始之前完成，无论是单线程先执行 A 操作再执行 B 操作，还是多线程中某个线程执行完 B 操作后给另一个线程发信号让其开始执行 A 操作，其实都是同步的。

### 异步

异步不关注两个过程在时间上的顺序，但是异步要求至少有两个进程/线程并发执行。比如一个线程在某个时刻产生了一个任务，则这个任务被交由其他线程处理（处理时间可能很长/很短，可能立即开始处理，也可能过一段时间才会开始处理），处理结束后把结果通过线程间通信的方式返回原线程。

## IO 模型

以网络 IO 模型为例，以 accept 和 read 组成，面向并发连接。

### 同步阻塞 IO

假如使用阻塞 IO，则单线程是一定不行的，因为多个不同的阻塞操作之间会互相影响。只能一个线程 accept，建立连接后开一个新的线程负责 read 这个连接。这种方式的缺点是无法应对高并发连接，因为我们不可能开特别多的线程，因为线程/进程本身的建立/销毁/调度是消耗资源的。

单线程一定是同步的。

### 同步非阻塞 IO

如果使用非阻塞 IO，则单线程就可以处理高并发，在每一次循环中，先 accept 一下，然后对于维护的所有 socket，每个 socket 去 read 一下。这种方式的缺点是，假如一段时间不存在 tcp 连接建立请求，所有 tcp 连接也不发任何信息，因为不存在阻塞所以这时 cpu 会大量空转。

单线程一定是同步的。

### 同步多路复用 IO

为了利用阻塞的优点并且避免多个阻塞操作相互影响，多路复用采用事件机制将所有的操作汇聚成了一个阻塞操作，即 select 操作。select 操作会阻塞的查看缓冲区中的所有事件（可以是 accept 事件，也可以是某个 socket 的 read 事件等等）。这样我们就可以在每一次循环中，先 select 函数返回所有的事件，再依次处理所有的事件（比如出现了某个 socket 的 read 事件，这时候就要调这个 socket 的 read 函数去读数据，显然此时无论是阻塞 read 还是非阻塞 read 都是能立刻读到数据的）。

单线程一定是同步的。

### 异步非阻塞 IO

举一个异步非阻塞 read 操作的例子，首先 read 系统调用陷入内核态，查看内核缓冲区发现没有数据，因为是非阻塞的所以要马上返回，但是可以在返回之前开启另一个异步线程，异步线程阻塞等待 IO 数据，并在拿到 IO 数据之后通过线程间通信的方式将数据发送给主线程。

注意异步阻塞 IO 是不存在的，原因是异步是开多线程的，此时就不需要阻塞等待了。
