---
title: 事务
date: 2023-10-29 13:23:12
tags: [计算机基础, 数据库, 八股文]
---

# 事务

### 没有事务时，数据库如何保证并发客户端的数据一致性

假设当前有多个客户端连接着数据库，则数据库这边肯定有一些并发线程，每个并发线程都有一个 crud 语句的队列，里面装着客户端发来的增删改查语句，数据库会给每行数据都上一个行锁，这是一个读写锁，即读时可以并发读，不能写，写时既不能并发读也不能并发写，因此数据库所有连接的 crud 队列如果不操作同一行数据就直接并发执行，但如果涉及到操作同一行数据，则行锁会通过一定程度的串行化保证数据的一致性。

因此可以说 mysql 数据库中多客户端并发对于同一行数据的增删改查的数据一致性问题是由 mysql 的行锁来保证的，所以任何 mysql 客户端进行一次增删改查都可以认为是在那一时刻进行的。

### 为什么要有事务

事务来源于一个需求就是所有 sql 语句要么都执行，要么都不执行，如果只执行一半就会导致逻辑问题。比如说银行转钱（给一个人扣钱，给一个人加钱），或者是存数据（先存一个表，然后存另一个表）...
因此为了满足事务的需求，数据库支持了回滚机制，即开启一段事务，执行了一些增上改查语句后，可以选择提交或者回滚。

回滚机制的实际实现是，数据库在某个客户端开启事务后，创建一个局部数据快照，该数据快照从数据主干中独立出来，之后事务中所有的 dml 增删改都是在数据快照上进行的，而查询时既可以查到快照数据也可以查到主干数据，如果事务结束时选择回滚，数据库则直接删除数据快照，如果选择提交，则将快照上的数据合并回主干。

### 并发事务产生的数据一致性问题以及数据库采用的相应解决方案

并发事务会产生三种问题，其中脏读一定是逻辑性问题，不可重复读和幻读是否是逻辑性问题取决于具体业务

- 脏读：事务中读到了可能并不存在的数据。原因是 B 事务读到了 A 事务未提交的数据，由于 A 事务之后可能会回滚，所以 B 事务读到的是脏数据。
- 不可重复读：事务中多次读同一行，发现读出来的数据不一样。原因是 B 事务的第一次读和第二次读之间，A 事务提交了关于该行数据的修改。
- 幻读：事务中多次读同一行，发现之前有这一行之后没有了，或者之前没有这一行之后又有了。原因是 B 事务的第一次读和第二次读之间，A 事务提交了关于该行数据的增删。

数据库提供了四种隔离界别，分别是读未提交、读已提交、可重复读和串行化，从左到右它们的数据一致性越来越高、并发程度越来越低。mysql 数据库默认隔离级别是可重复读，因为在实际业务中幻读一般问题不大。

- 读未提交：A 事务的增删改在没提交时直接影响到了主干数据，从而导致 B 事务出现了脏读。
- 读已提交：A 事务的增删改在没提交时不会影响主干数据，从而导致 B 事务读不到未提交的增删改，但是能够读到已提交的增删改。
- 可重复读：B 事务第一次读某一行的时候，会为这一行上一个行锁（读写锁），B 事务在自己事务结束时才会释放这个锁，这也意味着如果 A 事务在 B 事务结束前提交时，如果 A 事务涉及到修改了这一行，则 A 事务的提交会因为拿不到锁而阻塞等待，因此 B 事务在结束前即使多次读了这一行，也不会产生数据一致性问题。
- 串行化：所有事务串行化互斥执行，因此不会出现任何数据一致性问题。
